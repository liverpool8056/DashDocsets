<h1 id="nginx-api-for-lua">Nginx API for Lua</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#ngxarg">ngx.arg</a></li>
<li><a href="#ngxvarvariable">ngx.var.VARIABLE</a></li>
<li><a href="#core-constants">Core constants</a></li>
<li><a href="#http-method-constants">HTTP method constants</a></li>
<li><a href="#http-status-constants">HTTP status constants</a></li>
<li><a href="#nginx-log-level-constants">Nginx log level
constants</a></li>
<li><a href="#print">print</a></li>
<li><a href="#ngxctx">ngx.ctx</a></li>
<li><a href="#ngxlocationcapture">ngx.location.capture</a></li>
<li><a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a></li>
<li><a href="#ngxstatus">ngx.status</a></li>
<li><a href="#ngxheaderheader">ngx.header.HEADER</a></li>
<li><a href="#ngxrespget_headers">ngx.resp.get_headers</a></li>
<li><a href="#ngxreqis_internal">ngx.req.is_internal</a></li>
<li><a href="#ngxreqstart_time">ngx.req.start_time</a></li>
<li><a href="#ngxreqhttp_version">ngx.req.http_version</a></li>
<li><a href="#ngxreqraw_header">ngx.req.raw_header</a></li>
<li><a href="#ngxreqget_method">ngx.req.get_method</a></li>
<li><a href="#ngxreqset_method">ngx.req.set_method</a></li>
<li><a href="#ngxreqset_uri">ngx.req.set_uri</a></li>
<li><a href="#ngxreqset_uri_args">ngx.req.set_uri_args</a></li>
<li><a href="#ngxreqget_uri_args">ngx.req.get_uri_args</a></li>
<li><a href="#ngxreqget_post_args">ngx.req.get_post_args</a></li>
<li><a href="#ngxreqget_headers">ngx.req.get_headers</a></li>
<li><a href="#ngxreqset_header">ngx.req.set_header</a></li>
<li><a href="#ngxreqclear_header">ngx.req.clear_header</a></li>
<li><a href="#ngxreqread_body">ngx.req.read_body</a></li>
<li><a href="#ngxreqdiscard_body">ngx.req.discard_body</a></li>
<li><a href="#ngxreqget_body_data">ngx.req.get_body_data</a></li>
<li><a href="#ngxreqget_body_file">ngx.req.get_body_file</a></li>
<li><a href="#ngxreqset_body_data">ngx.req.set_body_data</a></li>
<li><a href="#ngxreqset_body_file">ngx.req.set_body_file</a></li>
<li><a href="#ngxreqinit_body">ngx.req.init_body</a></li>
<li><a href="#ngxreqappend_body">ngx.req.append_body</a></li>
<li><a href="#ngxreqfinish_body">ngx.req.finish_body</a></li>
<li><a href="#ngxreqsocket">ngx.req.socket</a></li>
<li><a href="#ngxexec">ngx.exec</a></li>
<li><a href="#ngxredirect">ngx.redirect</a></li>
<li><a href="#ngxsend_headers">ngx.send_headers</a></li>
<li><a href="#ngxheaders_sent">ngx.headers_sent</a></li>
<li><a href="#ngxprint">ngx.print</a></li>
<li><a href="#ngxsay">ngx.say</a></li>
<li><a href="#ngxlog">ngx.log</a></li>
<li><a href="#ngxflush">ngx.flush</a></li>
<li><a href="#ngxexit">ngx.exit</a></li>
<li><a href="#ngxeof">ngx.eof</a></li>
<li><a href="#ngxsleep">ngx.sleep</a></li>
<li><a href="#ngxescape_uri">ngx.escape_uri</a></li>
<li><a href="#ngxunescape_uri">ngx.unescape_uri</a></li>
<li><a href="#ngxencode_args">ngx.encode_args</a></li>
<li><a href="#ngxdecode_args">ngx.decode_args</a></li>
<li><a href="#ngxencode_base64">ngx.encode_base64</a></li>
<li><a href="#ngxdecode_base64">ngx.decode_base64</a></li>
<li><a href="#ngxdecode_base64mime">ngx.decode_base64mime</a></li>
<li><a href="#ngxcrc32_short">ngx.crc32_short</a></li>
<li><a href="#ngxcrc32_long">ngx.crc32_long</a></li>
<li><a href="#ngxhmac_sha1">ngx.hmac_sha1</a></li>
<li><a href="#ngxmd5">ngx.md5</a></li>
<li><a href="#ngxmd5_bin">ngx.md5_bin</a></li>
<li><a href="#ngxsha1_bin">ngx.sha1_bin</a></li>
<li><a href="#ngxquote_sql_str">ngx.quote_sql_str</a></li>
<li><a href="#ngxtoday">ngx.today</a></li>
<li><a href="#ngxtime">ngx.time</a></li>
<li><a href="#ngxnow">ngx.now</a></li>
<li><a href="#ngxupdate_time">ngx.update_time</a></li>
<li><a href="#ngxlocaltime">ngx.localtime</a></li>
<li><a href="#ngxutctime">ngx.utctime</a></li>
<li><a href="#ngxcookie_time">ngx.cookie_time</a></li>
<li><a href="#ngxhttp_time">ngx.http_time</a></li>
<li><a href="#ngxparse_http_time">ngx.parse_http_time</a></li>
<li><a href="#ngxis_subrequest">ngx.is_subrequest</a></li>
<li><a href="#ngxrematch">ngx.re.match</a></li>
<li><a href="#ngxrefind">ngx.re.find</a></li>
<li><a href="#ngxregmatch">ngx.re.gmatch</a></li>
<li><a href="#ngxresub">ngx.re.sub</a></li>
<li><a href="#ngxregsub">ngx.re.gsub</a></li>
<li><a href="#ngxshareddict">ngx.shared.DICT</a></li>
<li><a href="#ngxshareddictget">ngx.shared.DICT.get</a></li>
<li><a href="#ngxshareddictget_stale">ngx.shared.DICT.get_stale</a></li>
<li><a href="#ngxshareddictset">ngx.shared.DICT.set</a></li>
<li><a href="#ngxshareddictsafe_set">ngx.shared.DICT.safe_set</a></li>
<li><a href="#ngxshareddictadd">ngx.shared.DICT.add</a></li>
<li><a href="#ngxshareddictsafe_add">ngx.shared.DICT.safe_add</a></li>
<li><a href="#ngxshareddictreplace">ngx.shared.DICT.replace</a></li>
<li><a href="#ngxshareddictdelete">ngx.shared.DICT.delete</a></li>
<li><a href="#ngxshareddictincr">ngx.shared.DICT.incr</a></li>
<li><a href="#ngxshareddictlpush">ngx.shared.DICT.lpush</a></li>
<li><a href="#ngxshareddictrpush">ngx.shared.DICT.rpush</a></li>
<li><a href="#ngxshareddictlpop">ngx.shared.DICT.lpop</a></li>
<li><a href="#ngxshareddictrpop">ngx.shared.DICT.rpop</a></li>
<li><a href="#ngxshareddictllen">ngx.shared.DICT.llen</a></li>
<li><a href="#ngxshareddictttl">ngx.shared.DICT.ttl</a></li>
<li><a href="#ngxshareddictexpire">ngx.shared.DICT.expire</a></li>
<li><a href="#ngxshareddictflush_all">ngx.shared.DICT.flush_all</a></li>
<li><a
href="#ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</a></li>
<li><a href="#ngxshareddictget_keys">ngx.shared.DICT.get_keys</a></li>
<li><a href="#ngxshareddictcapacity">ngx.shared.DICT.capacity</a></li>
<li><a
href="#ngxshareddictfree_space">ngx.shared.DICT.free_space</a></li>
<li><a href="#ngxsocketudp">ngx.socket.udp</a></li>
<li><a href="#udpsockbind">udpsock:bind</a></li>
<li><a href="#udpsocksetpeername">udpsock:setpeername</a></li>
<li><a href="#udpsocksend">udpsock:send</a></li>
<li><a href="#udpsockreceive">udpsock:receive</a></li>
<li><a href="#udpsockclose">udpsock:close</a></li>
<li><a href="#udpsocksettimeout">udpsock:settimeout</a></li>
<li><a href="#ngxsocketstream">ngx.socket.stream</a></li>
<li><a href="#ngxsockettcp">ngx.socket.tcp</a></li>
<li><a href="#tcpsockbind">tcpsock:bind</a></li>
<li><a href="#tcpsockconnect">tcpsock:connect</a></li>
<li><a href="#getfd">tcpsock:getfd</a></li>
<li><a href="#tcpsocksetclientcert">tcpsock:setclientcert</a></li>
<li><a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a></li>
<li><a href="#tcpsocksend">tcpsock:send</a></li>
<li><a href="#tcpsockreceive">tcpsock:receive</a></li>
<li><a href="#tcpsockreceiveany">tcpsock:receiveany</a></li>
<li><a href="#tcpsockreceiveuntil">tcpsock:receiveuntil</a></li>
<li><a href="#tcpsockclose">tcpsock:close</a></li>
<li><a href="#tcpsocksettimeout">tcpsock:settimeout</a></li>
<li><a href="#tcpsocksettimeouts">tcpsock:settimeouts</a></li>
<li><a href="#tcpsocksetoption">tcpsock:setoption</a></li>
<li><a href="#tcpsocksetkeepalive">tcpsock:setkeepalive</a></li>
<li><a href="#tcpsockgetreusedtimes">tcpsock:getreusedtimes</a></li>
<li><a href="#ngxsocketconnect">ngx.socket.connect</a></li>
<li><a href="#ngxget_phase">ngx.get_phase</a></li>
<li><a href="#ngxthreadspawn">ngx.thread.spawn</a></li>
<li><a href="#ngxthreadwait">ngx.thread.wait</a></li>
<li><a href="#ngxthreadkill">ngx.thread.kill</a></li>
<li><a href="#ngxon_abort">ngx.on_abort</a></li>
<li><a href="#ngxtimerat">ngx.timer.at</a></li>
<li><a href="#ngxtimerevery">ngx.timer.every</a></li>
<li><a href="#ngxtimerrunning_count">ngx.timer.running_count</a></li>
<li><a href="#ngxtimerpending_count">ngx.timer.pending_count</a></li>
<li><a href="#ngxconfigsubsystem">ngx.config.subsystem</a></li>
<li><a href="#ngxconfigdebug">ngx.config.debug</a></li>
<li><a href="#ngxconfigprefix">ngx.config.prefix</a></li>
<li><a href="#ngxconfignginx_version">ngx.config.nginx_version</a></li>
<li><a
href="#ngxconfignginx_configure">ngx.config.nginx_configure</a></li>
<li><a
href="#ngxconfigngx_lua_version">ngx.config.ngx_lua_version</a></li>
<li><a href="#ngxworkerexiting">ngx.worker.exiting</a></li>
<li><a href="#ngxworkerpid">ngx.worker.pid</a></li>
<li><a href="#ngxworkerpids">ngx.worker.pids</a></li>
<li><a href="#ngxworkercount">ngx.worker.count</a></li>
<li><a href="#ngxworkerid">ngx.worker.id</a></li>
<li><a href="#ngxsemaphore">ngx.semaphore</a></li>
<li><a href="#ngxbalancer">ngx.balancer</a></li>
<li><a href="#ngxssl">ngx.ssl</a></li>
<li><a href="#ngxocsp">ngx.ocsp</a></li>
<li><a href="#ndkset_vardirective">ndk.set_var.DIRECTIVE</a></li>
<li><a href="#coroutinecreate">coroutine.create</a></li>
<li><a href="#coroutineresume">coroutine.resume</a></li>
<li><a href="#coroutineyield">coroutine.yield</a></li>
<li><a href="#coroutinewrap">coroutine.wrap</a></li>
<li><a href="#coroutinerunning">coroutine.running</a></li>
<li><a href="#coroutinestatus">coroutine.status</a></li>
<li><a href="#ngxrun_worker_thread">ngx.run_worker_thread</a></li>
</ul>
<p><a href="#table-of-contents">Back to TOC</a></p>
<h2 id="introduction">Introduction</h2>
<p>The various <code>*_by_lua</code>, <code>*_by_lua_block</code> and
<code>*_by_lua_file</code> configuration directives serve as gateways to
the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API
described below can only be called within the user Lua code run in the
context of these configuration directives.</p>
<p>The API is exposed to Lua in the form of two standard packages
<code>ngx</code> and <code>ndk</code>. These packages are in the default
global scope within ngx_lua and are always available within ngx_lua
directives.</p>
<p>The packages can be introduced into external Lua modules like
this:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">say</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">say</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="cn">_M</span> <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">function</span> <span class="cn">_M</span><span class="op">.</span>foo<span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>     say<span class="op">(</span><span class="va">a</span><span class="op">)</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="cn">_M</span></span></code></pre></div>
<p>Use of the <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-package.seeall">package.seeall</a>
flag is strongly discouraged due to its various bad side-effects.</p>
<p>It is also possible to directly require the packages in external Lua
modules:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ngx</span> <span class="op">=</span> <span class="fu">require</span> <span class="st">&quot;ngx&quot;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ndk</span> <span class="op">=</span> <span class="fu">require</span> <span class="st">&quot;ndk&quot;</span></span></code></pre></div>
<p>The ability to require these packages was introduced in the
<code>v0.2.1rc19</code> release.</p>
<p>Network I/O operations in user code should only be done through the
Nginx Lua API calls as the Nginx event loop may be blocked and
performance drop off dramatically otherwise. Disk operations with
relatively small amount of data can be done using the standard Lua
<code>io</code> library but huge file reading and writing should be
avoided wherever possible as they may block the Nginx process
significantly. Delegating all network and disk I/O operations to Nginx's
subrequests (via the <a
href="#ngxlocationcapture">ngx.location.capture</a> method and similar)
is strongly recommended for maximum performance.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.arg">ngx.arg</h2>
<p><strong>syntax:</strong> <em>val = ngx.arg[index]</em></p>
<p><strong>context:</strong> <em>set_by_lua*,
body_filter_by_lua*</em></p>
<p>When this is used in the context of the <a
href="#set_by_lua">set_by_lua*</a> directives, this table is read-only
and holds the input arguments to the config directives:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a> <span class="va">value</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">arg</span><span class="op">[</span><span class="va">n</span><span class="op">]</span></span></code></pre></div>
<p>Here is an example</p>
<pre class="nginx"><code>
 location /foo {
     set $a 32;
     set $b 56;

     set_by_lua $sum
         &#39;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])&#39;
         $a $b;

     echo $sum;
 }</code></pre>
<p>that writes out <code>88</code>, the sum of <code>32</code> and
<code>56</code>.</p>
<p>When this table is used in the context of <a
href="#body_filter_by_lua">body_filter_by_lua*</a>, the first element
holds the input data chunk to the output filter code and the second
element holds the boolean flag for the "eof" flag indicating the end of
the whole output data stream.</p>
<p>The data chunk and "eof" flag passed to the downstream Nginx output
filters can also be overridden by assigning values directly to the
corresponding table elements. When setting <code>nil</code> or an empty
Lua string value to <code>ngx.arg[1]</code>, no data chunk will be
passed to the downstream Nginx output filters at all.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.var.variable">ngx.var.VARIABLE</h2>
<p><strong>syntax:</strong> <em>ngx.var.VAR_NAME</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, balancer_by_lua*</em></p>
<p>Read and write Nginx variable values.</p>
<pre class="nginx"><code>
 value = ngx.var.some_nginx_variable_name
 ngx.var.some_nginx_variable_name = value</code></pre>
<p>Note that only already defined Nginx variables can be written to. For
example:</p>
<pre class="nginx"><code>
 location /foo {
     set $my_var &#39;&#39;; # this line is required to create $my_var at config time
     content_by_lua_block {
         ngx.var.my_var = 123
         ...
     }
 }</code></pre>
<p>That is, Nginx variables cannot be created on-the-fly. Here is a list
of pre-defined <a href="http://nginx.org/en/docs/varindex.html">Nginx
variables</a>.</p>
<p>Some special Nginx variables like <code>$args</code> and
<code>$limit_rate</code> can be assigned a value, many others are not,
like <code>$query_string</code>, <code>$arg_PARAMETER</code>, and
<code>$http_NAME</code>.</p>
<p>Nginx regex group capturing variables <code>$1</code>,
<code>$2</code>, <code>$3</code>, and etc, can be read by this interface
as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>,
<code>ngx.var[3]</code>, and etc.</p>
<p>Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will
unset the <code>$Foo</code> Nginx variable.</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">var</span><span class="op">.</span><span class="va">args</span> <span class="op">=</span> <span class="kw">nil</span></span></code></pre></div>
<p><strong>CAUTION</strong> When reading from an Nginx variable, Nginx
will allocate memory in the per-request memory pool which is freed only
at request termination. So when you need to read from an Nginx variable
repeatedly in your Lua code, cache the Nginx variable value to your own
Lua variable, for example,</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">val</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">var</span><span class="op">.</span><span class="va">some_var</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a> <span class="co">--- use the val repeatedly later</span></span></code></pre></div>
<p>to prevent (temporary) memory leaking within the current request's
lifetime. Another way of caching the result is to use the <a
href="#ngxctx">ngx.ctx</a> table.</p>
<p>Undefined Nginx variables are evaluated to <code>nil</code> while
uninitialized (but defined) Nginx variables are evaluated to an empty
Lua string.</p>
<p>This API requires a relatively expensive metamethod call and it is
recommended to avoid using it on hot code paths.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="core-constants">Core constants</h2>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span>OK <span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span>ERROR <span class="op">(-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span>AGAIN <span class="op">(-</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span>DONE <span class="op">(-</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span>DECLINED <span class="op">(-</span><span class="dv">5</span><span class="op">)</span></span></code></pre></div>
<p>Note that only three of these constants are utilized by the <a
href="#nginx-api-for-lua">Nginx API for Lua</a> (i.e., <a
href="#ngxexit">ngx.exit</a> accepts <code>ngx.OK</code>,
<code>ngx.ERROR</code>, and <code>ngx.DECLINED</code> as input).</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="va">null</span></span></code></pre></div>
<p>The <code>ngx.null</code> constant is a <code>NULL</code> light
userdata usually used to represent nil values in Lua tables etc and is
similar to the <a
href="http://www.kyne.com.au/~mark/software/lua-cjson.php">lua-cjson</a>
library's <code>cjson.null</code> constant. This constant was first
introduced in the <code>v0.5.0rc5</code> release.</p>
<p>The <code>ngx.DECLINED</code> constant was first introduced in the
<code>v0.5.0rc19</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="http-method-constants">HTTP method constants</h2>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<pre><code>  ngx.HTTP_GET
  ngx.HTTP_HEAD
  ngx.HTTP_PUT
  ngx.HTTP_POST
  ngx.HTTP_DELETE
  ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)
  ngx.HTTP_MKCOL     (added in the v0.8.2 release)
  ngx.HTTP_COPY      (added in the v0.8.2 release)
  ngx.HTTP_MOVE      (added in the v0.8.2 release)
  ngx.HTTP_PROPFIND  (added in the v0.8.2 release)
  ngx.HTTP_PROPPATCH (added in the v0.8.2 release)
  ngx.HTTP_LOCK      (added in the v0.8.2 release)
  ngx.HTTP_UNLOCK    (added in the v0.8.2 release)
  ngx.HTTP_PATCH     (added in the v0.8.2 release)
  ngx.HTTP_TRACE     (added in the v0.8.2 release)</code></pre>
<p>These constants are usually used in <a
href="#ngxlocationcapture">ngx.location.capture</a> and <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a> method
calls.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="http-status-constants">HTTP status constants</h2>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<pre class="nginx"><code>
   value = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release)
   value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release)
   value = ngx.HTTP_OK (200)
   value = ngx.HTTP_CREATED (201)
   value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release)
   value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release)
   value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release)
   value = ngx.HTTP_SPECIAL_RESPONSE (300)
   value = ngx.HTTP_MOVED_PERMANENTLY (301)
   value = ngx.HTTP_MOVED_TEMPORARILY (302)
   value = ngx.HTTP_SEE_OTHER (303)
   value = ngx.HTTP_NOT_MODIFIED (304)
   value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release)
   value = ngx.HTTP_PERMANENT_REDIRECT (308)
   value = ngx.HTTP_BAD_REQUEST (400)
   value = ngx.HTTP_UNAUTHORIZED (401)
   value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release)
   value = ngx.HTTP_FORBIDDEN (403)
   value = ngx.HTTP_NOT_FOUND (404)
   value = ngx.HTTP_NOT_ALLOWED (405)
   value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release)
   value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release)
   value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release)
   value = ngx.HTTP_GONE (410)
   value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release)
   value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release)
   value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release)
   value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release)
   value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
   value = ngx.HTTP_NOT_IMPLEMENTED (501)
   value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501) (kept for compatibility)
   value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release)
   value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
   value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
   value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release)
   value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release)</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="nginx-log-level-constants">Nginx log level constants</h2>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">STDERR</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">EMERG</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">ALERT</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">CRIT</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">WARN</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">NOTICE</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">INFO</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>   <span class="va">ngx</span><span class="op">.</span><span class="cn">DEBUG</span></span></code></pre></div>
<p>These constants are usually used by the <a href="#ngxlog">ngx.log</a>
method.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="print">print</h2>
<p><strong>syntax:</strong> <em>print(...)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Writes argument values into the Nginx <code>error.log</code> file
with the <code>ngx.NOTICE</code> log level.</p>
<p>It is equivalent to</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">NOTICE</span><span class="op">,</span> <span class="op">...)</span></span></code></pre></div>
<p>Lua <code>nil</code> arguments are accepted and result in literal
<code>"nil"</code> strings while Lua booleans result in literal
<code>"true"</code> or <code>"false"</code> strings. And the
<code>ngx.null</code> constant will yield the <code>"null"</code> string
output.</p>
<p>There is a hard coded <code>2048</code> byte limitation on error
message lengths in the Nginx core. This limit includes trailing newlines
and leading time stamps. If the message size exceeds this limit, Nginx
will truncate the message text accordingly. This limit can be manually
modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition
in the <code>src/core/ngx_log.h</code> file in the Nginx source
tree.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.ctx">ngx.ctx</h2>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
exit_worker_by_lua*</em></p>
<p>This table can be used to store per-request Lua context data and has
a life time identical to the current request (as with the Nginx
variables).</p>
<p>Consider the following example,</p>
<pre class="nginx"><code>
 location /test {
     rewrite_by_lua_block {
         ngx.ctx.foo = 76
     }
     access_by_lua_block {
         ngx.ctx.foo = ngx.ctx.foo + 3
     }
     content_by_lua_block {
         ngx.say(ngx.ctx.foo)
     }
 }</code></pre>
<p>Then <code>GET /test</code> will yield the output</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">79</span></span></code></pre></div>
<p>That is, the <code>ngx.ctx.foo</code> entry persists across the
rewrite, access, and content phases of a request.</p>
<p>Every request, including subrequests, has its own copy of the table.
For example:</p>
<pre class="nginx"><code>
 location /sub {
     content_by_lua_block {
         ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)
         ngx.ctx.blah = 32
         ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)
     }
 }

 location /main {
     content_by_lua_block {
         ngx.ctx.blah = 73
         ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)
         local res = ngx.location.capture(&quot;/sub&quot;)
         ngx.print(res.body)
         ngx.say(&quot;main post: &quot;, ngx.ctx.blah)
     }
 }</code></pre>
<p>Then <code>GET /main</code> will give the output</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">main</span> pre: 73</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">sub</span> pre: nil</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">sub</span> post: 32</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">main</span> post: 73</span></code></pre></div>
<p>Here, modification of the <code>ngx.ctx.blah</code> entry in the
subrequest does not affect the one in the parent request. This is
because they have two separate versions of
<code>ngx.ctx.blah</code>.</p>
<p>Internal redirects (triggered by nginx configuration directives like
<code>error_page</code>, <code>try_files</code>, <code>index</code>,
etc.) will destroy the original request <code>ngx.ctx</code> data (if
any) and the new request will have an empty <code>ngx.ctx</code> table.
For instance,</p>
<pre class="nginx"><code>
 location /new {
     content_by_lua_block {
         ngx.say(ngx.ctx.foo)
     }
 }

 location /orig {
     content_by_lua_block {
         ngx.ctx.foo = &quot;hello&quot;
         ngx.exec(&quot;/new&quot;)
     }
 }</code></pre>
<p>Then <code>GET /orig</code> will give</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">nil</span></span></code></pre></div>
<p>rather than the original <code>"hello"</code> value.</p>
<p>Because HTTP request is created after SSL handshake, the
<code>ngx.ctx</code> created in <a
href="#ssl_certificate_by_lua">ssl_certificate_by_lua*</a>, <a
href="#ssl_session_store_by_lua">ssl_session_store_by_lua*</a>, <a
href="#ssl_session_fetch_by_lua">ssl_session_fetch_by_lua*</a> and <a
href="#ssl_client_hello_by_lua">ssl_client_hello_by_lua*</a> is not
available in the following phases like <a
href="#rewrite_by_lua">rewrite_by_lua*</a>.</p>
<p>Since <code>v0.10.18</code>, the <code>ngx.ctx</code> created during
a SSL handshake will be inherited by the requests which share the same
TCP connection established by the handshake. Note that overwrite values
in <code>ngx.ctx</code> in the http request phases (like
<code>rewrite_by_lua*</code>) will only take affect in the current http
request.</p>
<p>Arbitrary data values, including Lua closures and nested tables, can
be inserted into this "magic" table. It also allows the registration of
custom meta methods.</p>
<p>Overriding <code>ngx.ctx</code> with a new Lua table is also
supported, for example,</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">ctx</span> <span class="op">=</span> <span class="op">{</span> <span class="va">foo</span> <span class="op">=</span> <span class="dv">32</span><span class="op">,</span> <span class="va">bar</span> <span class="op">=</span> <span class="dv">54</span> <span class="op">}</span></span></code></pre></div>
<p>When being used in the context of <a
href="#init_worker_by_lua">init_worker_by_lua*</a>, this table just has
the same lifetime of the current Lua handler.</p>
<p>The <code>ngx.ctx</code> lookup requires relatively expensive
metamethod calls and it is much slower than explicitly passing
per-request data along by your own function arguments. So do not abuse
this API for saving your own function arguments because it usually has
quite some performance impact.</p>
<p>Because of the metamethod magic, never "local" the
<code>ngx.ctx</code> table outside your Lua function scope on the Lua
module level due to <a
href="#data-sharing-within-an-nginx-worker">worker-level data
sharing</a>. For example, the following is bad:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- mymodule.lua</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="cn">_M</span> <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a> <span class="co">-- the following line is bad since ngx.ctx is a per-request</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a> <span class="co">-- data while this &lt;code&gt;ctx&lt;/code&gt; variable is on the Lua module level</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a> <span class="co">-- and thus is per-nginx-worker.</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ctx</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">ctx</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">function</span> <span class="cn">_M</span><span class="op">.</span>main<span class="op">()</span></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>     <span class="va">ctx</span><span class="op">.</span><span class="va">foo</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="cn">_M</span></span></code></pre></div>
<p>Use the following instead:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- mymodule.lua</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="cn">_M</span> <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">function</span> <span class="cn">_M</span><span class="op">.</span>main<span class="op">(</span><span class="va">ctx</span><span class="op">)</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>     <span class="va">ctx</span><span class="op">.</span><span class="va">foo</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="cn">_M</span></span></code></pre></div>
<p>That is, let the caller pass the <code>ctx</code> table explicitly
via a function argument.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.location.capture">ngx.location.capture</h2>
<p><strong>syntax:</strong> <em>res = ngx.location.capture(uri,
options?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Issues a synchronous but still non-blocking <em>Nginx Subrequest</em>
using <code>uri</code>.</p>
<p>Nginx's subrequests provide a powerful way to make non-blocking
internal requests to other locations configured with disk file directory
or <em>any</em> other Nginx C modules like <code>ngx_proxy</code>,
<code>ngx_fastcgi</code>, <code>ngx_memc</code>,
<code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua
itself and etc etc etc.</p>
<p>Also note that subrequests just mimic the HTTP interface but there is
<em>no</em> extra HTTP/TCP traffic <em>nor</em> IPC involved. Everything
works internally, efficiently, on the C level.</p>
<p>Subrequests are completely different from HTTP 301/302 redirection
(via <a href="#ngxredirect">ngx.redirect</a>) and internal redirection
(via <a href="#ngxexec">ngx.exec</a>).</p>
<p>You should always read the request body (by either calling <a
href="#ngxreqread_body">ngx.req.read_body</a> or configuring <a
href="#lua_need_request_body">lua_need_request_body</a> on) before
initiating a subrequest.</p>
<p>This API function (as well as <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>) always
buffers the whole response body of the subrequest in memory. Thus, you
should use <a href="#ngxsockettcp">cosockets</a> and streaming
processing instead if you have to handle large subrequest responses.</p>
<p>Here is a basic example:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a> <span class="va">res</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="va">uri</span><span class="op">)</span></span></code></pre></div>
<p>Returns a Lua table with 4 slots: <code>res.status</code>,
<code>res.header</code>, <code>res.body</code>, and
<code>res.truncated</code>.</p>
<p><code>res.status</code> holds the response status code for the
subrequest response.</p>
<p><code>res.header</code> holds all the response headers of the
subrequest and it is a normal Lua table. For multi-value response
headers, the value is a Lua (array) table that holds all the values in
the order that they appear. For instance, if the subrequest response
headers contain the following lines:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">Set-Cookie:</span> a=3</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">Set-Cookie:</span> foo=bar</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">Set-Cookie:</span> baz=blah</span></code></pre></div>
<p>Then <code>res.header["Set-Cookie"]</code> will be evaluated to the
table value <code>{"a=3", "foo=bar", "baz=blah"}</code>.</p>
<p><code>res.body</code> holds the subrequest's response body data,
which might be truncated. You always need to check the
<code>res.truncated</code> boolean flag to see if <code>res.body</code>
contains truncated data. The data truncation here can only be caused by
those unrecoverable errors in your subrequests like the cases that the
remote end aborts the connection prematurely in the middle of the
response body data stream or a read timeout happens when your subrequest
is receiving the response body data from the remote.</p>
<p>URI query strings can be concatenated to URI itself, for
instance,</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a> <span class="va">res</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="st">&#39;/foo/bar?a=3&amp;b=4&#39;</span><span class="op">)</span></span></code></pre></div>
<p>Named locations like <code>@foo</code> are not allowed due to a
limitation in the Nginx core. Use normal locations combined with the
<code>internal</code> directive to prepare internal-only locations.</p>
<p>An optional option table can be fed as the second argument, which
supports the options:</p>
<ul>
<li><code>method</code> specify the subrequest's request method, which
only accepts constants like <code>ngx.HTTP_POST</code>.</li>
<li><code>body</code> specify the subrequest's request body (string
value only).</li>
<li><code>args</code> specify the subrequest's URI query arguments (both
string value and Lua tables are accepted)</li>
<li><code>headers</code> specify the subrequest's request headers (Lua
table only). this headers will override the original headers of the
subrequest.</li>
<li><code>ctx</code> specify a Lua table to be the <a
href="#ngxctx">ngx.ctx</a> table for the subrequest. It can be the
current request's <a href="#ngxctx">ngx.ctx</a> table, which effectively
makes the parent and its subrequest to share exactly the same context
table. This option was first introduced in the <code>v0.3.1rc25</code>
release.</li>
<li><code>vars</code> take a Lua table which holds the values to set the
specified Nginx variables in the subrequest as this option's value. This
option was first introduced in the <code>v0.3.1rc31</code> release.</li>
<li><code>copy_all_vars</code> specify whether to copy over all the
Nginx variable values of the current request to the subrequest in
question. modifications of the Nginx variables in the subrequest will
not affect the current (parent) request. This option was first
introduced in the <code>v0.3.1rc31</code> release.</li>
<li><code>share_all_vars</code> specify whether to share all the Nginx
variables of the subrequest with the current (parent) request.
modifications of the Nginx variables in the subrequest will affect the
current (parent) request. Enabling this option may lead to hard-to-debug
issues due to bad side-effects and is considered bad and harmful. Only
enable this option when you completely know what you are doing.</li>
<li><code>always_forward_body</code> when set to true, the current
(parent) request's request body will always be forwarded to the
subrequest being created if the <code>body</code> option is not
specified. The request body read by either <a
href="#ngxreqread_body">ngx.req.read_body()</a> or <a
href="#lua_need_request_body">lua_need_request_body on</a> will be
directly forwarded to the subrequest without copying the whole request
body data when creating the subrequest (no matter the request body data
is buffered in memory buffers or temporary files). By default, this
option is <code>false</code> and when the <code>body</code> option is
not specified, the request body of the current (parent) request is only
forwarded when the subrequest takes the <code>PUT</code> or
<code>POST</code> request method.</li>
</ul>
<p>Issuing a POST subrequest, for example, can be done as follows</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a> <span class="va">res</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;/foo/bar&#39;</span><span class="op">,</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> <span class="va">method</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_POST</span><span class="op">,</span> <span class="va">body</span> <span class="op">=</span> <span class="st">&#39;hello, world&#39;</span> <span class="op">}</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a> <span class="op">)</span></span></code></pre></div>
<p>See HTTP method constants methods other than POST. The
<code>method</code> option is <code>ngx.HTTP_GET</code> by default.</p>
<p>The <code>args</code> option can specify extra URI arguments, for
instance,</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="st">&#39;/foo?a=1&#39;</span><span class="op">,</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> <span class="va">args</span> <span class="op">=</span> <span class="op">{</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="va">c</span> <span class="op">=</span> <span class="st">&#39;:&#39;</span> <span class="op">}</span> <span class="op">}</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a> <span class="op">)</span></span></code></pre></div>
<p>is equivalent to</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="st">&#39;/foo?a=1&amp;b=3&amp;c=%3a&#39;</span><span class="op">)</span></span></code></pre></div>
<p>that is, this method will escape argument keys and values according
to URI rules and concatenate them together into a complete query string.
The format for the Lua table passed as the <code>args</code> argument is
identical to the format used in the <a
href="#ngxencode_args">ngx.encode_args</a> method.</p>
<p>The <code>args</code> option can also take plain query strings:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="st">&#39;/foo?a=1&#39;</span><span class="op">,</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> <span class="va">args</span> <span class="op">=</span> <span class="st">&#39;b=3&amp;c=%3a&#39;</span> <span class="op">}</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a> <span class="op">)</span></span></code></pre></div>
<p>This is functionally identical to the previous examples.</p>
<p>The <code>share_all_vars</code> option controls whether to share
Nginx variables among the current request and its subrequests. If this
option is set to <code>true</code>, then the current request and
associated subrequests will share the same Nginx variable scope. Hence,
changes to Nginx variables made by a subrequest will affect the current
request.</p>
<p>Care should be taken in using this option as variable scope sharing
can have unexpected side effects. The <code>args</code>,
<code>vars</code>, or <code>copy_all_vars</code> options are generally
preferable instead.</p>
<p>This option is set to <code>false</code> by default</p>
<pre class="nginx"><code>
 location /other {
     set $dog &quot;$dog world&quot;;
     echo &quot;$uri dog: $dog&quot;;
 }

 location /lua {
     set $dog &#39;hello&#39;;
     content_by_lua_block {
         res = ngx.location.capture(&quot;/other&quot;,
             { share_all_vars = true })

         ngx.print(res.body)
         ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)
     }
 }</code></pre>
<p>Accessing location <code>/lua</code> gives</p>
<pre><code>/other dog: hello world
/lua: hello world</code></pre>
<p>The <code>copy_all_vars</code> option provides a copy of the parent
request's Nginx variables to subrequests when such subrequests are
issued. Changes made to these variables by such subrequests will not
affect the parent request or any other subrequests sharing the parent
request's variables.</p>
<pre class="nginx"><code>
 location /other {
     set $dog &quot;$dog world&quot;;
     echo &quot;$uri dog: $dog&quot;;
 }

 location /lua {
     set $dog &#39;hello&#39;;
     content_by_lua_block {
         res = ngx.location.capture(&quot;/other&quot;,
             { copy_all_vars = true })

         ngx.print(res.body)
         ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)
     }
 }</code></pre>
<p>Request <code>GET /lua</code> will give the output</p>
<pre><code>/other dog: hello world
/lua: hello</code></pre>
<p>Note that if both <code>share_all_vars</code> and
<code>copy_all_vars</code> are set to true, then
<code>share_all_vars</code> takes precedence.</p>
<p>In addition to the two settings above, it is possible to specify
values for variables in the subrequest using the <code>vars</code>
option. These variables are set after the sharing or copying of
variables has been evaluated, and provides a more efficient method of
passing specific values to a subrequest over encoding them as URL
arguments and unescaping them in the Nginx config file.</p>
<pre class="nginx"><code>
 location /other {
     content_by_lua_block {
         ngx.say(&quot;dog = &quot;, ngx.var.dog)
         ngx.say(&quot;cat = &quot;, ngx.var.cat)
     }
 }

 location /lua {
     set $dog &#39;&#39;;
     set $cat &#39;&#39;;
     content_by_lua_block {
         res = ngx.location.capture(&quot;/other&quot;,
             { vars = { dog = &quot;hello&quot;, cat = 32 }})

         ngx.print(res.body)
     }
 }</code></pre>
<p>Accessing <code>/lua</code> will yield the output</p>
<pre><code>dog = hello
cat = 32</code></pre>
<p>The <code>headers</code> option can be used to specify the request
headers for the subrequest. The value of this option should be a Lua
table where the keys are the header names and the values are the header
values. For example,</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="va">location</span> <span class="op">/</span>foo <span class="op">{</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    content_by_lua_block <span class="op">{</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">ngx</span><span class="op">.</span>print<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="va">var</span><span class="op">.</span><span class="va">http_x_test</span><span class="op">)</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="va">location</span> <span class="op">/</span>lua <span class="op">{</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    content_by_lua_block <span class="op">{</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">local</span> <span class="va">res</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="op">{</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">headers</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">[</span><span class="st">&quot;X-Test&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;aa&quot;</span><span class="op">,</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">ngx</span><span class="op">.</span>print<span class="op">(</span><span class="va">res</span><span class="op">.</span><span class="va">body</span><span class="op">)</span></span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Accessing <code>/lua</code> will yield the output</p>
<pre><code>aa</code></pre>
<p>The <code>ctx</code> option can be used to specify a custom Lua table
to serve as the <a href="#ngxctx">ngx.ctx</a> table for the
subrequest.</p>
<pre class="nginx"><code>
 location /sub {
     content_by_lua_block {
         ngx.ctx.foo = &quot;bar&quot;;
     }
 }
 location /lua {
     content_by_lua_block {
         local ctx = {}
         res = ngx.location.capture(&quot;/sub&quot;, { ctx = ctx })

         ngx.say(ctx.foo)
         ngx.say(ngx.ctx.foo)
     }
 }</code></pre>
<p>Then request <code>GET /lua</code> gives</p>
<pre><code>bar
nil</code></pre>
<p>It is also possible to use this <code>ctx</code> option to share the
same <a href="#ngxctx">ngx.ctx</a> table between the current (parent)
request and the subrequest:</p>
<pre class="nginx"><code>
 location /sub {
     content_by_lua_block {
         ngx.ctx.foo = &quot;bar&quot;
     }
 }
 location /lua {
     content_by_lua_block {
         res = ngx.location.capture(&quot;/sub&quot;, { ctx = ngx.ctx })
         ngx.say(ngx.ctx.foo)
     }
 }</code></pre>
<p>Request <code>GET /lua</code> yields the output</p>
<pre><code>bar</code></pre>
<p>Note that subrequests issued by <a
href="#ngxlocationcapture">ngx.location.capture</a> inherit all the
request headers of the current request by default and that this may have
unexpected side effects on the subrequest responses. For example, when
using the standard <code>ngx_proxy</code> module to serve subrequests,
an "Accept-Encoding: gzip" header in the main request may result in
gzipped responses that cannot be handled properly in Lua code. Original
request headers should be ignored by setting <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers">proxy_pass_request_headers</a>
to <code>off</code> in subrequest locations.</p>
<p>When the <code>body</code> option is not specified and the
<code>always_forward_body</code> option is false (the default value),
the <code>POST</code> and <code>PUT</code> subrequests will inherit the
request bodies of the parent request (if any).</p>
<p>There is a hard-coded upper limit on the number of subrequests
possible for every main request. In older versions of Nginx, the limit
was <code>50</code> concurrent subrequests and in more recent versions,
Nginx <code>1.9.5</code> onwards, the same limit is changed to limit the
depth of recursive subrequests. When this limit is exceeded, the
following error message is added to the <code>error.log</code> file:</p>
<pre><code>[error] 13983#0: *1 subrequests cycle while processing &quot;/uri&quot;</code></pre>
<p>The limit can be manually modified if required by editing the
definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the
<code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source
tree.</p>
<p>Please also refer to restrictions on capturing locations configured
by <a
href="#locations-configured-by-subrequest-directives-of-other-modules">subrequest
directives of other modules</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.location.capture_multi">ngx.location.capture_multi</h2>
<p><strong>syntax:</strong> <em>res1, res2, ... =
ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ...
})</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Just like <a href="#ngxlocationcapture">ngx.location.capture</a>, but
supports multiple subrequests running in parallel.</p>
<p>This function issues several parallel subrequests specified by the
input table and returns their results in the same order. For
example,</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a> <span class="va">res1</span><span class="op">,</span> <span class="va">res2</span><span class="op">,</span> <span class="va">res3</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture_multi<span class="op">{</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> <span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="op">{</span> <span class="va">args</span> <span class="op">=</span> <span class="st">&quot;a=3&amp;b=4&quot;</span> <span class="op">}</span> <span class="op">},</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> <span class="st">&quot;/bar&quot;</span> <span class="op">},</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> <span class="st">&quot;/baz&quot;</span><span class="op">,</span> <span class="op">{</span> <span class="va">method</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_POST</span><span class="op">,</span> <span class="va">body</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="op">}</span> <span class="op">},</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">res1</span><span class="op">.</span><span class="va">status</span> <span class="op">==</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_OK</span> <span class="cf">then</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">res2</span><span class="op">.</span><span class="va">body</span> <span class="op">==</span> <span class="st">&quot;BLAH&quot;</span> <span class="cf">then</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This function will not return until all the subrequests terminate.
The total latency is the longest latency of the individual subrequests
rather than the sum.</p>
<p>Lua tables can be used for both requests and responses when the
number of subrequests to be issued is not known in advance:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- construct the requests table</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">reqs</span> <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a> <span class="fu">table.insert</span><span class="op">(</span><span class="va">reqs</span><span class="op">,</span> <span class="op">{</span> <span class="st">&quot;/mysql&quot;</span> <span class="op">})</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a> <span class="fu">table.insert</span><span class="op">(</span><span class="va">reqs</span><span class="op">,</span> <span class="op">{</span> <span class="st">&quot;/postgres&quot;</span> <span class="op">})</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a> <span class="fu">table.insert</span><span class="op">(</span><span class="va">reqs</span><span class="op">,</span> <span class="op">{</span> <span class="st">&quot;/redis&quot;</span> <span class="op">})</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a> <span class="fu">table.insert</span><span class="op">(</span><span class="va">reqs</span><span class="op">,</span> <span class="op">{</span> <span class="st">&quot;/memcached&quot;</span> <span class="op">})</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a> <span class="co">-- issue all the requests at once and wait until they all return</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">resps</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture_multi<span class="op">(</span><span class="va">reqs</span><span class="op">)</span></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a> <span class="co">-- loop over the responses table</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> <span class="va">i</span><span class="op">,</span> <span class="va">resp</span> <span class="kw">in</span> <span class="fu">ipairs</span><span class="op">(</span><span class="va">resps</span><span class="op">)</span> <span class="cf">do</span></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- process the response table &quot;resp&quot;</span></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>The <a href="#ngxlocationcapture">ngx.location.capture</a> function
is just a special form of this function. Logically speaking, the <a
href="#ngxlocationcapture">ngx.location.capture</a> can be implemented
like this</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span><span class="va">capture</span> <span class="op">=</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">function</span> <span class="op">(</span><span class="va">uri</span><span class="op">,</span> <span class="va">args</span><span class="op">)</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture_multi<span class="op">({</span> <span class="op">{</span><span class="va">uri</span><span class="op">,</span> <span class="va">args</span><span class="op">}</span> <span class="op">})</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>     <span class="kw">end</span></span></code></pre></div>
<p>Please also refer to restrictions on capturing locations configured
by <a
href="#locations-configured-by-subrequest-directives-of-other-modules">subrequest
directives of other modules</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.status">ngx.status</h2>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*</em></p>
<p>Read and write the current request's response status. This should be
called before sending out the response headers.</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">status</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_CREATED</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a> <span class="va">status</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">status</span></span></code></pre></div>
<p>Setting <code>ngx.status</code> after the response header is sent out
has no effect but leaving an error message in your Nginx's error log
file:</p>
<pre><code>attempt to set ngx.status after sending out response headers</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.header.header">ngx.header.HEADER</h2>
<p><strong>syntax:</strong> <em>ngx.header.HEADER = VALUE</em></p>
<p><strong>syntax:</strong> <em>value = ngx.header.HEADER</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
log_by_lua*</em></p>
<p>Set, add to, or clear the current request's <code>HEADER</code>
response header that is to be sent.</p>
<p>Underscores (<code>_</code>) in the header names will be replaced by
hyphens (<code>-</code>) by default. This transformation can be turned
off via the <a
href="#lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</a>
directive.</p>
<p>The header names are matched case-insensitively.</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- equivalent to ngx.header[&quot;Content-Type&quot;] = &#39;text/plain&#39;</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">.</span><span class="va">content_type</span> <span class="op">=</span> <span class="st">&#39;text/plain&#39;</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">[</span><span class="st">&quot;X-My-Header&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&#39;blah blah&#39;</span></span></code></pre></div>
<p>Multi-value headers can be set this way:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">[</span><span class="st">&#39;Set-Cookie&#39;</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&#39;a=32; path=/&#39;</span><span class="op">,</span> <span class="st">&#39;b=4; path=/&#39;</span><span class="op">}</span></span></code></pre></div>
<p>will yield</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">Set-Cookie:</span> a=32<span class="kw">;</span> <span class="va">path</span><span class="op">=</span>/</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">Set-Cookie:</span> b=4<span class="kw">;</span> <span class="va">path</span><span class="op">=</span>/</span></code></pre></div>
<p>in the response headers.</p>
<p>Only Lua tables are accepted (Only the last element in the table will
take effect for standard headers such as <code>Content-Type</code> that
only accept a single value).</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">.</span><span class="va">content_type</span> <span class="op">=</span> <span class="op">{</span><span class="st">&#39;a&#39;</span><span class="op">,</span> <span class="st">&#39;b&#39;</span><span class="op">}</span></span></code></pre></div>
<p>is equivalent to</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">.</span><span class="va">content_type</span> <span class="op">=</span> <span class="st">&#39;b&#39;</span></span></code></pre></div>
<p>Setting a slot to <code>nil</code> effectively removes it from the
response headers:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">[</span><span class="st">&quot;X-My-Header&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="kw">nil</span></span></code></pre></div>
<p>The same applies to assigning an empty table:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">header</span><span class="op">[</span><span class="st">&quot;X-My-Header&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="op">{}</span></span></code></pre></div>
<p>Setting <code>ngx.header.HEADER</code> after sending out response
headers (either explicitly with <a
href="#ngxsend_headers">ngx.send_headers</a> or implicitly with <a
href="#ngxprint">ngx.print</a> and similar) will log an error
message.</p>
<p>Reading <code>ngx.header.HEADER</code> will return the value of the
response header named <code>HEADER</code>.</p>
<p>Underscores (<code>_</code>) in the header names will also be
replaced by dashes (<code>-</code>) and the header names will be matched
case-insensitively. If the response header is not present at all,
<code>nil</code> will be returned.</p>
<p>This is particularly useful in the context of <a
href="#header_filter_by_lua">header_filter_by_lua*</a>, for example,</p>
<pre class="nginx"><code>
 location /test {
     set $footer &#39;&#39;;

     proxy_pass http://some-backend;

     header_filter_by_lua_block {
         if ngx.header[&quot;X-My-Header&quot;] == &quot;blah&quot; then
             ngx.var.footer = &quot;some value&quot;
         end
     }

     echo_after_body $footer;
 }</code></pre>
<p>For multi-value headers, all of the values of header will be
collected in order and returned as a Lua table. For example, response
headers</p>
<pre><code>Foo: bar
Foo: baz</code></pre>
<p>will result in</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a> <span class="op">{</span><span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span><span class="op">}</span></span></code></pre></div>
<p>to be returned when reading <code>ngx.header.Foo</code>.</p>
<p>Note that <code>ngx.header</code> is not a normal Lua table and as
such, it is not possible to iterate through it using the Lua
<code>ipairs</code> function.</p>
<p>Note: this function throws a Lua error if <code>HEADER</code> or
<code>VALUE</code> contain unsafe characters (control characters).</p>
<p>For reading <em>request</em> headers, use the <a
href="#ngxreqget_headers">ngx.req.get_headers</a> function instead.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.resp.get_headers">ngx.resp.get_headers</h2>
<p><strong>syntax:</strong> <em>headers, err =
ngx.resp.get_headers(max_headers?, raw?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, balancer_by_lua*</em></p>
<p>Returns a Lua table holding all the current response headers for the
current request.</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">h</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">resp</span><span class="op">.</span>get_headers<span class="op">()</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="op">==</span> <span class="st">&quot;truncated&quot;</span> <span class="cf">then</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- one can choose to ignore or reject the current response here</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> <span class="va">k</span><span class="op">,</span> <span class="va">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="op">(</span><span class="va">h</span><span class="op">)</span> <span class="cf">do</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This function has the same signature as <a
href="#ngxreqget_headers">ngx.req.get_headers</a> except getting
response headers instead of request headers.</p>
<p>Note that a maximum of 100 response headers are parsed by default
(including those with the same name) and that additional response
headers are silently discarded to guard against potential denial of
service attacks. Since <code>v0.10.13</code>, when the limit is
exceeded, it will return a second value which is the string
<code>"truncated"</code>.</p>
<p>This API was first introduced in the <code>v0.9.5</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.is_internal">ngx.req.is_internal</h2>
<p><strong>syntax:</strong> <em>is_internal =
ngx.req.is_internal()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*</em></p>
<p>Returns a boolean indicating whether the current request is an
"internal request", i.e., a request initiated from inside the current
Nginx server instead of from the client side.</p>
<p>Subrequests are all internal requests and so are requests after
internal redirects.</p>
<p>This API was first introduced in the <code>v0.9.20</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.start_time">ngx.req.start_time</h2>
<p><strong>syntax:</strong> <em>secs = ngx.req.start_time()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*</em></p>
<p>Returns a floating-point number representing the timestamp (including
milliseconds as the decimal part) when the current request was
created.</p>
<p>The following example emulates the <code>$request_time</code>
variable value (provided by <a
href="http://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a>)
in pure Lua:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">request_time</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span>now<span class="op">()</span> <span class="op">-</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>start_time<span class="op">()</span></span></code></pre></div>
<p>This function was first introduced in the <code>v0.7.7</code>
release.</p>
<p>See also <a href="#ngxnow">ngx.now</a> and <a
href="#ngxupdate_time">ngx.update_time</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.http_version">ngx.req.http_version</h2>
<p><strong>syntax:</strong> <em>num = ngx.req.http_version()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*</em></p>
<p>Returns the HTTP version number for the current request as a Lua
number.</p>
<p>Current possible values are 3.0, 2.0, 1.0, 1.1, and 0.9. Returns
<code>nil</code> for unrecognized values.</p>
<p>This method was first introduced in the <code>v0.7.17</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.raw_header">ngx.req.raw_header</h2>
<p><strong>syntax:</strong> <em>str =
ngx.req.raw_header(no_request_line?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*</em></p>
<p>Returns the original raw HTTP protocol header received by the Nginx
server.</p>
<p>By default, the request line and trailing <code>CR LF</code>
terminator will also be included. For example,</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>print<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>raw_header<span class="op">())</span></span></code></pre></div>
<p>gives something like this:</p>
<pre><code>GET /t HTTP/1.1
Host: localhost
Connection: close
Foo: bar</code></pre>
<p>You can specify the optional <code>no_request_line</code> argument as
a <code>true</code> value to exclude the request line from the result.
For example,</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>print<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>raw_header<span class="op">(</span><span class="kw">true</span><span class="op">))</span></span></code></pre></div>
<p>outputs something like this:</p>
<pre><code>Host: localhost
Connection: close
Foo: bar</code></pre>
<p>This method was first introduced in the <code>v0.7.17</code>
release.</p>
<p>This method does not work in HTTP/2 requests yet.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.get_method">ngx.req.get_method</h2>
<p><strong>syntax:</strong> <em>method_name =
ngx.req.get_method()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, balancer_by_lua*, log_by_lua*</em></p>
<p>Retrieves the current request's request method name. Strings like
<code>"GET"</code> and <code>"POST"</code> are returned instead of
numerical <a href="#http-method-constants">method constants</a>.</p>
<p>If the current request is an Nginx subrequest, then the subrequest's
method name will be returned.</p>
<p>This method was first introduced in the <code>v0.5.6</code>
release.</p>
<p>See also <a href="#ngxreqset_method">ngx.req.set_method</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.set_method">ngx.req.set_method</h2>
<p><strong>syntax:</strong> <em>ngx.req.set_method(method_id)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*</em></p>
<p>Overrides the current request's request method with the
<code>method_id</code> argument. Currently only numerical <a
href="#http-method-constants">method constants</a> are supported, like
<code>ngx.HTTP_POST</code> and <code>ngx.HTTP_GET</code>.</p>
<p>If the current request is an Nginx subrequest, then the subrequest's
method will be overridden.</p>
<p>This method was first introduced in the <code>v0.5.6</code>
release.</p>
<p>See also <a href="#ngxreqget_method">ngx.req.get_method</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.set_uri">ngx.req.set_uri</h2>
<p><strong>syntax:</strong> <em>ngx.req.set_uri(uri, jump?,
binary?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*</em></p>
<p>Rewrite the current request's (parsed) URI by the <code>uri</code>
argument. The <code>uri</code> argument must be a Lua string and cannot
be of zero length, or a Lua exception will be thrown.</p>
<p>The optional boolean <code>jump</code> argument can trigger location
rematch (or location jump) as <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>'s
<a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite">rewrite</a>
directive, that is, when <code>jump</code> is <code>true</code> (default
to <code>false</code>), this function will never return and it will tell
Nginx to try re-searching locations with the new URI value at the later
<code>post-rewrite</code> phase and jumping to the new location.</p>
<p>Location jump will not be triggered otherwise, and only the current
request's URI will be modified, which is also the default behavior. This
function will return but with no returned values when the
<code>jump</code> argument is <code>false</code> or absent
altogether.</p>
<p>For example, the following Nginx config snippet</p>
<pre class="nginx"><code>
 rewrite ^ /foo last;</code></pre>
<p>can be coded in Lua like this:</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_uri<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="kw">true</span><span class="op">)</span></span></code></pre></div>
<p>Similarly, Nginx config</p>
<pre class="nginx"><code>
 rewrite ^ /foo break;</code></pre>
<p>can be coded in Lua as</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_uri<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="kw">false</span><span class="op">)</span></span></code></pre></div>
<p>or equivalently,</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_uri<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">)</span></span></code></pre></div>
<p>The <code>jump</code> argument can only be set to <code>true</code>
in <a href="#rewrite_by_lua">rewrite_by_lua*</a>. Use of jump in other
contexts is prohibited and will throw out a Lua exception.</p>
<p>A more sophisticated example involving regex substitutions is as
follows</p>
<pre class="nginx"><code>
 location /test {
     rewrite_by_lua_block {
         local uri = ngx.re.sub(ngx.var.uri, &quot;^/test/(.*)&quot;, &quot;/$1&quot;, &quot;o&quot;)
         ngx.req.set_uri(uri)
     }
     proxy_pass http://my_backend;
 }</code></pre>
<p>which is functionally equivalent to</p>
<pre class="nginx"><code>
 location /test {
     rewrite ^/test/(.*) /$1 break;
     proxy_pass http://my_backend;
 }</code></pre>
<p>Note: this function throws a Lua error if the <code>uri</code>
argument contains unsafe characters (control characters).</p>
<p>Note that it is not possible to use this interface to rewrite URI
arguments and that <a
href="#ngxreqset_uri_args">ngx.req.set_uri_args</a> should be used for
this instead. For instance, Nginx config</p>
<pre class="nginx"><code>
 rewrite ^ /foo?a=3? last;</code></pre>
<p>can be coded as</p>
<pre class="nginx"><code>
 ngx.req.set_uri_args(&quot;a=3&quot;)
 ngx.req.set_uri(&quot;/foo&quot;, true)</code></pre>
<p>or</p>
<pre class="nginx"><code>
 ngx.req.set_uri_args({a = 3})
 ngx.req.set_uri(&quot;/foo&quot;, true)</code></pre>
<p>Starting from <code>0.10.16</code> of this module, this function
accepts an optional boolean <code>binary</code> argument to allow
arbitrary binary URI data. By default, this <code>binary</code> argument
is false and this function will throw out a Lua error such as the one
below when the <code>uri</code> argument contains any control characters
(ASCII Code 0 ~ 0x08, 0x0A ~ 0x1F and 0x7F).</p>
<pre><code>[error] 23430#23430: *1 lua entry thread aborted: runtime error:
content_by_lua(nginx.conf:44):3: ngx.req.set_uri unsafe byte &quot;0x00&quot;
in &quot;\x00foo&quot; (maybe you want to set the &#39;binary&#39; argument?)</code></pre>
<p>This interface was first introduced in the <code>v0.3.1rc14</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.set_uri_args">ngx.req.set_uri_args</h2>
<p><strong>syntax:</strong> <em>ngx.req.set_uri_args(args)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*</em></p>
<p>Rewrite the current request's URI query arguments by the
<code>args</code> argument. The <code>args</code> argument can be either
a Lua string, as in</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_uri_args<span class="op">(</span><span class="st">&quot;a=3&amp;b=hello%20world&quot;</span><span class="op">)</span></span></code></pre></div>
<p>or a Lua table holding the query arguments' key-value pairs, as
in</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_uri_args<span class="op">({</span> <span class="va">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="va">b</span> <span class="op">=</span> <span class="st">&quot;hello world&quot;</span> <span class="op">})</span></span></code></pre></div>
<p>In the former case, i.e., when the whole query-string is provided
directly, the input Lua string should already be well-formed with the
URI encoding. For security considerations, this method will
automatically escape any control and whitespace characters (ASCII code
0x00 ~ 0x20 and 0x7F) in the Lua string.</p>
<p>In the latter case, this method will escape argument keys and values
according to the URI escaping rule.</p>
<p>Multi-value arguments are also supported:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_uri_args<span class="op">({</span> <span class="va">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="va">b</span> <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span> <span class="op">})</span></span></code></pre></div>
<p>which will result in a query string like
<code>a=3&amp;b=5&amp;b=6</code> or
<code>b=5&amp;b=6&amp;a=3</code>.</p>
<p><strong>Note that when using Lua table as the <code>arg</code>
argument, the order of the arguments in the result query string which
change from time to time. If you would like to get an ordered result,
you need to use Lua string as the <code>arg</code>
argument.</strong></p>
<p>This interface was first introduced in the <code>v0.3.1rc13</code>
release.</p>
<p>See also <a href="#ngxreqset_uri">ngx.req.set_uri</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.get_uri_args">ngx.req.get_uri_args</h2>
<p><strong>syntax:</strong> <em>args, err =
ngx.req.get_uri_args(max_args?, tab?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, balancer_by_lua*</em></p>
<p>Returns a Lua table holding all the current request URL query
arguments. An optional <code>tab</code> argument can be used to reuse
the table returned by this method.</p>
<pre class="nginx"><code>
 location = /test {
     content_by_lua_block {
         local args, err = ngx.req.get_uri_args()

         if err == &quot;truncated&quot; then
             -- one can choose to ignore or reject the current request here
         end

         for key, val in pairs(args) do
             if type(val) == &quot;table&quot; then
                 ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))
             else
                 ngx.say(key, &quot;: &quot;, val)
             end
         end
     }
 }</code></pre>
<p>Then <code>GET /test?foo=bar&amp;bar=baz&amp;bar=blah</code> will
yield the response body</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">foo:</span> bar</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">bar:</span> baz, blah</span></code></pre></div>
<p>Multiple occurrences of an argument key will result in a table value
holding all the values for that key in order.</p>
<p>Keys and values are unescaped according to URI escaping rules. In the
settings above, <code>GET /test?a%20b=1%61+2</code> will yield:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">a</span> b: 1a 2</span></code></pre></div>
<p>Arguments without the <code>=&lt;value&gt;</code> parts are treated
as boolean arguments. <code>GET /test?foo&amp;bar</code> will yield:</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">foo:</span> true</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">bar:</span> true</span></code></pre></div>
<p>That is, they will take Lua boolean values <code>true</code>.
However, they are different from arguments taking empty string values.
<code>GET /test?foo=&amp;bar=</code> will give something like</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">foo:</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">bar:</span></span></code></pre></div>
<p>Empty key arguments are discarded.
<code>GET /test?=hello&amp;=world</code> will yield an empty output for
instance.</p>
<p>Updating query arguments via the Nginx variable <code>$args</code>
(or <code>ngx.var.args</code> in Lua) at runtime is also supported:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">var</span><span class="op">.</span><span class="va">args</span> <span class="op">=</span> <span class="st">&quot;a=3&amp;b=42&quot;</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_uri_args<span class="op">()</span></span></code></pre></div>
<p>Here the <code>args</code> table will always look like</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a> <span class="op">{</span><span class="va">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">42</span><span class="op">}</span></span></code></pre></div>
<p>regardless of the actual request query string.</p>
<p>Note that a maximum of 100 request arguments are parsed by default
(including those with the same name) and that additional request
arguments are silently discarded to guard against potential denial of
service attacks. Since <code>v0.10.13</code>, when the limit is
exceeded, it will return a second value which is the string
<code>"truncated"</code>.</p>
<p>However, the optional <code>max_args</code> function argument can be
used to override this limit:</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_uri_args<span class="op">(</span><span class="dv">10</span><span class="op">)</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="op">==</span> <span class="st">&quot;truncated&quot;</span> <span class="cf">then</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- one can choose to ignore or reject the current request here</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This argument can be set to zero to remove the limit and to process
all request arguments received:</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_uri_args<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>Removing the <code>max_args</code> cap is strongly discouraged.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.get_post_args">ngx.req.get_post_args</h2>
<p><strong>syntax:</strong> <em>args, err =
ngx.req.get_post_args(max_args?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, header_filter_by_lua*, body_filter_by_lua*,
log_by_lua*</em></p>
<p>Returns a Lua table holding all the current request POST query
arguments (of the MIME type
<code>application/x-www-form-urlencoded</code>). Call <a
href="#ngxreqread_body">ngx.req.read_body</a> to read the request body
first or turn on the <a
href="#lua_need_request_body">lua_need_request_body</a> directive to
avoid errors.</p>
<pre class="nginx"><code>
 location = /test {
     content_by_lua_block {
         ngx.req.read_body()
         local args, err = ngx.req.get_post_args()

         if err == &quot;truncated&quot; then
             -- one can choose to ignore or reject the current request here
         end

         if not args then
             ngx.say(&quot;failed to get post args: &quot;, err)
             return
         end
         for key, val in pairs(args) do
             if type(val) == &quot;table&quot; then
                 ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))
             else
                 ngx.say(key, &quot;: &quot;, val)
             end
         end
     }
 }</code></pre>
<p>Then</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a> <span class="co"># Post request with the body &#39;foo=bar&amp;bar=baz&amp;bar=blah&#39;</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">$</span> curl <span class="at">--data</span> <span class="st">&#39;foo=bar&amp;bar=baz&amp;bar=blah&#39;</span> localhost/test</span></code></pre></div>
<p>will yield the response body like</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">foo:</span> bar</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">bar:</span> baz, blah</span></code></pre></div>
<p>Multiple occurrences of an argument key will result in a table value
holding all of the values for that key in order.</p>
<p>Keys and values will be unescaped according to URI escaping
rules.</p>
<p>With the settings above,</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a> <span class="co"># POST request with body &#39;a%20b=1%61+2&#39;</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">$</span> curl <span class="at">-d</span> <span class="st">&#39;a%20b=1%61+2&#39;</span> localhost/test</span></code></pre></div>
<p>will yield:</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">a</span> b: 1a 2</span></code></pre></div>
<p>Arguments without the <code>=&lt;value&gt;</code> parts are treated
as boolean arguments. <code>POST /test</code> with the request body
<code>foo&amp;bar</code> will yield:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">foo:</span> true</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">bar:</span> true</span></code></pre></div>
<p>That is, they will take Lua boolean values <code>true</code>.
However, they are different from arguments taking empty string values.
<code>POST /test</code> with request body <code>foo=&amp;bar=</code>
will return something like</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">foo:</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">bar:</span></span></code></pre></div>
<p>Empty key arguments are discarded. <code>POST /test</code> with body
<code>=hello&amp;=world</code> will yield empty outputs for
instance.</p>
<p>Note that a maximum of 100 request arguments are parsed by default
(including those with the same name) and that additional request
arguments are silently discarded to guard against potential denial of
service attacks. Since <code>v0.10.13</code>, when the limit is
exceeded, it will return a second value which is the string
<code>"truncated"</code>.</p>
<p>However, the optional <code>max_args</code> function argument can be
used to override this limit:</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_post_args<span class="op">(</span><span class="dv">10</span><span class="op">)</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="op">==</span> <span class="st">&quot;truncated&quot;</span> <span class="cf">then</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- one can choose to ignore or reject the current request here</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This argument can be set to zero to remove the limit and to process
all request arguments received:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_post_args<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>Removing the <code>max_args</code> cap is strongly discouraged.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.get_headers">ngx.req.get_headers</h2>
<p><strong>syntax:</strong> <em>headers, err =
ngx.req.get_headers(max_headers?, raw?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*</em></p>
<p>Returns a Lua table holding all the current request headers.</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">h</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_headers<span class="op">()</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="op">==</span> <span class="st">&quot;truncated&quot;</span> <span class="cf">then</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- one can choose to ignore or reject the current request here</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> <span class="va">k</span><span class="op">,</span> <span class="va">v</span> <span class="kw">in</span> <span class="fu">pairs</span><span class="op">(</span><span class="va">h</span><span class="op">)</span> <span class="cf">do</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>To read an individual header:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;Host: &quot;</span><span class="op">,</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_headers<span class="op">()[</span><span class="st">&quot;Host&quot;</span><span class="op">])</span></span></code></pre></div>
<p>Note that the <a href="#ngxvarvariable">ngx.var.HEADER</a> API call,
which uses core <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_">$http_HEADER</a>
variables, may be more preferable for reading individual request
headers.</p>
<p>For multiple instances of request headers such as:</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">Foo:</span> foo</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">Foo:</span> bar</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">Foo:</span> baz</span></code></pre></div>
<p>the value of <code>ngx.req.get_headers()["Foo"]</code> will be a Lua
(array) table such as:</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a> <span class="op">{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span><span class="op">}</span></span></code></pre></div>
<p>Note that a maximum of 100 request headers are parsed by default
(including those with the same name) and that additional request headers
are silently discarded to guard against potential denial of service
attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it
will return a second value which is the string
<code>"truncated"</code>.</p>
<p>However, the optional <code>max_headers</code> function argument can
be used to override this limit:</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">headers</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_headers<span class="op">(</span><span class="dv">10</span><span class="op">)</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="op">==</span> <span class="st">&quot;truncated&quot;</span> <span class="cf">then</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- one can choose to ignore or reject the current request here</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This argument can be set to zero to remove the limit and to process
all request headers received:</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">headers</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_headers<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>Removing the <code>max_headers</code> cap is strongly
discouraged.</p>
<p>Since the <code>0.6.9</code> release, all the header names in the Lua
table returned are converted to the pure lower-case form by default,
unless the <code>raw</code> argument is set to <code>true</code>
(default to <code>false</code>).</p>
<p>Also, by default, an <code>__index</code> metamethod is added to the
resulting Lua table and will normalize the keys to a pure lowercase form
with all underscores converted to dashes in case of a lookup miss. For
example, if a request header <code>My-Foo-Header</code> is present, then
the following invocations will all pick up the value of this header
correctly:</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">headers</span><span class="op">.</span><span class="va">my_foo_header</span><span class="op">)</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">headers</span><span class="op">[</span><span class="st">&quot;My-Foo-Header&quot;</span><span class="op">])</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">headers</span><span class="op">[</span><span class="st">&quot;my-foo-header&quot;</span><span class="op">])</span></span></code></pre></div>
<p>The <code>__index</code> metamethod will not be added when the
<code>raw</code> argument is set to <code>true</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.set_header">ngx.req.set_header</h2>
<p><strong>syntax:</strong> <em>ngx.req.set_header(header_name,
header_value)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*</em></p>
<p>Set the current request's request header named
<code>header_name</code> to value <code>header_value</code>, overriding
any existing ones.</p>
<p>The input Lua string <code>header_name</code> and
<code>header_value</code> should already be well-formed with the URI
encoding. For security considerations, this method will automatically
escape "
",""","(",")",",","/",":",";","?","&lt;","=","&gt;","?","@","[","]","",
"{", "}", 0x00-0x1F, 0x7F-0xFF in <code>header_name</code> and
automatically escape "0x00-0x08, 0x0A-0x0F, 0x7F in
<code>header_value</code>.</p>
<p>By default, all the subrequests subsequently initiated by <a
href="#ngxlocationcapture">ngx.location.capture</a> and <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a> will
inherit the new header.</p>
<p>It is not a Lua's equivalent of nginx <code>proxy_set_header</code>
directive (same is true about <a
href="#ngxreqclear_header">ngx.req.clear_header</a>).
<code>proxy_set_header</code> only affects the upstream request while
<code>ngx.req.set_header</code> change the incoming request. Record the
http headers in the access log file will show the difference. But you
still can use it as an alternative of nginx
<code>proxy_set_header</code> directive as long as you know the
difference.</p>
<p>Here is an example of setting the <code>Content-Type</code>
header:</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_header<span class="op">(</span><span class="st">&quot;Content-Type&quot;</span><span class="op">,</span> <span class="st">&quot;text/css&quot;</span><span class="op">)</span></span></code></pre></div>
<p>The <code>header_value</code> can take an array list of values, for
example,</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_header<span class="op">(</span><span class="st">&quot;Foo&quot;</span><span class="op">,</span> <span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;abc&quot;</span><span class="op">})</span></span></code></pre></div>
<p>will produce two new request headers:</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">Foo:</span> a</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">Foo:</span> abc</span></code></pre></div>
<p>and old <code>Foo</code> headers will be overridden if there is
any.</p>
<p>When the <code>header_value</code> argument is <code>nil</code>, the
request header will be removed. So</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>set_header<span class="op">(</span><span class="st">&quot;X-Foo&quot;</span><span class="op">,</span> <span class="kw">nil</span><span class="op">)</span></span></code></pre></div>
<p>is equivalent to</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>clear_header<span class="op">(</span><span class="st">&quot;X-Foo&quot;</span><span class="op">)</span></span></code></pre></div>
<p>Note: this function throws a Lua error if <code>header_name</code> or
<code>header_value</code> contain unsafe characters (control
characters).</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.clear_header">ngx.req.clear_header</h2>
<p><strong>syntax:</strong>
<em>ngx.req.clear_header(header_name)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*</em></p>
<p>Clears the current request's request header named
<code>header_name</code>. None of the current request's existing
subrequests will be affected but subsequently initiated subrequests will
inherit the change by default.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.read_body">ngx.req.read_body</h2>
<p><strong>syntax:</strong> <em>ngx.req.read_body()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Reads the client request body synchronously without blocking the
Nginx event loop.</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>read_body<span class="op">()</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>get_post_args<span class="op">()</span></span></code></pre></div>
<p>If the request body is already read previously by turning on <a
href="#lua_need_request_body">lua_need_request_body</a> or by using
other modules, then this function does not run and returns
immediately.</p>
<p>If the request body has already been explicitly discarded, either by
the <a href="#ngxreqdiscard_body">ngx.req.discard_body</a> function or
other modules, this function does not run and returns immediately.</p>
<p>In case of errors, such as connection errors while reading the data,
this method will throw out a Lua exception <em>or</em> terminate the
current request with a 500 status code immediately.</p>
<p>The request body data read using this function can be retrieved later
via <a href="#ngxreqget_body_data">ngx.req.get_body_data</a> or,
alternatively, the temporary file name for the body data cached to disk
using <a href="#ngxreqget_body_file">ngx.req.get_body_file</a>. This
depends on</p>
<ol type="1">
<li>whether the current request body is already larger than the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a>,</li>
<li>and whether <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only">client_body_in_file_only</a>
has been switched on.</li>
</ol>
<p>In cases where current request may have a request body and the
request body data is not required, The <a
href="#ngxreqdiscard_body">ngx.req.discard_body</a> function must be
used to explicitly discard the request body to avoid breaking things
under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.discard_body">ngx.req.discard_body</h2>
<p><strong>syntax:</strong> <em>ngx.req.discard_body()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Explicitly discard the request body, i.e., read the data on the
connection and throw it away immediately (without using the request body
by any means).</p>
<p>This function is an asynchronous call and returns immediately.</p>
<p>If the request body has already been read, this function does nothing
and returns immediately.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code>
release.</p>
<p>See also <a href="#ngxreqread_body">ngx.req.read_body</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.get_body_data">ngx.req.get_body_data</h2>
<p><strong>syntax:</strong> <em>data =
ngx.req.get_body_data(max_bytes?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, log_by_lua*</em></p>
<p>Retrieves in-memory request body data. It returns a Lua string rather
than a Lua table holding all the parsed query arguments. Use the <a
href="#ngxreqget_post_args">ngx.req.get_post_args</a> function instead
if a Lua table is required.</p>
<p>The optional <code>max_bytes</code> argument can be used when you
don't need the entire body.</p>
<p>This function returns <code>nil</code> if</p>
<ol type="1">
<li>the request body has not been read,</li>
<li>the request body has been read into disk temporary files,</li>
<li>or the request body has zero size.</li>
</ol>
<p>If the request body has not been read yet, call <a
href="#ngxreqread_body">ngx.req.read_body</a> first (or turn on <a
href="#lua_need_request_body">lua_need_request_body</a> to force this
module to read the request body. This is not recommended however).</p>
<p>If the request body has been read into disk files, try calling the <a
href="#ngxreqget_body_file">ngx.req.get_body_file</a> function
instead.</p>
<p>To force in-memory request bodies, try setting <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a>
to the same size value in <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">client_max_body_size</a>.</p>
<p>Note that calling this function instead of using
<code>ngx.var.request_body</code> or
<code>ngx.var.echo_request_body</code> is more efficient because it can
save one dynamic memory allocation and one data copy.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code>
release.</p>
<p>See also <a
href="#ngxreqget_body_file">ngx.req.get_body_file</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.get_body_file">ngx.req.get_body_file</h2>
<p><strong>syntax:</strong> <em>file_name =
ngx.req.get_body_file()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Retrieves the file name for the in-file request body data. Returns
<code>nil</code> if the request body has not been read or has been read
into memory.</p>
<p>The returned file is read only and is usually cleaned up by Nginx's
memory pool. It should not be manually modified, renamed, or removed in
Lua code.</p>
<p>If the request body has not been read yet, call <a
href="#ngxreqread_body">ngx.req.read_body</a> first (or turn on <a
href="#lua_need_request_body">lua_need_request_body</a> to force this
module to read the request body. This is not recommended however).</p>
<p>If the request body has been read into memory, try calling the <a
href="#ngxreqget_body_data">ngx.req.get_body_data</a> function
instead.</p>
<p>To force in-file request bodies, try turning on <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only">client_body_in_file_only</a>.</p>
<p>Note that this function is also work for balancer phase but it needs
to call <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md#recreate_request">balancer.recreate_request</a>
to make the change take effect after set the request body data or
headers.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code>
release.</p>
<p>See also <a
href="#ngxreqget_body_data">ngx.req.get_body_data</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.set_body_data">ngx.req.set_body_data</h2>
<p><strong>syntax:</strong> <em>ngx.req.set_body_data(data)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, balancer_by_lua*,</em></p>
<p>Set the current request's request body using the in-memory data
specified by the <code>data</code> argument.</p>
<p>If the request body has not been read yet, call <a
href="#ngxreqread_body">ngx.req.read_body</a> first (or turn on <a
href="#lua_need_request_body">lua_need_request_body</a> to force this
module to read the request body. This is not recommended however).
Additionally, the request body must not have been previously discarded
by <a href="#ngxreqdiscard_body">ngx.req.discard_body</a>.</p>
<p>Whether the previous request body has been read into memory or
buffered into a disk file, it will be freed or the disk file will be
cleaned up immediately, respectively.</p>
<p>Note that this function is also work for balancer phase but it needs
to call <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md#recreate_request">balancer.recreate_request</a>
to make the change take effect after set the request body data or
headers.</p>
<p>This function was first introduced in the <code>v0.3.1rc18</code>
release.</p>
<p>See also <a
href="#ngxreqset_body_file">ngx.req.set_body_file</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.set_body_file">ngx.req.set_body_file</h2>
<p><strong>syntax:</strong> <em>ngx.req.set_body_file(file_name,
auto_clean?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, balancer_by_lua*,</em></p>
<p>Set the current request's request body using the in-file data
specified by the <code>file_name</code> argument.</p>
<p>If the request body has not been read yet, call <a
href="#ngxreqread_body">ngx.req.read_body</a> first (or turn on <a
href="#lua_need_request_body">lua_need_request_body</a> to force this
module to read the request body. This is not recommended however).
Additionally, the request body must not have been previously discarded
by <a href="#ngxreqdiscard_body">ngx.req.discard_body</a>.</p>
<p>If the optional <code>auto_clean</code> argument is given a
<code>true</code> value, then this file will be removed at request
completion or the next time this function or <a
href="#ngxreqset_body_data">ngx.req.set_body_data</a> are called in the
same request. The <code>auto_clean</code> is default to
<code>false</code>.</p>
<p>Please ensure that the file specified by the <code>file_name</code>
argument exists and is readable by an Nginx worker process by setting
its permission properly to avoid Lua exception errors.</p>
<p>Whether the previous request body has been read into memory or
buffered into a disk file, it will be freed or the disk file will be
cleaned up immediately, respectively.</p>
<p>This function was first introduced in the <code>v0.3.1rc18</code>
release.</p>
<p>See also <a
href="#ngxreqset_body_data">ngx.req.set_body_data</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.init_body">ngx.req.init_body</h2>
<p><strong>syntax:</strong> <em>ngx.req.init_body(buffer_size?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*</em></p>
<p>Creates a new blank request body for the current request and
initializes the buffer for later request body data writing via the <a
href="#ngxreqappend_body">ngx.req.append_body</a> and <a
href="#ngxreqfinish_body">ngx.req.finish_body</a> APIs.</p>
<p>If the <code>buffer_size</code> argument is specified, then its value
will be used for the size of the memory buffer for body writing with <a
href="#ngxreqappend_body">ngx.req.append_body</a>. If the argument is
omitted, then the value specified by the standard <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size">client_body_buffer_size</a>
directive will be used instead.</p>
<p>When the data can no longer be hold in the memory buffer for the
request body, then the data will be flushed onto a temporary file just
like the standard request body reader in the Nginx core.</p>
<p>It is important to always call the <a
href="#ngxreqfinish_body">ngx.req.finish_body</a> after all the data has
been appended onto the current request body. Also, when this function is
used together with <a href="#ngxreqsocket">ngx.req.socket</a>, it is
required to call <a href="#ngxreqsocket">ngx.req.socket</a>
<em>before</em> this function, or you will get the "request body already
exists" error message.</p>
<p>The usage of this function is often like this:</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>init_body<span class="op">(</span><span class="dv">128</span> <span class="op">*</span> <span class="dv">1024</span><span class="op">)</span>  <span class="co">-- buffer is 128KB</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> <span class="va">chunk</span> <span class="kw">in</span> next_data_chunk<span class="op">()</span> <span class="cf">do</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>append_body<span class="op">(</span><span class="va">chunk</span><span class="op">)</span> <span class="co">-- each chunk can be 4KB</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">req</span><span class="op">.</span>finish_body<span class="op">()</span></span></code></pre></div>
<p>This function can be used with <a
href="#ngxreqappend_body">ngx.req.append_body</a>, <a
href="#ngxreqfinish_body">ngx.req.finish_body</a>, and <a
href="#ngxreqsocket">ngx.req.socket</a> to implement efficient input
filters in pure Lua (in the context of <a
href="#rewrite_by_lua">rewrite_by_lua*</a> or <a
href="#access_by_lua">access_by_lua*</a>), which can be used with other
Nginx content handler or upstream modules like <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>
and <a
href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a>.</p>
<p>This function was first introduced in the <code>v0.5.11</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.append_body">ngx.req.append_body</h2>
<p><strong>syntax:</strong> <em>ngx.req.append_body(data_chunk)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*</em></p>
<p>Append new data chunk specified by the <code>data_chunk</code>
argument onto the existing request body created by the <a
href="#ngxreqinit_body">ngx.req.init_body</a> call.</p>
<p>When the data can no longer be hold in the memory buffer for the
request body, then the data will be flushed onto a temporary file just
like the standard request body reader in the Nginx core.</p>
<p>It is important to always call the <a
href="#ngxreqfinish_body">ngx.req.finish_body</a> after all the data has
been appended onto the current request body.</p>
<p>This function can be used with <a
href="#ngxreqinit_body">ngx.req.init_body</a>, <a
href="#ngxreqfinish_body">ngx.req.finish_body</a>, and <a
href="#ngxreqsocket">ngx.req.socket</a> to implement efficient input
filters in pure Lua (in the context of <a
href="#rewrite_by_lua">rewrite_by_lua*</a> or <a
href="#access_by_lua">access_by_lua*</a>), which can be used with other
Nginx content handler or upstream modules like <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>
and <a
href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a>.</p>
<p>This function was first introduced in the <code>v0.5.11</code>
release.</p>
<p>See also <a href="#ngxreqinit_body">ngx.req.init_body</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.finish_body">ngx.req.finish_body</h2>
<p><strong>syntax:</strong> <em>ngx.req.finish_body()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*</em></p>
<p>Completes the construction process of the new request body created by
the <a href="#ngxreqinit_body">ngx.req.init_body</a> and <a
href="#ngxreqappend_body">ngx.req.append_body</a> calls.</p>
<p>This function can be used with <a
href="#ngxreqinit_body">ngx.req.init_body</a>, <a
href="#ngxreqappend_body">ngx.req.append_body</a>, and <a
href="#ngxreqsocket">ngx.req.socket</a> to implement efficient input
filters in pure Lua (in the context of <a
href="#rewrite_by_lua">rewrite_by_lua*</a> or <a
href="#access_by_lua">access_by_lua*</a>), which can be used with other
Nginx content handler or upstream modules like <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>
and <a
href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a>.</p>
<p>This function was first introduced in the <code>v0.5.11</code>
release.</p>
<p>See also <a href="#ngxreqinit_body">ngx.req.init_body</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.req.socket">ngx.req.socket</h2>
<p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket()</em></p>
<p><strong>syntax:</strong> <em>tcpsock, err =
ngx.req.socket(raw)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Returns a read-only cosocket object that wraps the downstream
connection. Only <a href="#tcpsockreceive">receive</a>, <a
href="#tcpsockreceiveany">receiveany</a> and <a
href="#tcpsockreceiveuntil">receiveuntil</a> methods are supported on
this object.</p>
<p>In case of error, <code>nil</code> will be returned as well as a
string describing the error.</p>
<p><strong>Note:</strong> This method will block while waiting for
client request body to be fully received. Block time depends on the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_timeout">client_body_timeout</a>
directive and maximum body size specified by the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">client_max_body_size</a>
directive. If read timeout occurs or client body size exceeds the
defined limit, this function will not return and
<code>408 Request Time-out</code> or
<code>413 Request Entity Too Large</code> response will be returned to
the client instead.</p>
<p>The socket object returned by this method is usually used to read the
current request's body in a streaming fashion. Do not turn on the <a
href="#lua_need_request_body">lua_need_request_body</a> directive, and
do not mix this call with <a
href="#ngxreqread_body">ngx.req.read_body</a> and <a
href="#ngxreqdiscard_body">ngx.req.discard_body</a>.</p>
<p>If any request body data has been pre-read into the Nginx core
request header buffer, the resulting cosocket object will take care of
this to avoid potential data loss resulting from such pre-reading.
Chunked request bodies are not yet supported in this API.</p>
<p>Since the <code>v0.9.0</code> release, this function accepts an
optional boolean <code>raw</code> argument. When this argument is
<code>true</code>, this function returns a full-duplex cosocket object
wrapping around the raw downstream connection socket, upon which you can
call the <a href="#tcpsockreceive">receive</a>, <a
href="#tcpsockreceiveany">receiveany</a>, <a
href="#tcpsockreceiveuntil">receiveuntil</a>, and <a
href="#tcpsocksend">send</a> methods.</p>
<p>When the <code>raw</code> argument is <code>true</code>, it is
required that no pending data from any previous <a
href="#ngxsay">ngx.say</a>, <a href="#ngxprint">ngx.print</a>, or <a
href="#ngxsend_headers">ngx.send_headers</a> calls exists. So if you
have these downstream output calls previously, you should call <a
href="#ngxflush">ngx.flush(true)</a> before calling
<code>ngx.req.socket(true)</code> to ensure that there is no pending
output data. If the request body has not been read yet, then this "raw
socket" can also be used to read the request body.</p>
<p>You can use the "raw request socket" returned by
<code>ngx.req.socket(true)</code> to implement fancy protocols like <a
href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>, or just
emit your own raw HTTP response header or body data. You can refer to
the <a
href="https://github.com/openresty/lua-resty-websocket">lua-resty-websocket
library</a> for a real world example.</p>
<p>This function was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.exec">ngx.exec</h2>
<p><strong>syntax:</strong> <em>ngx.exec(uri, args?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Does an internal redirect to <code>uri</code> with <code>args</code>
and is similar to the <a
href="http://github.com/openresty/echo-nginx-module#echo_exec">echo_exec</a>
directive of the <a
href="http://github.com/openresty/echo-nginx-module">echo-nginx-module</a>.</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exec<span class="op">(</span><span class="st">&#39;/some-location&#39;</span><span class="op">)</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exec<span class="op">(</span><span class="st">&#39;/some-location&#39;</span><span class="op">,</span> <span class="st">&#39;a=3&amp;b=5&amp;c=6&#39;</span><span class="op">)</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exec<span class="op">(</span><span class="st">&#39;/some-location?a=3&amp;b=5&#39;</span><span class="op">,</span> <span class="st">&#39;c=6&#39;</span><span class="op">)</span></span></code></pre></div>
<p>The optional second <code>args</code> can be used to specify extra
URI query arguments, for example:</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exec<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="st">&quot;a=3&amp;b=hello%20world&quot;</span><span class="op">)</span></span></code></pre></div>
<p>Alternatively, a Lua table can be passed for the <code>args</code>
argument for ngx_lua to carry out URI escaping and string
concatenation.</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exec<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="op">{</span> <span class="va">a</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="va">b</span> <span class="op">=</span> <span class="st">&quot;hello world&quot;</span> <span class="op">})</span></span></code></pre></div>
<p>The result is exactly the same as the previous example.</p>
<p>The format for the Lua table passed as the <code>args</code> argument
is identical to the format used in the <a
href="#ngxencode_args">ngx.encode_args</a> method.</p>
<p>Named locations are also supported but the second <code>args</code>
argument will be ignored if present and the querystring for the new
target is inherited from the referring location (if any).</p>
<p><code>GET /foo/file.php?a=hello</code> will return "hello" and not
"goodbye" in the example below</p>
<pre class="nginx"><code>
 location /foo {
     content_by_lua_block {
         ngx.exec(&quot;@bar&quot;, &quot;a=goodbye&quot;)
     }
 }

 location @bar {
     content_by_lua_block {
         local args = ngx.req.get_uri_args()
         for key, val in pairs(args) do
             if key == &quot;a&quot; then
                 ngx.say(val)
             end
         end
     }
 }</code></pre>
<p>Note that the <code>ngx.exec</code> method is different from <a
href="#ngxredirect">ngx.redirect</a> in that it is purely an internal
redirect and that no new external HTTP traffic is involved.</p>
<p>Also note that this method call terminates the processing of the
current request and that it <em>must</em> be called before <a
href="#ngxsend_headers">ngx.send_headers</a> or explicit response body
outputs by either <a href="#ngxprint">ngx.print</a> or <a
href="#ngxsay">ngx.say</a>.</p>
<p>It is recommended that a coding style that combines this method call
with the <code>return</code> statement, i.e.,
<code>return ngx.exec(...)</code> be adopted when this method call is
used in contexts other than <a
href="#header_filter_by_lua">header_filter_by_lua*</a> to reinforce the
fact that the request processing is being terminated.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.redirect">ngx.redirect</h2>
<p><strong>syntax:</strong> <em>ngx.redirect(uri, status?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Issue an <code>HTTP 301</code> or <code>302</code> redirection to
<code>uri</code>.</p>
<p>Note: this function throws a Lua error if the <code>uri</code>
argument contains unsafe characters (control characters).</p>
<p>The optional <code>status</code> parameter specifies the HTTP status
code to be used. The following status codes are supported right now:</p>
<ul>
<li><code>301</code></li>
<li><code>302</code> (default)</li>
<li><code>303</code></li>
<li><code>307</code></li>
<li><code>308</code></li>
</ul>
<p>It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by
default.</p>
<p>Here is an example assuming the current server name is
<code>localhost</code> and that it is listening on port 1984:</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">)</span></span></code></pre></div>
<p>which is equivalent to</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_MOVED_TEMPORARILY</span><span class="op">)</span></span></code></pre></div>
<p>Redirecting arbitrary external URLs is also supported, for
example:</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&quot;http://www.google.com&quot;</span><span class="op">)</span></span></code></pre></div>
<p>We can also use the numerical code directly as the second
<code>status</code> argument:</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="dv">301</span><span class="op">)</span></span></code></pre></div>
<p>This method is similar to the <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite">rewrite</a>
directive with the <code>redirect</code> modifier in the standard <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>,
for example, this <code>nginx.conf</code> snippet</p>
<pre class="nginx"><code>
 rewrite ^ /foo? redirect;  # nginx config</code></pre>
<p>is equivalent to the following Lua code</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&#39;/foo&#39;</span><span class="op">)</span>  <span class="co">-- Lua code</span></span></code></pre></div>
<p>while</p>
<pre class="nginx"><code>
 rewrite ^ /foo? permanent;  # nginx config</code></pre>
<p>is equivalent to</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&#39;/foo&#39;</span><span class="op">,</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_MOVED_PERMANENTLY</span><span class="op">)</span>  <span class="co">-- Lua code</span></span></code></pre></div>
<p>URI arguments can be specified as well, for example:</p>
<div class="sourceCode" id="cb206"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>redirect<span class="op">(</span><span class="st">&#39;/foo?a=3&amp;b=4&#39;</span><span class="op">)</span></span></code></pre></div>
<p>Note that this method call terminates the processing of the current
request and that it <em>must</em> be called before <a
href="#ngxsend_headers">ngx.send_headers</a> or explicit response body
outputs by either <a href="#ngxprint">ngx.print</a> or <a
href="#ngxsay">ngx.say</a>.</p>
<p>It is recommended that a coding style that combines this method call
with the <code>return</code> statement, i.e.,
<code>return ngx.redirect(...)</code> be adopted when this method call
is used in contexts other than <a
href="#header_filter_by_lua">header_filter_by_lua*</a> to reinforce the
fact that the request processing is being terminated.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.send_headers">ngx.send_headers</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.send_headers()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Explicitly send out the response headers.</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on
success, or returns <code>nil</code> and a string describing the error
otherwise.</p>
<p>Note that there is normally no need to manually send out response
headers as ngx_lua will automatically send headers out before content is
output with <a href="#ngxsay">ngx.say</a> or <a
href="#ngxprint">ngx.print</a> or when <a
href="#content_by_lua">content_by_lua*</a> exits normally.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.headers_sent">ngx.headers_sent</h2>
<p><strong>syntax:</strong> <em>value = ngx.headers_sent</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*</em></p>
<p>Returns <code>true</code> if the response headers have been sent (by
ngx_lua), and <code>false</code> otherwise.</p>
<p>This API was first introduced in ngx_lua v0.3.1rc6.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.print">ngx.print</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.print(...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Emits arguments concatenated to the HTTP client (as response body).
If response headers have not been sent, this function will send headers
out first and then output body data.</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on
success, or returns <code>nil</code> and a string describing the error
otherwise.</p>
<p>Lua <code>nil</code> values will output <code>"nil"</code> strings
and Lua boolean values will output <code>"true"</code> and
<code>"false"</code> literal strings respectively.</p>
<p>Nested arrays of strings are permitted and the elements in the arrays
will be sent one by one:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">table</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;hello, &quot;</span><span class="op">,</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span><span class="st">&quot;world: &quot;</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> <span class="st">&quot; or &quot;</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span><span class="st">&quot;: &quot;</span><span class="op">,</span> <span class="kw">nil</span><span class="op">}}</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>print<span class="op">(</span><span class="va">table</span><span class="op">)</span></span></code></pre></div>
<p>will yield the output</p>
<div class="sourceCode" id="cb208"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">hello,</span> world: true or false: nil</span></code></pre></div>
<p>Non-array table arguments will cause a Lua exception to be
thrown.</p>
<p>The <code>ngx.null</code> constant will yield the <code>"null"</code>
string output.</p>
<p>This is an asynchronous call and will return immediately without
waiting for all the data to be written into the system send buffer. To
run in synchronous mode, call <code>ngx.flush(true)</code> after calling
<code>ngx.print</code>. This can be particularly useful for streaming
output. See <a href="#ngxflush">ngx.flush</a> for more details.</p>
<p>Please note that both <code>ngx.print</code> and <a
href="#ngxsay">ngx.say</a> will always invoke the whole Nginx output
body filter chain, which is an expensive operation. So be careful when
calling either of these two in a tight loop; buffer the data yourself in
Lua and save the calls.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.say">ngx.say</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.say(...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Just as <a href="#ngxprint">ngx.print</a> but also emit a trailing
newline.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.log">ngx.log</h2>
<p><strong>syntax:</strong> <em>ngx.log(log_level, ...)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Log arguments concatenated to error.log with the given logging
level.</p>
<p>Lua <code>nil</code> arguments are accepted and result in literal
<code>"nil"</code> string while Lua booleans result in literal
<code>"true"</code> or <code>"false"</code> string outputs. And the
<code>ngx.null</code> constant will yield the <code>"null"</code> string
output.</p>
<p>The <code>log_level</code> argument can take constants like
<code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out <a
href="#nginx-log-level-constants">Nginx log level constants</a> for
details.</p>
<p>There is a hard coded <code>2048</code> byte limitation on error
message lengths in the Nginx core. This limit includes trailing newlines
and leading time stamps. If the message size exceeds this limit, Nginx
will truncate the message text accordingly. This limit can be manually
modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition
in the <code>src/core/ngx_log.h</code> file in the Nginx source
tree.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.flush">ngx.flush</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.flush(wait?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Flushes response output to the client.</p>
<p><code>ngx.flush</code> accepts an optional boolean <code>wait</code>
argument (Default: <code>false</code>) first introduced in the
<code>v0.3.1rc34</code> release. When called with the default argument,
it issues an asynchronous call (Returns immediately without waiting for
output data to be written into the system send buffer). Calling the
function with the <code>wait</code> argument set to <code>true</code>
switches to synchronous mode.</p>
<p>In synchronous mode, the function will not return until all output
data has been written into the system send buffer or until the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout">send_timeout</a>
setting has expired. Note that using the Lua coroutine mechanism means
that this function does not block the Nginx event loop even in the
synchronous mode.</p>
<p>When <code>ngx.flush(true)</code> is called immediately after <a
href="#ngxprint">ngx.print</a> or <a href="#ngxsay">ngx.say</a>, it
causes the latter functions to run in synchronous mode. This can be
particularly useful for streaming output.</p>
<p>Note that <code>ngx.flush</code> is not functional when in the HTTP
1.0 output buffering mode. See <a href="#http-10-support">HTTP 1.0
support</a>.</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on
success, or returns <code>nil</code> and a string describing the error
otherwise.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.exit">ngx.exit</h2>
<p><strong>syntax:</strong> <em>ngx.exit(status)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>When <code>status &gt;= 200</code> (i.e., <code>ngx.HTTP_OK</code>
and above), it will interrupt the execution of the current request and
return status code to Nginx.</p>
<p>When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will
only quit the current phase handler (or the content handler if the <a
href="#content_by_lua">content_by_lua*</a> directive is used) and
continue to run later phases (if any) for the current request.</p>
<p>The <code>status</code> argument can be <code>ngx.OK</code>,
<code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>,
<code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other <a
href="#http-status-constants">HTTP status constants</a>.</p>
<p>To return an error page with custom contents, use code snippets like
this:</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">status</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_GONE</span></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;This is our own content&quot;</span><span class="op">)</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- to cause quit the whole request rather than the current phase handler</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exit<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">HTTP_OK</span><span class="op">)</span></span></code></pre></div>
<p>The effect in action:</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">$</span> curl <span class="at">-i</span> http://localhost/test</span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">HTTP/1.1</span> 410 Gone</span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">Server:</span> nginx/1.0.6</span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">Date:</span> Thu, 15 Sep 2011 00:51:48 GMT</span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">Content-Type:</span> text/plain</span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a> <span class="ex">Transfer-Encoding:</span> chunked</span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a> <span class="ex">Connection:</span> keep-alive</span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a> <span class="ex">This</span> is our own content</span></code></pre></div>
<p>Number literals can be used directly as the argument, for
instance,</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exit<span class="op">(</span><span class="dv">501</span><span class="op">)</span></span></code></pre></div>
<p>Note that while this method accepts all <a
href="#http-status-constants">HTTP status constants</a> as input, it
only accepts <code>ngx.OK</code> and <code>ngx.ERROR</code> of the <a
href="#core-constants">core constants</a>.</p>
<p>Also note that this method call terminates the processing of the
current request and that it is recommended that a coding style that
combines this method call with the <code>return</code> statement, i.e.,
<code>return ngx.exit(...)</code> be used to reinforce the fact that the
request processing is being terminated.</p>
<p>When being used in the contexts of <a
href="#header_filter_by_lua">header_filter_by_lua*</a>, <a
href="#balancer_by_lua_block">balancer_by_lua*</a>, and <a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua*</a>,
<code>ngx.exit()</code> is an asynchronous operation and will return
immediately. This behavior may change in future and it is recommended
that users always use <code>return</code> in combination as suggested
above.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.eof">ngx.eof</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.eof()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Explicitly specify the end of the response output stream. In the case
of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core
to send out the "last chunk".</p>
<p>When you disable the HTTP 1.1 keep-alive feature for your downstream
connections, you can rely on well written HTTP clients to close the
connection actively for you when you call this method. This trick can be
used do back-ground jobs without letting the HTTP clients to wait on the
connection, as in the following example:</p>
<pre class="nginx"><code>
 location = /async {
     keepalive_timeout 0;
     content_by_lua_block {
         ngx.say(&quot;got the task!&quot;)
         ngx.eof()  -- well written HTTP clients will close the connection at this point
         -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...
     }
 }</code></pre>
<p>But if you create subrequests to access other locations configured by
Nginx upstream modules, then you should configure those upstream modules
to ignore client connection abortions if they are not by default. For
example, by default the standard <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>
will terminate both the subrequest and the main request as soon as the
client closes the connection, so it is important to turn on the <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort">proxy_ignore_client_abort</a>
directive in your location block configured by <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>:</p>
<pre class="nginx"><code>
 proxy_ignore_client_abort on;</code></pre>
<p>A better way to do background jobs is to use the <a
href="#ngxtimerat">ngx.timer.at</a> API.</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on
success, or returns <code>nil</code> and a string describing the error
otherwise.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.sleep">ngx.sleep</h2>
<p><strong>syntax:</strong> <em>ngx.sleep(seconds)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Sleeps for the specified seconds without blocking. One can specify
time resolution up to 0.001 seconds (i.e., one millisecond).</p>
<p>Behind the scene, this method makes use of the Nginx timers.</p>
<p>Since the <code>0.7.20</code> release, The <code>0</code> time
argument can also be specified.</p>
<p>This method was introduced in the <code>0.5.0rc30</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.escape_uri">ngx.escape_uri</h2>
<p><strong>syntax:</strong> <em>newstr = ngx.escape_uri(str,
type?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Since <code>v0.10.16</code>, this function accepts an optional
<code>type</code> argument. It accepts the following values (defaults to
<code>2</code>):</p>
<ul>
<li><code>0</code>: escapes <code>str</code> as a full URI. And the
characters <code></code> (space), <code>#</code>, <code>%</code>,
<code>?</code>, 0x00 ~ 0x1F, 0x7F ~ 0xFF will be escaped.</li>
<li><code>2</code>: escape <code>str</code> as a URI component. All
characters except alphabetic characters, digits, <code>-</code>,
<code>.</code>, <code>_</code>, <code>~</code> will be encoded as
<code>%XX</code>.</li>
</ul>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.unescape_uri">ngx.unescape_uri</h2>
<p><strong>syntax:</strong> <em>newstr = ngx.unescape_uri(str)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Unescape <code>str</code> as an escaped URI component.</p>
<p>For example,</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">ngx</span><span class="op">.</span>unescape_uri<span class="op">(</span><span class="st">&quot;b%20r56+7&quot;</span><span class="op">))</span></span></code></pre></div>
<p>gives the output</p>
<pre><code>b r56 7</code></pre>
<p>Invalid escaping sequences are handled in a conventional way:
<code>%</code>s are left unchanged. Also, characters that should not
appear in escaped string are simply left unchanged.</p>
<p>For example,</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">ngx</span><span class="op">.</span>unescape_uri<span class="op">(</span><span class="st">&quot;try %search%%20%again%&quot;</span><span class="op">))</span></span></code></pre></div>
<p>gives the output</p>
<pre><code>try %search% %again%</code></pre>
<p>(Note that <code>%20</code> following <code>%</code> got unescaped,
even it can be considered a part of invalid sequence.)</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.encode_args">ngx.encode_args</h2>
<p><strong>syntax:</strong> <em>str = ngx.encode_args(table)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Encode the Lua table to a query args string according to the URI
encoded rules.</p>
<p>For example,</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>encode_args<span class="op">({</span><span class="va">foo</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="op">[</span><span class="st">&quot;b r&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;hello world&quot;</span><span class="op">})</span></span></code></pre></div>
<p>yields</p>
<pre><code>foo=3&amp;b%20r=hello%20world</code></pre>
<p>The table keys must be Lua strings.</p>
<p>Multi-value query args are also supported. Just use a Lua table for
the argument's value, for example:</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>encode_args<span class="op">({</span><span class="va">baz</span> <span class="op">=</span> <span class="op">{</span><span class="dv">32</span><span class="op">,</span> <span class="st">&quot;hello&quot;</span><span class="op">}})</span></span></code></pre></div>
<p>gives</p>
<pre><code>baz=32&amp;baz=hello</code></pre>
<p>If the value table is empty and the effect is equivalent to the
<code>nil</code> value.</p>
<p>Boolean argument values are also supported, for instance,</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>encode_args<span class="op">({</span><span class="va">a</span> <span class="op">=</span> <span class="kw">true</span><span class="op">,</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">1</span><span class="op">})</span></span></code></pre></div>
<p>yields</p>
<pre><code>a&amp;b=1</code></pre>
<p>If the argument value is <code>false</code>, then the effect is
equivalent to the <code>nil</code> value.</p>
<p>This method was first introduced in the <code>v0.3.1rc27</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.decode_args">ngx.decode_args</h2>
<p><strong>syntax:</strong> <em>table, err = ngx.decode_args(str,
max_args?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Decodes a URI encoded query-string into a Lua table. This is the
inverse function of <a href="#ngxencode_args">ngx.encode_args</a>.</p>
<p>The optional <code>max_args</code> argument can be used to specify
the maximum number of arguments parsed from the <code>str</code>
argument. By default, a maximum of 100 request arguments are parsed
(including those with the same name) and that additional URI arguments
are silently discarded to guard against potential denial of service
attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it
will return a second value which is the string
<code>"truncated"</code>.</p>
<p>This argument can be set to zero to remove the limit and to process
all request arguments received:</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">args</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span>decode_args<span class="op">(</span><span class="va">str</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>Removing the <code>max_args</code> cap is strongly discouraged.</p>
<p>This method was introduced in the <code>v0.5.0rc29</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.encode_base64">ngx.encode_base64</h2>
<p><strong>syntax:</strong> <em>newstr = ngx.encode_base64(str,
no_padding?)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Encodes <code>str</code> to a base64 digest. For base64url encoding
use <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/base64.md#encode_base64url"><code>base64.encode_base64url</code></a>.</p>
<p>Since the <code>0.9.16</code> release, an optional boolean-typed
<code>no_padding</code> argument can be specified to control whether the
base64 padding should be appended to the resulting digest (default to
<code>false</code>, i.e., with padding enabled).</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.decode_base64">ngx.decode_base64</h2>
<p><strong>syntax:</strong> <em>newstr = ngx.decode_base64(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Decodes the <code>str</code> argument as a base64 digest to the raw
form. For base64url decoding use <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/base64.md#decode_base64url"><code>base64.decode_base64url</code></a>.</p>
<p>The <code>str</code> should be standard ‘base64' encoding for RFC
3548 or RFC 4648, and will returns <code>nil</code> if is not well
formed or any characters not in the base encoding alphabet. Padding may
be omitted from the input.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.decode_base64mime">ngx.decode_base64mime</h2>
<p><strong>syntax:</strong> <em>newstr =
ngx.decode_base64mime(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*</em></p>
<p><strong>requires:</strong> <code>resty.core.base64</code> or
<code>resty.core</code></p>
<p>Decodes the <code>str</code> argument as a base64 digest to the raw
form. The <code>str</code> follows base64 transfer encoding for MIME
(RFC 2045), and will discard characters outside the base encoding
alphabet. Returns <code>nil</code> if <code>str</code> is not well
formed.</p>
<p>'‘'Note:''' This method requires the <code>resty.core.base64</code>
or <code>resty.core</code> modules from the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.crc32_short">ngx.crc32_short</h2>
<p><strong>syntax:</strong> <em>intval = ngx.crc32_short(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the
<code>str</code> argument.</p>
<p>This method performs better on relatively short <code>str</code>
inputs (i.e., less than 30 ~ 60 bytes), as compared to <a
href="#ngxcrc32_long">ngx.crc32_long</a>. The result is exactly the same
as <a href="#ngxcrc32_long">ngx.crc32_long</a>.</p>
<p>Behind the scene, it is just a thin wrapper around the
<code>ngx_crc32_short</code> function defined in the Nginx core.</p>
<p>This API was first introduced in the <code>v0.3.1rc8</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.crc32_long">ngx.crc32_long</h2>
<p><strong>syntax:</strong> <em>intval = ngx.crc32_long(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the
<code>str</code> argument.</p>
<p>This method performs better on relatively long <code>str</code>
inputs (i.e., longer than 30 ~ 60 bytes), as compared to <a
href="#ngxcrc32_short">ngx.crc32_short</a>. The result is exactly the
same as <a href="#ngxcrc32_short">ngx.crc32_short</a>.</p>
<p>Behind the scene, it is just a thin wrapper around the
<code>ngx_crc32_long</code> function defined in the Nginx core.</p>
<p>This API was first introduced in the <code>v0.3.1rc8</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.hmac_sha1">ngx.hmac_sha1</h2>
<p><strong>syntax:</strong> <em>digest = ngx.hmac_sha1(secret_key,
str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Computes the <a
href="https://en.wikipedia.org/wiki/HMAC">HMAC-SHA1</a> digest of the
argument <code>str</code> and turns the result using the secret key
<code>&lt;secret_key&gt;</code>.</p>
<p>The raw binary form of the <code>HMAC-SHA1</code> digest will be
generated, use <a href="#ngxencode_base64">ngx.encode_base64</a>, for
example, to encode the result to a textual representation if
desired.</p>
<p>For example,</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;thisisverysecretstuff&quot;</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">src</span> <span class="op">=</span> <span class="st">&quot;some string we want to sign&quot;</span></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">digest</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span>hmac_sha1<span class="op">(</span><span class="va">key</span><span class="op">,</span> <span class="va">src</span><span class="op">)</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">ngx</span><span class="op">.</span>encode_base64<span class="op">(</span><span class="va">digest</span><span class="op">))</span></span></code></pre></div>
<p>yields the output</p>
<pre><code>R/pvxzHC4NLtj7S+kXFg/NePTmk=</code></pre>
<p>This API requires the OpenSSL library enabled in the Nginx build
(usually by passing the <code>--with-http_ssl_module</code> option to
the <code>./configure</code> script).</p>
<p>This function was first introduced in the <code>v0.3.1rc29</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.md5">ngx.md5</h2>
<p><strong>syntax:</strong> <em>digest = ngx.md5(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Returns the hexadecimal representation of the MD5 digest of the
<code>str</code> argument.</p>
<p>For example,</p>
<pre class="nginx"><code>
 location = /md5 {
     content_by_lua_block {
         ngx.say(ngx.md5(&quot;hello&quot;))
     }
 }</code></pre>
<p>yields the output</p>
<pre><code>5d41402abc4b2a76b9719d911017c592</code></pre>
<p>See <a href="#ngxmd5_bin">ngx.md5_bin</a> if the raw binary MD5
digest is required.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.md5_bin">ngx.md5_bin</h2>
<p><strong>syntax:</strong> <em>digest = ngx.md5_bin(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Returns the binary form of the MD5 digest of the <code>str</code>
argument.</p>
<p>See <a href="#ngxmd5">ngx.md5</a> if the hexadecimal form of the MD5
digest is required.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.sha1_bin">ngx.sha1_bin</h2>
<p><strong>syntax:</strong> <em>digest = ngx.sha1_bin(str)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Returns the binary form of the SHA-1 digest of the <code>str</code>
argument.</p>
<p>This function requires SHA-1 support in the Nginx build. (This
usually just means OpenSSL should be installed while building
Nginx).</p>
<p>This function was first introduced in the <code>v0.5.0rc6</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.quote_sql_str">ngx.quote_sql_str</h2>
<p><strong>syntax:</strong> <em>quoted_value =
ngx.quote_sql_str(raw_value)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Returns a quoted SQL string literal according to the MySQL quoting
rules.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.today">ngx.today</h2>
<p><strong>syntax:</strong> <em>str = ngx.today()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns current date (in the format <code>yyyy-mm-dd</code>) from the
Nginx cached time (no syscall involved unlike Lua's date library).</p>
<p>This is the local time.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.time">ngx.time</h2>
<p><strong>syntax:</strong> <em>secs = ngx.time()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns the elapsed seconds from the epoch for the current time stamp
from the Nginx cached time (no syscall involved unlike Lua's date
library).</p>
<p>Updates of the Nginx time cache can be forced by calling <a
href="#ngxupdate_time">ngx.update_time</a> first.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.now">ngx.now</h2>
<p><strong>syntax:</strong> <em>secs = ngx.now()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns a floating-point number for the elapsed time in seconds
(including milliseconds as the decimal part) from the epoch for the
current time stamp from the Nginx cached time (no syscall involved
unlike Lua's date library).</p>
<p>You can forcibly update the Nginx time cache by calling <a
href="#ngxupdate_time">ngx.update_time</a> first.</p>
<p>This API was first introduced in <code>v0.3.1rc32</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.update_time">ngx.update_time</h2>
<p><strong>syntax:</strong> <em>ngx.update_time()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Forcibly updates the Nginx current time cache. This call involves a
syscall and thus has some overhead, so do not abuse it.</p>
<p>This API was first introduced in <code>v0.3.1rc32</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.localtime">ngx.localtime</h2>
<p><strong>syntax:</strong> <em>str = ngx.localtime()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns the current time stamp (in the format
<code>yyyy-mm-dd hh:mm:ss</code>) of the Nginx cached time (no syscall
involved unlike Lua's <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-os.date">os.date</a>
function).</p>
<p>This is the local time.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.utctime">ngx.utctime</h2>
<p><strong>syntax:</strong> <em>str = ngx.utctime()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns the current time stamp (in the format
<code>yyyy-mm-dd hh:mm:ss</code>) of the Nginx cached time (no syscall
involved unlike Lua's <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-os.date">os.date</a>
function).</p>
<p>This is the UTC time.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.cookie_time">ngx.cookie_time</h2>
<p><strong>syntax:</strong> <em>str = ngx.cookie_time(sec)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns a formatted string can be used as the cookie expiration time.
The parameter <code>sec</code> is the time stamp in seconds (like those
returned from <a href="#ngxtime">ngx.time</a>).</p>
<pre class="nginx"><code>
 ngx.say(ngx.cookie_time(1290079655))
     -- yields &quot;Thu, 18-Nov-10 11:27:35 GMT&quot;</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.http_time">ngx.http_time</h2>
<p><strong>syntax:</strong> <em>str = ngx.http_time(sec)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns a formated string can be used as the http header time (for
example, being used in <code>Last-Modified</code> header). The parameter
<code>sec</code> is the time stamp in seconds (like those returned from
<a href="#ngxtime">ngx.time</a>).</p>
<pre class="nginx"><code>
 ngx.say(ngx.http_time(1290079655))
     -- yields &quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.parse_http_time">ngx.parse_http_time</h2>
<p><strong>syntax:</strong> <em>sec = ngx.parse_http_time(str)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Parse the http time string (as returned by <a
href="#ngxhttp_time">ngx.http_time</a>) into seconds. Returns the
seconds or <code>nil</code> if the input string is in bad forms.</p>
<pre class="nginx"><code>
 local time = ngx.parse_http_time(&quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;)
 if time == nil then
     ...
 end</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.is_subrequest">ngx.is_subrequest</h2>
<p><strong>syntax:</strong> <em>value = ngx.is_subrequest</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*</em></p>
<p>Returns <code>true</code> if the current request is an Nginx
subrequest, or <code>false</code> otherwise.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.re.match">ngx.re.match</h2>
<p><strong>syntax:</strong> <em>captures, err = ngx.re.match(subject,
regex, options?, ctx?, res_table?)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Matches the <code>subject</code> string using the Perl compatible
regular expression <code>regex</code> with the optional
<code>options</code>.</p>
<p>Only the first occurrence of the match is returned, or
<code>nil</code> if no match is found. In case of errors, like seeing a
bad regular expression or exceeding the PCRE stack limit,
<code>nil</code> and a string describing the error will be returned.</p>
<p>When a match is found, a Lua table <code>captures</code> is returned,
where <code>captures[0]</code> holds the whole substring being matched,
and <code>captures[1]</code> holds the first parenthesized sub-pattern's
capturing, <code>captures[2]</code> the second, and so on.</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>match<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;[0-9]+&quot;</span><span class="op">)</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">m</span> <span class="cf">then</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- m[0] == &quot;1234&quot;</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">else</span></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>         <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span></span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;match not found&quot;</span><span class="op">)</span></span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<div class="sourceCode" id="cb233"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>match<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;([0-9])[0-9]+&quot;</span><span class="op">)</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[0] == &quot;1234&quot;</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[1] == &quot;1&quot;</span></span></code></pre></div>
<p>Named captures are also supported since the <code>v0.7.14</code>
release and are returned in the same Lua table as key-value pairs as the
numbered captures.</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>match<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;([0-9])(?&lt;remaining&gt;[0-9]+)&quot;</span><span class="op">)</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[0] == &quot;1234&quot;</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[1] == &quot;1&quot;</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[2] == &quot;234&quot;</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[&quot;remaining&quot;] == &quot;234&quot;</span></span></code></pre></div>
<p>Unmatched subpatterns will have <code>false</code> values in their
<code>captures</code> table fields.</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>match<span class="op">(</span><span class="st">&quot;hello, world&quot;</span><span class="op">,</span> <span class="st">&quot;(world)|(hello)|(?&lt;named&gt;howdy)&quot;</span><span class="op">)</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[0] == &quot;hello&quot;</span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[1] == false</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[2] == &quot;hello&quot;</span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[3] == false</span></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a> <span class="co">-- m[&quot;named&quot;] == false</span></span></code></pre></div>
<p>Specify <code>options</code> to control how the match operation will
be performed. The following option characters are supported:</p>
<pre><code>a             anchored mode (only match from the beginning)

d             enable the DFA mode (or the longest token match semantics).
              this requires PCRE 6.0+ or else a Lua exception will be thrown.
              first introduced in ngx_lua v0.3.1rc30.

D             enable duplicate named pattern support. This allows named
              subpattern names to be repeated, returning the captures in
              an array-like Lua table. for example,
                local m = ngx.re.match(&quot;hello, world&quot;,
                                       &quot;(?&lt;named&gt;\w+), (?&lt;named&gt;\w+)&quot;,
                                       &quot;D&quot;)
                -- m[&quot;named&quot;] == {&quot;hello&quot;, &quot;world&quot;}
              this option was first introduced in the v0.7.14 release.
              this option requires at least PCRE 8.12.

i             case insensitive mode (similar to Perl&#39;s /i modifier)

j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
              must be built with the --enable-jit option. for optimum performance,
              this option should always be used together with the &#39;o&#39; option.
              first introduced in ngx_lua v0.3.1rc30.

J             enable the PCRE Javascript compatible mode. this option was
              first introduced in the v0.7.14 release. this option requires
              at least PCRE 8.12.

m             multi-line mode (similar to Perl&#39;s /m modifier)

o             compile-once mode (similar to Perl&#39;s /o modifier),
              to enable the worker-process-level compiled-regex cache

s             single-line mode (similar to Perl&#39;s /s modifier)

u             UTF-8 mode. this requires PCRE to be built with
              the --enable-utf8 option or else a Lua exception will be thrown.

U             similar to &quot;u&quot; but disables PCRE&#39;s UTF-8 validity check on
              the subject string. first introduced in ngx_lua v0.8.1.

x             extended mode (similar to Perl&#39;s /x modifier)</code></pre>
<p>These options can be combined:</p>
<pre class="nginx"><code>
 local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;HEL LO&quot;, &quot;ix&quot;)
 -- m[0] == &quot;hello&quot;</code></pre>
<pre class="nginx"><code>
 local m, err = ngx.re.match(&quot;hello, 美好生活&quot;, &quot;HELLO, (.{2})&quot;, &quot;iu&quot;)
 -- m[0] == &quot;hello, 美好&quot;
 -- m[1] == &quot;美好&quot;</code></pre>
<p>The <code>o</code> option is useful for performance tuning, because
the regex pattern in question will only be compiled once, cached in the
worker-process level, and shared among all requests in the current Nginx
worker process. The upper limit of the regex cache can be tuned via the
<a href="#lua_regex_cache_max_entries">lua_regex_cache_max_entries</a>
directive.</p>
<p>The optional fourth argument, <code>ctx</code>, can be a Lua table
holding an optional <code>pos</code> field. When the <code>pos</code>
field in the <code>ctx</code> table argument is specified,
<code>ngx.re.match</code> will start matching from that offset (starting
from 1). Regardless of the presence of the <code>pos</code> field in the
<code>ctx</code> table, <code>ngx.re.match</code> will always set this
<code>pos</code> field to the position <em>after</em> the substring
matched by the whole pattern in case of a successful match. When match
fails, the <code>ctx</code> table will be left intact.</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ctx</span> <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>match<span class="op">(</span><span class="st">&quot;1234, hello&quot;</span><span class="op">,</span> <span class="st">&quot;[0-9]+&quot;</span><span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">,</span> <span class="va">ctx</span><span class="op">)</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- m[0] = &quot;1234&quot;</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- ctx.pos == 5</span></span></code></pre></div>
<div class="sourceCode" id="cb240"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ctx</span> <span class="op">=</span> <span class="op">{</span> <span class="va">pos</span> <span class="op">=</span> <span class="dv">2</span> <span class="op">}</span></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>match<span class="op">(</span><span class="st">&quot;1234, hello&quot;</span><span class="op">,</span> <span class="st">&quot;[0-9]+&quot;</span><span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">,</span> <span class="va">ctx</span><span class="op">)</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- m[0] = &quot;234&quot;</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- ctx.pos == 5</span></span></code></pre></div>
<p>The <code>ctx</code> table argument combined with the <code>a</code>
regex modifier can be used to construct a lexer atop
<code>ngx.re.match</code>.</p>
<p>Note that, the <code>options</code> argument is not optional when the
<code>ctx</code> argument is specified and that the empty Lua string
(<code>""</code>) must be used as placeholder for <code>options</code>
if no meaningful regex options are required.</p>
<p>This method requires the PCRE library enabled in Nginx (<a
href="#special-escaping-sequences">Known Issue With Special Escaping
Sequences</a>).</p>
<p>To confirm that PCRE JIT is enabled, activate the Nginx debug log by
adding the <code>--with-debug</code> option to Nginx or OpenResty's
<code>./configure</code> script. Then, enable the "debug" error log
level in <code>error_log</code> directive. The following message will be
generated if PCRE JIT is enabled:</p>
<pre><code>pcre JIT compiling result: 1</code></pre>
<p>Starting from the <code>0.9.4</code> release, this function also
accepts a 5th argument, <code>res_table</code>, for letting the caller
supply the Lua table used to hold all the capturing results. Starting
from <code>0.9.6</code>, it is the caller's responsibility to ensure
this table is empty. This is very useful for recycling Lua tables and
saving GC and table allocation overhead.</p>
<p>This feature was introduced in the <code>v0.2.1rc11</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.re.find">ngx.re.find</h2>
<p><strong>syntax:</strong> <em>from, to, err = ngx.re.find(subject,
regex, options?, ctx?, nth?)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Similar to <a href="#ngxrematch">ngx.re.match</a> but only returns
the beginning index (<code>from</code>) and end index (<code>to</code>)
of the matched substring. The returned indexes are 1-based and can be
fed directly into the <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-string.sub">string.sub</a>
API function to obtain the matched substring.</p>
<p>In case of errors (like bad regexes or any PCRE runtime errors), this
API function returns two <code>nil</code> values followed by a string
describing the error.</p>
<p>If no match is found, this function just returns a <code>nil</code>
value.</p>
<p>Below is an example:</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">s</span> <span class="op">=</span> <span class="st">&quot;hello, 1234&quot;</span></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">from</span><span class="op">,</span> <span class="va">to</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>find<span class="op">(</span><span class="va">s</span><span class="op">,</span> <span class="st">&quot;([0-9]+)&quot;</span><span class="op">,</span> <span class="st">&quot;jo&quot;</span><span class="op">)</span></span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">from</span> <span class="cf">then</span></span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;from: &quot;</span><span class="op">,</span> <span class="va">from</span><span class="op">)</span></span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;to: &quot;</span><span class="op">,</span> <span class="va">to</span><span class="op">)</span></span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;matched: &quot;</span><span class="op">,</span> <span class="fu">string.sub</span><span class="op">(</span><span class="va">s</span><span class="op">,</span> <span class="va">from</span><span class="op">,</span> <span class="va">to</span><span class="op">))</span></span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">else</span></span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true" tabindex="-1"></a>         <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span></span>
<span id="cb242-12"><a href="#cb242-12" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb242-13"><a href="#cb242-13" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;not matched!&quot;</span><span class="op">)</span></span>
<span id="cb242-14"><a href="#cb242-14" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This example produces the output</p>
<pre><code>from: 8
to: 11
matched: 1234</code></pre>
<p>Because this API function does not create new Lua strings nor new Lua
tables, it is much faster than <a href="#ngxrematch">ngx.re.match</a>.
It should be used wherever possible.</p>
<p>Since the <code>0.9.3</code> release, an optional 5th argument,
<code>nth</code>, is supported to specify which (submatch) capture's
indexes to return. When <code>nth</code> is 0 (which is the default),
the indexes for the whole matched substring is returned; when
<code>nth</code> is 1, then the 1st submatch capture's indexes are
returned; when <code>nth</code> is 2, then the 2nd submatch capture is
returned, and so on. When the specified submatch does not have a match,
then two <code>nil</code> values will be returned. Below is an example
for this:</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">str</span> <span class="op">=</span> <span class="st">&quot;hello, 1234&quot;</span></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">from</span><span class="op">,</span> <span class="va">to</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>find<span class="op">(</span><span class="va">str</span><span class="op">,</span> <span class="st">&quot;([0-9])([0-9]+)&quot;</span><span class="op">,</span> <span class="st">&quot;jo&quot;</span><span class="op">,</span> <span class="kw">nil</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">from</span> <span class="cf">then</span></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;matched 2nd submatch: &quot;</span><span class="op">,</span> <span class="fu">string.sub</span><span class="op">(</span><span class="va">str</span><span class="op">,</span> <span class="va">from</span><span class="op">,</span> <span class="va">to</span><span class="op">))</span>  <span class="co">-- yields &quot;234&quot;</span></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>This API function was first introduced in the <code>v0.9.2</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.re.gmatch">ngx.re.gmatch</h2>
<p><strong>syntax:</strong> <em>iterator, err = ngx.re.gmatch(subject,
regex, options?)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Similar to <a href="#ngxrematch">ngx.re.match</a>, but returns a Lua
iterator instead, so as to let the user programmer iterate all the
matches over the <code>&lt;subject&gt;</code> string argument with the
PCRE <code>regex</code>.</p>
<p>In case of errors, like seeing an ill-formed regular expression,
<code>nil</code> and a string describing the error will be returned.</p>
<p>Here is a small example to demonstrate its basic usage:</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">iterator</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>gmatch<span class="op">(</span><span class="st">&quot;hello, world!&quot;</span><span class="op">,</span> <span class="st">&quot;([a-z]+)&quot;</span><span class="op">,</span> <span class="st">&quot;i&quot;</span><span class="op">)</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">iterator</span> <span class="cf">then</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">m</span></span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> iterator<span class="op">()</span>    <span class="co">-- m[0] == m[1] == &quot;hello&quot;</span></span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb245-13"><a href="#cb245-13" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb245-14"><a href="#cb245-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-15"><a href="#cb245-15" aria-hidden="true" tabindex="-1"></a> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> iterator<span class="op">()</span>    <span class="co">-- m[0] == m[1] == &quot;world&quot;</span></span>
<span id="cb245-16"><a href="#cb245-16" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb245-17"><a href="#cb245-17" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb245-18"><a href="#cb245-18" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb245-19"><a href="#cb245-19" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb245-20"><a href="#cb245-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-21"><a href="#cb245-21" aria-hidden="true" tabindex="-1"></a> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> iterator<span class="op">()</span>    <span class="co">-- m == nil</span></span>
<span id="cb245-22"><a href="#cb245-22" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb245-23"><a href="#cb245-23" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb245-24"><a href="#cb245-24" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb245-25"><a href="#cb245-25" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>More often we just put it into a Lua loop:</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">it</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>gmatch<span class="op">(</span><span class="st">&quot;hello, world!&quot;</span><span class="op">,</span> <span class="st">&quot;([a-z]+)&quot;</span><span class="op">,</span> <span class="st">&quot;i&quot;</span><span class="op">)</span></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">it</span> <span class="cf">then</span></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">while</span> <span class="kw">true</span> <span class="cf">do</span></span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">m</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> it<span class="op">()</span></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>         <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span></span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="kw">not</span> <span class="va">m</span> <span class="cf">then</span></span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- no match found (any more)</span></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>         <span class="cf">break</span></span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-20"><a href="#cb246-20" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- found a match</span></span>
<span id="cb246-21"><a href="#cb246-21" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">m</span><span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb246-22"><a href="#cb246-22" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">m</span><span class="op">[</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb246-23"><a href="#cb246-23" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>The optional <code>options</code> argument takes exactly the same
semantics as the <a href="#ngxrematch">ngx.re.match</a> method.</p>
<p>The current implementation requires that the iterator returned should
only be used in a single request. That is, one should <em>not</em>
assign it to a variable belonging to persistent namespace like a Lua
package.</p>
<p>This method requires the PCRE library enabled in Nginx (<a
href="#special-escaping-sequences">Known Issue With Special Escaping
Sequences</a>).</p>
<p>This feature was first introduced in the <code>v0.2.1rc12</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.re.sub">ngx.re.sub</h2>
<p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.sub(subject,
regex, replace, options?)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Substitutes the first match of the Perl compatible regular expression
<code>regex</code> on the <code>subject</code> argument string with the
string or function argument <code>replace</code>. The optional
<code>options</code> argument has exactly the same meaning as in <a
href="#ngxrematch">ngx.re.match</a>.</p>
<p>This method returns the resulting new string as well as the number of
successful substitutions. In case of failures, like syntax errors in the
regular expressions or the <code>&lt;replace&gt;</code> string argument,
it will return <code>nil</code> and a string describing the error.</p>
<p>When the <code>replace</code> is a string, then it is treated as a
special template for string replacement. For example,</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newstr</span><span class="op">,</span> <span class="va">n</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>sub<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;([0-9])[0-9]&quot;</span><span class="op">,</span> <span class="st">&quot;[$0][$1]&quot;</span><span class="op">)</span></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">newstr</span> <span class="cf">then</span></span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb247-6"><a href="#cb247-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb247-7"><a href="#cb247-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-8"><a href="#cb247-8" aria-hidden="true" tabindex="-1"></a> <span class="co">-- newstr == &quot;hello, [12][1]34&quot;</span></span>
<span id="cb247-9"><a href="#cb247-9" aria-hidden="true" tabindex="-1"></a> <span class="co">-- n == 1</span></span></code></pre></div>
<p>where <code>$0</code> referring to the whole substring matched by the
pattern and <code>$1</code> referring to the first parenthesized
capturing substring.</p>
<p>Curly braces can also be used to disambiguate variable names from the
background string literals:</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newstr</span><span class="op">,</span> <span class="va">n</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>sub<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;[0-9]&quot;</span><span class="op">,</span> <span class="st">&quot;${0}00&quot;</span><span class="op">)</span></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- newstr == &quot;hello, 100234&quot;</span></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- n == 1</span></span></code></pre></div>
<p>Literal dollar sign characters (<code>$</code>) in the
<code>replace</code> string argument can be escaped by another dollar
sign, for instance,</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newstr</span><span class="op">,</span> <span class="va">n</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>sub<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;[0-9]&quot;</span><span class="op">,</span> <span class="st">&quot;$$&quot;</span><span class="op">)</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- newstr == &quot;hello, $234&quot;</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- n == 1</span></span></code></pre></div>
<p>Do not use backlashes to escape dollar signs; it will not work as
expected.</p>
<p>When the <code>replace</code> argument is of type "function", then it
will be invoked with the "match table" as the argument to generate the
replace string literal for substitution. The "match table" fed into the
<code>replace</code> function is exactly the same as the return value of
<a href="#ngxrematch">ngx.re.match</a>. Here is an example:</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">func</span> <span class="op">=</span> <span class="kw">function</span> <span class="op">(</span><span class="va">m</span><span class="op">)</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="st">&quot;[&quot;</span> <span class="op">..</span> <span class="va">m</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">..</span> <span class="st">&quot;][&quot;</span> <span class="op">..</span> <span class="va">m</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">..</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newstr</span><span class="op">,</span> <span class="va">n</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>sub<span class="op">(</span><span class="st">&quot;hello, 1234&quot;</span><span class="op">,</span> <span class="st">&quot;( [0-9] ) [0-9]&quot;</span><span class="op">,</span> <span class="va">func</span><span class="op">,</span> <span class="st">&quot;x&quot;</span><span class="op">)</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a> <span class="co">-- newstr == &quot;hello, [12][1]34&quot;</span></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a> <span class="co">-- n == 1</span></span></code></pre></div>
<p>The dollar sign characters in the return value of the
<code>replace</code> function argument are not special at all.</p>
<p>This method requires the PCRE library enabled in Nginx (<a
href="#special-escaping-sequences">Known Issue With Special Escaping
Sequences</a>).</p>
<p>This feature was first introduced in the <code>v0.2.1rc13</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.re.gsub">ngx.re.gsub</h2>
<p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.gsub(subject,
regex, replace, options?)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Just like <a href="#ngxresub">ngx.re.sub</a>, but does global
substitution.</p>
<p>Here is some examples:</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newstr</span><span class="op">,</span> <span class="va">n</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>gsub<span class="op">(</span><span class="st">&quot;hello, world&quot;</span><span class="op">,</span> <span class="st">&quot;([a-z])[a-z]+&quot;</span><span class="op">,</span> <span class="st">&quot;[$0,$1]&quot;</span><span class="op">,</span> <span class="st">&quot;i&quot;</span><span class="op">)</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">newstr</span> <span class="cf">then</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;error: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a> <span class="co">-- newstr == &quot;[hello,h], [world,w]&quot;</span></span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a> <span class="co">-- n == 2</span></span></code></pre></div>
<div class="sourceCode" id="cb252"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">func</span> <span class="op">=</span> <span class="kw">function</span> <span class="op">(</span><span class="va">m</span><span class="op">)</span></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="st">&quot;[&quot;</span> <span class="op">..</span> <span class="va">m</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">..</span> <span class="st">&quot;,&quot;</span> <span class="op">..</span> <span class="va">m</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">..</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newstr</span><span class="op">,</span> <span class="va">n</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">re</span><span class="op">.</span>gsub<span class="op">(</span><span class="st">&quot;hello, world&quot;</span><span class="op">,</span> <span class="st">&quot;([a-z])[a-z]+&quot;</span><span class="op">,</span> <span class="va">func</span><span class="op">,</span> <span class="st">&quot;i&quot;</span><span class="op">)</span></span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a> <span class="co">-- newstr == &quot;[hello,h], [world,w]&quot;</span></span>
<span id="cb252-7"><a href="#cb252-7" aria-hidden="true" tabindex="-1"></a> <span class="co">-- n == 2</span></span></code></pre></div>
<p>This method requires the PCRE library enabled in Nginx (<a
href="#special-escaping-sequences">Known Issue With Special Escaping
Sequences</a>).</p>
<p>This feature was first introduced in the <code>v0.2.1rc15</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict">ngx.shared.DICT</h2>
<p><strong>syntax:</strong> <em>dict = ngx.shared.DICT</em></p>
<p><strong>syntax:</strong> <em>dict = ngx.shared[name_var]</em></p>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Fetching the shm-based Lua dictionary object for the shared memory
zone named <code>DICT</code> defined by the <a
href="#lua_shared_dict">lua_shared_dict</a> directive.</p>
<p>Shared memory zones are always shared by all the Nginx worker
processes in the current Nginx server instance.</p>
<p>The resulting object <code>dict</code> has the following methods:</p>
<ul>
<li><a href="#ngxshareddictget">get</a></li>
<li><a href="#ngxshareddictget_stale">get_stale</a></li>
<li><a href="#ngxshareddictset">set</a></li>
<li><a href="#ngxshareddictsafe_set">safe_set</a></li>
<li><a href="#ngxshareddictadd">add</a></li>
<li><a href="#ngxshareddictsafe_add">safe_add</a></li>
<li><a href="#ngxshareddictreplace">replace</a></li>
<li><a href="#ngxshareddictdelete">delete</a></li>
<li><a href="#ngxshareddictincr">incr</a></li>
<li><a href="#ngxshareddictlpush">lpush</a></li>
<li><a href="#ngxshareddictrpush">rpush</a></li>
<li><a href="#ngxshareddictlpop">lpop</a></li>
<li><a href="#ngxshareddictrpop">rpop</a></li>
<li><a href="#ngxshareddictllen">llen</a></li>
<li><a href="#ngxshareddictttl">ttl</a></li>
<li><a href="#ngxshareddictexpire">expire</a></li>
<li><a href="#ngxshareddictflush_all">flush_all</a></li>
<li><a href="#ngxshareddictflush_expired">flush_expired</a></li>
<li><a href="#ngxshareddictget_keys">get_keys</a></li>
<li><a href="#ngxshareddictcapacity">capacity</a></li>
<li><a href="#ngxshareddictfree_space">free_space</a></li>
</ul>
<p>All these methods are <em>atomic</em> operations, that is, safe from
concurrent accesses from multiple Nginx worker processes for the same
<code>lua_shared_dict</code> zone.</p>
<p>Here is an example:</p>
<pre class="nginx"><code>
 http {
     lua_shared_dict dogs 10m;
     server {
         location /set {
             content_by_lua_block {
                 local dogs = ngx.shared.dogs
                 dogs:set(&quot;Jim&quot;, 8)
                 ngx.say(&quot;STORED&quot;)
             }
         }
         location /get {
             content_by_lua_block {
                 local dogs = ngx.shared.dogs
                 ngx.say(dogs:get(&quot;Jim&quot;))
             }
         }
     }
 }</code></pre>
<p>Let us test it:</p>
<div class="sourceCode" id="cb254"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a> <span class="ex">$</span> curl localhost/set</span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">STORED</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">$</span> curl localhost/get</span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">8</span></span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a> <span class="ex">$</span> curl localhost/get</span>
<span id="cb254-9"><a href="#cb254-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">8</span></span></code></pre></div>
<p>The number <code>8</code> will be consistently output when accessing
<code>/get</code> regardless of how many Nginx workers there are because
the <code>dogs</code> dictionary resides in the shared memory and
visible to <em>all</em> of the worker processes.</p>
<p>The shared dictionary will retain its contents through a server
config reload (either by sending the <code>HUP</code> signal to the
Nginx process or by using the <code>-s reload</code> command-line
option).</p>
<p>The contents in the dictionary storage will be lost, however, when
the Nginx server quits.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.get">ngx.shared.DICT.get</h2>
<p><strong>syntax:</strong> <em>value, flags =
ngx.shared.DICT:get(key)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Retrieving the value in the dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a> for the key <code>key</code>.
If the key does not exist or has expired, then <code>nil</code> will be
returned.</p>
<p>In case of errors, <code>nil</code> and a string describing the error
will be returned.</p>
<p>The value returned will have the original data type when they were
inserted into the dictionary, for example, Lua booleans, numbers, or
strings.</p>
<p>The first argument to this method must be the dictionary object
itself, for example,</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">value</span><span class="op">,</span> <span class="va">flags</span> <span class="op">=</span> <span class="va">cats</span><span class="op">.</span>get<span class="op">(</span><span class="va">cats</span><span class="op">,</span> <span class="st">&quot;Marry&quot;</span><span class="op">)</span></span></code></pre></div>
<p>or use Lua's syntactic sugar for method calls:</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">value</span><span class="op">,</span> <span class="va">flags</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>get<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">)</span></span></code></pre></div>
<p>These two forms are fundamentally equivalent.</p>
<p>If the user flags is <code>0</code> (the default), then no flags
value will be returned.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.get_stale">ngx.shared.DICT.get_stale</h2>
<p><strong>syntax:</strong> <em>value, flags, stale =
ngx.shared.DICT:get_stale(key)</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Similar to the <a href="#ngxshareddictget">get</a> method but returns
the value even if the key has already expired.</p>
<p>Returns a 3rd value, <code>stale</code>, indicating whether the key
has expired or not.</p>
<p>Note that the value of an expired key is not guaranteed to be
available so one should never rely on the availability of expired
items.</p>
<p>This method was first introduced in the <code>0.8.6</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.set">ngx.shared.DICT.set</h2>
<p><strong>syntax:</strong> <em>success, err, forcible =
ngx.shared.DICT:set(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Unconditionally sets a key-value pair into the shm-based dictionary
<a href="#ngxshareddict">ngx.shared.DICT</a>. Returns three values:</p>
<ul>
<li><code>success</code>: boolean value to indicate whether the
key-value pair is stored or not.</li>
<li><code>err</code>: textual error message, can be
<code>"no memory"</code>.</li>
<li><code>forcible</code>: a boolean value to indicate whether other
valid items have been removed forcibly when out of storage in the shared
memory zone.</li>
</ul>
<p>The <code>value</code> argument inserted can be Lua booleans,
numbers, strings, or <code>nil</code>. Their value type will also be
stored into the dictionary and the same data type can be retrieved later
via the <a href="#ngxshareddictget">get</a> method.</p>
<p>The optional <code>exptime</code> argument specifies expiration time
(in seconds) for the inserted key-value pair. The time resolution is
<code>0.001</code> seconds. If the <code>exptime</code> takes the value
<code>0</code> (which is the default), then the item will never
expire.</p>
<p>The optional <code>flags</code> argument specifies a user flags value
associated with the entry to be stored. It can also be retrieved later
with the value. The user flags is stored as an unsigned 32-bit integer
internally. Defaults to <code>0</code>. The user flags argument was
first introduced in the <code>v0.5.0rc2</code> release.</p>
<p>When it fails to allocate memory for the current key-value item, then
<code>set</code> will try removing existing items in the storage
according to the Least-Recently Used (LRU) algorithm. Note that, LRU
takes priority over expiration time here. If up to tens of existing
items have been removed and the storage left is still insufficient
(either due to the total capacity limit specified by <a
href="#lua_shared_dict">lua_shared_dict</a> or memory segmentation),
then the <code>err</code> return value will be <code>no memory</code>
and <code>success</code> will be <code>false</code>.</p>
<p>If the sizes of items in the dictionary are not multiples or even
powers of a certain value (like 2), it is easier to encounter
<code>no memory</code> error because of memory fragmentation. It is
recommended to use different dictionaries for different sizes of
items.</p>
<p>When you encounter <code>no memory</code> error, you can also evict
more least-recently-used items by retrying this method call more times
to to make room for the current item.</p>
<p>If this method succeeds in storing the current item by forcibly
removing other not-yet-expired items in the dictionary via LRU, the
<code>forcible</code> return value will be <code>true</code>. If it
stores the item without forcibly removing other valid items, then the
return value <code>forcible</code> will be <code>false</code>.</p>
<p>The first argument to this method must be the dictionary object
itself, for example,</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">succ</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">forcible</span> <span class="op">=</span> <span class="va">cats</span><span class="op">.</span>set<span class="op">(</span><span class="va">cats</span><span class="op">,</span> <span class="st">&quot;Marry&quot;</span><span class="op">,</span> <span class="st">&quot;it is a nice cat!&quot;</span><span class="op">)</span></span></code></pre></div>
<p>or use Lua's syntactic sugar for method calls:</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">succ</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">forcible</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>set<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">,</span> <span class="st">&quot;it is a nice cat!&quot;</span><span class="op">)</span></span></code></pre></div>
<p>These two forms are fundamentally equivalent.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p>Please note that while internally the key-value pair is set
atomically, the atomicity does not go across the method call
boundary.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.safe_set">ngx.shared.DICT.safe_set</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_set(key,
value, exptime?, flags?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Similar to the <a href="#ngxshareddictset">set</a> method, but never
overrides the (least recently used) unexpired items in the store when
running out of storage in the shared memory zone. In this case, it will
immediately return <code>nil</code> and the string "no memory".</p>
<p>This feature was first introduced in the <code>v0.7.18</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.add">ngx.shared.DICT.add</h2>
<p><strong>syntax:</strong> <em>success, err, forcible =
ngx.shared.DICT:add(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Just like the <a href="#ngxshareddictset">set</a> method, but only
stores the key-value pair into the dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a> if the key does <em>not</em>
exist.</p>
<p>If the <code>key</code> argument already exists in the dictionary
(and not expired for sure), the <code>success</code> return value will
be <code>false</code> and the <code>err</code> return value will be
<code>"exists"</code>.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.safe_add">ngx.shared.DICT.safe_add</h2>
<p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_add(key,
value, exptime?, flags?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Similar to the <a href="#ngxshareddictadd">add</a> method, but never
overrides the (least recently used) unexpired items in the store when
running out of storage in the shared memory zone. In this case, it will
immediately return <code>nil</code> and the string "no memory".</p>
<p>This feature was first introduced in the <code>v0.7.18</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.replace">ngx.shared.DICT.replace</h2>
<p><strong>syntax:</strong> <em>success, err, forcible =
ngx.shared.DICT:replace(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Just like the <a href="#ngxshareddictset">set</a> method, but only
stores the key-value pair into the dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a> if the key <em>does</em>
exist.</p>
<p>If the <code>key</code> argument does <em>not</em> exist in the
dictionary (or expired already), the <code>success</code> return value
will be <code>false</code> and the <code>err</code> return value will be
<code>"not found"</code>.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.delete">ngx.shared.DICT.delete</h2>
<p><strong>syntax:</strong> <em>ngx.shared.DICT:delete(key)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Unconditionally removes the key-value pair from the shm-based
dictionary <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p>It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.incr">ngx.shared.DICT.incr</h2>
<p><strong>syntax:</strong> <em>newval, err, forcible? =
ngx.shared.DICT:incr(key, value, init?, init_ttl?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p><strong>optional requirement:</strong> <code>resty.core.shdict</code>
or <code>resty.core</code></p>
<p>Increments the (numerical) value for <code>key</code> in the
shm-based dictionary <a href="#ngxshareddict">ngx.shared.DICT</a> by the
step value <code>value</code>. Returns the new resulting number if the
operation is successfully completed or <code>nil</code> and an error
message otherwise.</p>
<p>When the key does not exist or has already expired in the shared
dictionary,</p>
<ol type="1">
<li>if the <code>init</code> argument is not specified or takes the
value <code>nil</code>, this method will return <code>nil</code> and the
error string <code>"not found"</code>, or</li>
<li>if the <code>init</code> argument takes a number value, this method
will create a new <code>key</code> with the value
<code>init + value</code>.</li>
</ol>
<p>Like the <a href="#ngxshareddictadd">add</a> method, it also
overrides the (least recently used) unexpired items in the store when
running out of storage in the shared memory zone.</p>
<p>The optional <code>init_ttl</code> argument specifies expiration time
(in seconds) of the value when it is initialized via the
<code>init</code> argument. The time resolution is <code>0.001</code>
seconds. If <code>init_ttl</code> takes the value <code>0</code> (which
is the default), then the item will never expire. This argument cannot
be provided without providing the <code>init</code> argument as well,
and has no effect if the value already exists (e.g., if it was
previously inserted via <a href="#ngxshareddictset">set</a> or the
likes).</p>
<p><strong>Note:</strong> Usage of the <code>init_ttl</code> argument
requires the <code>resty.core.shdict</code> or <code>resty.core</code>
modules from the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library. Example:</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">require</span> <span class="st">&quot;resty.core&quot;</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">newval</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>incr<span class="op">(</span><span class="st">&quot;black_cats&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0.1</span><span class="op">)</span></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a> <span class="fu">print</span><span class="op">(</span><span class="va">newval</span><span class="op">)</span> <span class="co">-- 1</span></span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>sleep<span class="op">(</span><span class="dv">0.2</span><span class="op">)</span></span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-11"><a href="#cb259-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">val</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>get<span class="op">(</span><span class="st">&quot;black_cats&quot;</span><span class="op">)</span></span>
<span id="cb259-12"><a href="#cb259-12" aria-hidden="true" tabindex="-1"></a> <span class="fu">print</span><span class="op">(</span><span class="va">val</span><span class="op">)</span> <span class="co">-- nil</span></span></code></pre></div>
<p>The <code>forcible</code> return value will always be
<code>nil</code> when the <code>init</code> argument is not
specified.</p>
<p>If this method succeeds in storing the current item by forcibly
removing other not-yet-expired items in the dictionary via LRU, the
<code>forcible</code> return value will be <code>true</code>. If it
stores the item without forcibly removing other valid items, then the
return value <code>forcible</code> will be <code>false</code>.</p>
<p>If the original value is not a valid Lua number in the dictionary, it
will return <code>nil</code> and <code>"not a number"</code>.</p>
<p>The <code>value</code> argument and <code>init</code> argument can be
any valid Lua numbers, like negative numbers or floating-point
numbers.</p>
<p>This method was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p>The optional <code>init</code> parameter was first added in the
<code>v0.10.6</code> release.</p>
<p>The optional <code>init_ttl</code> parameter was introduced in the
<code>v0.10.12rc2</code> release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.lpush">ngx.shared.DICT.lpush</h2>
<p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:lpush(key,
value)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Inserts the specified (numerical or string) <code>value</code> at the
head of the list named <code>key</code> in the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a>. Returns the number of
elements in the list after the push operation.</p>
<p>If <code>key</code> does not exist, it is created as an empty list
before performing the push operation. When the <code>key</code> already
takes a value that is not a list, it will return <code>nil</code> and
<code>"value not a list"</code>.</p>
<p>It never overrides the (least recently used) unexpired items in the
store when running out of storage in the shared memory zone. In this
case, it will immediately return <code>nil</code> and the string "no
memory".</p>
<p>This feature was first introduced in the <code>v0.10.6</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.rpush">ngx.shared.DICT.rpush</h2>
<p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:rpush(key,
value)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Similar to the <a href="#ngxshareddictlpush">lpush</a> method, but
inserts the specified (numerical or string) <code>value</code> at the
tail of the list named <code>key</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.lpop">ngx.shared.DICT.lpop</h2>
<p><strong>syntax:</strong> <em>val, err =
ngx.shared.DICT:lpop(key)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Removes and returns the first element of the list named
<code>key</code> in the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p>If <code>key</code> does not exist, it will return <code>nil</code>.
When the <code>key</code> already takes a value that is not a list, it
will return <code>nil</code> and <code>"value not a list"</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.rpop">ngx.shared.DICT.rpop</h2>
<p><strong>syntax:</strong> <em>val, err =
ngx.shared.DICT:rpop(key)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Removes and returns the last element of the list named
<code>key</code> in the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p>If <code>key</code> does not exist, it will return <code>nil</code>.
When the <code>key</code> already takes a value that is not a list, it
will return <code>nil</code> and <code>"value not a list"</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.llen">ngx.shared.DICT.llen</h2>
<p><strong>syntax:</strong> <em>len, err =
ngx.shared.DICT:llen(key)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Returns the number of elements in the list named <code>key</code> in
the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p>If key does not exist, it is interpreted as an empty list and 0 is
returned. When the <code>key</code> already takes a value that is not a
list, it will return <code>nil</code> and
<code>"value not a list"</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code>
release.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.ttl">ngx.shared.DICT.ttl</h2>
<p><strong>syntax:</strong> <em>ttl, err =
ngx.shared.DICT:ttl(key)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or
<code>resty.core</code></p>
<p>Retrieves the remaining TTL (time-to-live in seconds) of a key-value
pair in the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a>. Returns the TTL as a number
if the operation is successfully completed or <code>nil</code> and an
error message otherwise.</p>
<p>If the key does not exist (or has already expired), this method will
return <code>nil</code> and the error string
<code>"not found"</code>.</p>
<p>The TTL is originally determined by the <code>exptime</code> argument
of the <a href="#ngxshareddictset">set</a>, <a
href="#ngxshareddictadd">add</a>, <a
href="#ngxshareddictreplace">replace</a> (and the likes) methods. It has
a time resolution of <code>0.001</code> seconds. A value of
<code>0</code> means that the item will never expire.</p>
<p>Example:</p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">require</span> <span class="st">&quot;resty.core&quot;</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">succ</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>set<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">,</span> <span class="st">&quot;a nice cat&quot;</span><span class="op">,</span> <span class="dv">0.5</span><span class="op">)</span></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>sleep<span class="op">(</span><span class="dv">0.2</span><span class="op">)</span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ttl</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>ttl<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">)</span></span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">ttl</span><span class="op">)</span> <span class="co">-- 0.3</span></span></code></pre></div>
<p>This feature was first introduced in the <code>v0.10.11</code>
release.</p>
<p><strong>Note:</strong> This method requires the
<code>resty.core.shdict</code> or <code>resty.core</code> modules from
the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.expire">ngx.shared.DICT.expire</h2>
<p><strong>syntax:</strong> <em>success, err =
ngx.shared.DICT:expire(key, exptime)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or
<code>resty.core</code></p>
<p>Updates the <code>exptime</code> (in second) of a key-value pair in
the shm-based dictionary <a href="#ngxshareddict">ngx.shared.DICT</a>.
Returns a boolean indicating success if the operation completes or
<code>nil</code> and an error message otherwise.</p>
<p>If the key does not exist, this method will return <code>nil</code>
and the error string <code>"not found"</code>.</p>
<p>The <code>exptime</code> argument has a resolution of
<code>0.001</code> seconds. If <code>exptime</code> is <code>0</code>,
then the item will never expire.</p>
<p>Example:</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">require</span> <span class="st">&quot;resty.core&quot;</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">succ</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>set<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">,</span> <span class="st">&quot;a nice cat&quot;</span><span class="op">,</span> <span class="dv">0.1</span><span class="op">)</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a> <span class="va">succ</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>expire<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">,</span> <span class="dv">0.5</span><span class="op">)</span></span>
<span id="cb261-8"><a href="#cb261-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-9"><a href="#cb261-9" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>sleep<span class="op">(</span><span class="dv">0.2</span><span class="op">)</span></span>
<span id="cb261-10"><a href="#cb261-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-11"><a href="#cb261-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">val</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>get<span class="op">(</span><span class="st">&quot;Marry&quot;</span><span class="op">)</span></span>
<span id="cb261-12"><a href="#cb261-12" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">val</span><span class="op">)</span> <span class="co">-- &quot;a nice cat&quot;</span></span></code></pre></div>
<p>This feature was first introduced in the <code>v0.10.11</code>
release.</p>
<p><strong>Note:</strong> This method requires the
<code>resty.core.shdict</code> or <code>resty.core</code> modules from
the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.flush_all">ngx.shared.DICT.flush_all</h2>
<p><strong>syntax:</strong> <em>ngx.shared.DICT:flush_all()</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Flushes out all the items in the dictionary. This method does not
actually free up all the memory blocks in the dictionary but just marks
all the existing items as expired.</p>
<p>This feature was first introduced in the <code>v0.5.0rc17</code>
release.</p>
<p>See also <a
href="#ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</a> and
<a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2
id="ngx.shared.dict.flush_expired">ngx.shared.DICT.flush_expired</h2>
<p><strong>syntax:</strong> <em>flushed =
ngx.shared.DICT:flush_expired(max_count?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Flushes out the expired items in the dictionary, up to the maximal
number specified by the optional <code>max_count</code> argument. When
the <code>max_count</code> argument is given <code>0</code> or not given
at all, then it means unlimited. Returns the number of items that have
actually been flushed.</p>
<p>Unlike the <a href="#ngxshareddictflush_all">flush_all</a> method,
this method actually frees up the memory used by the expired items.</p>
<p>This feature was first introduced in the <code>v0.6.3</code>
release.</p>
<p>See also <a
href="#ngxshareddictflush_all">ngx.shared.DICT.flush_all</a> and <a
href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.get_keys">ngx.shared.DICT.get_keys</h2>
<p><strong>syntax:</strong> <em>keys =
ngx.shared.DICT:get_keys(max_count?)</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Fetch a list of the keys from the dictionary, up to
<code>&lt;max_count&gt;</code>.</p>
<p>By default, only the first 1024 keys (if any) are returned. When the
<code>&lt;max_count&gt;</code> argument is given the value
<code>0</code>, then all the keys will be returned even there is more
than 1024 keys in the dictionary.</p>
<p><strong>CAUTION</strong> Avoid calling this method on dictionaries
with a very large number of keys as it may lock the dictionary for
significant amount of time and block Nginx worker processes trying to
access the dictionary.</p>
<p>This feature was first introduced in the <code>v0.7.3</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.capacity">ngx.shared.DICT.capacity</h2>
<p><strong>syntax:</strong> <em>capacity_bytes =
ngx.shared.DICT:capacity()</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or
<code>resty.core</code></p>
<p>Retrieves the capacity in bytes for the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a> declared with the <a
href="#lua_shared_dict">lua_shared_dict</a> directive.</p>
<p>Example:</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">require</span> <span class="st">&quot;resty.core.shdict&quot;</span></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">capacity_bytes</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>capacity<span class="op">()</span></span></code></pre></div>
<p>This feature was first introduced in the <code>v0.10.11</code>
release.</p>
<p><strong>Note:</strong> This method requires the
<code>resty.core.shdict</code> or <code>resty.core</code> modules from
the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>This feature requires at least Nginx core version
<code>0.7.3</code>.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.shared.dict.free_space">ngx.shared.DICT.free_space</h2>
<p><strong>syntax:</strong> <em>free_page_bytes =
ngx.shared.DICT:free_space()</em></p>
<p><strong>context:</strong> <em>init_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or
<code>resty.core</code></p>
<p>Retrieves the free page size in bytes for the shm-based dictionary <a
href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><strong>Note:</strong> The memory for ngx.shared.DICT is allocated
via the Nginx slab allocator which has each slot for data size ranges
like ~8, 9~16, 17~32, ..., 1025~2048, 2048~ bytes. And pages are assigned
to a slot if there is no room in already assigned pages for the
slot.</p>
<p>So even if the return value of the <code>free_space</code> method is
zero, there may be room in already assigned pages, so you may
successfully set a new key value pair to the shared dict without getting
<code>true</code> for <code>forcible</code> or non nil <code>err</code>
from the <code>ngx.shared.DICT.set</code>.</p>
<p>On the other hand, if already assigned pages for a slot are full and
a new key value pair is added to the slot and there is no free page, you
may get <code>true</code> for <code>forcible</code> or non nil
<code>err</code> from the <code>ngx.shared.DICT.set</code> method.</p>
<p>Example:</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a> <span class="fu">require</span> <span class="st">&quot;resty.core.shdict&quot;</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">cats</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">shared</span><span class="op">.</span><span class="va">cats</span></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">free_page_bytes</span> <span class="op">=</span> <span class="va">cats</span><span class="op">:</span>free_space<span class="op">()</span></span></code></pre></div>
<p>This feature was first introduced in the <code>v0.10.11</code>
release.</p>
<p><strong>Note:</strong> This method requires the
<code>resty.core.shdict</code> or <code>resty.core</code> modules from
the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>This feature requires at least Nginx core version
<code>1.11.7</code>.</p>
<p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.socket.udp">ngx.socket.udp</h2>
<p><strong>syntax:</strong> <em>udpsock = ngx.socket.udp()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Creates and returns a UDP or datagram-oriented unix domain socket
object (also known as one type of the "cosocket" objects). The following
methods are supported on this object:</p>
<ul>
<li><a href="#udpsockbind">bind</a></li>
<li><a href="#udpsocksetpeername">setpeername</a></li>
<li><a href="#udpsocksend">send</a></li>
<li><a href="#udpsockreceive">receive</a></li>
<li><a href="#udpsockclose">close</a></li>
<li><a href="#udpsocksettimeout">settimeout</a></li>
</ul>
<p>It is intended to be compatible with the UDP API of the <a
href="http://w3.impa.br/~diego/software/luasocket/udp.html">LuaSocket</a>
library but is 100% nonblocking out of the box.</p>
<p>This feature was first introduced in the <code>v0.5.7</code>
release.</p>
<p>See also <a href="#ngxsockettcp">ngx.socket.tcp</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="udpsockbind">udpsock:bind</h2>
<p><strong>syntax:</strong> <em>ok, err = udpsock:bind(address)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*,
ssl_certificate_by_lua*,ssl_session_fetch_by_lua*,ssl_client_hello_by_lua*</em></p>
<p>Just like the standard <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind">proxy_bind</a>
directive, this api makes the outgoing connection to a upstream server
originate from the specified local IP address.</p>
<p>Only IP addresses can be specified as the <code>address</code>
argument.</p>
<p>Here is an example for connecting to a TCP server from the specified
local IP address:</p>
<pre class="nginx"><code>
 location /test {
     content_by_lua_block {
         local sock = ngx.socket.udp()
         -- assume &quot;192.168.1.10&quot; is the local ip address
         local ok, err = sock:bind(&quot;192.168.1.10&quot;)
         if not ok then
             ngx.say(&quot;failed to bind: &quot;, err)
             return
         end
         sock:close()
     }
 }</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="udpsocksetpeername">udpsock:setpeername</h2>
<p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(host,
port)</em></p>
<p><strong>syntax:</strong> <em>ok, err =
udpsock:setpeername("unix:/path/to/unix-domain.socket")</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Attempts to connect a UDP socket object to a remote server or to a
datagram unix domain socket file. Because the datagram protocol is
actually connection-less, this method does not really establish a
"connection", but only just set the name of the remote peer for
subsequent read/write operations.</p>
<p>Both IP addresses and domain names can be specified as the
<code>host</code> argument. In case of domain names, this method will
use Nginx core's dynamic resolver to parse the domain name without
blocking and it is required to configure the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver">resolver</a>
directive in the <code>nginx.conf</code> file like this:</p>
<pre class="nginx"><code>
 resolver 8.8.8.8;  # use Google&#39;s public DNS nameserver</code></pre>
<p>If the nameserver returns multiple IP addresses for the host name,
this method will pick up one randomly.</p>
<p>In case of error, the method returns <code>nil</code> followed by a
string describing the error. In case of success, the method returns
<code>1</code>.</p>
<p>Here is an example for connecting to a UDP (memcached) server:</p>
<pre class="nginx"><code>
 location /test {
     resolver 8.8.8.8;

     content_by_lua_block {
         local sock = ngx.socket.udp()
         local ok, err = sock:setpeername(&quot;my.memcached.server.domain&quot;, 11211)
         if not ok then
             ngx.say(&quot;failed to connect to memcached: &quot;, err)
             return
         end
         ngx.say(&quot;successfully connected to memcached!&quot;)
         sock:close()
     }
 }</code></pre>
<p>Since the <code>v0.7.18</code> release, connecting to a datagram unix
domain socket file is also possible on Linux:</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">sock</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">socket</span><span class="op">.</span>udp<span class="op">()</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>setpeername<span class="op">(</span><span class="st">&quot;unix:/tmp/some-datagram-service.sock&quot;</span><span class="op">)</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to connect to the datagram unix domain socket: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a> <span class="co">-- do something after connect</span></span>
<span id="cb267-10"><a href="#cb267-10" aria-hidden="true" tabindex="-1"></a> <span class="co">-- such as sock:send or sock:receive</span></span></code></pre></div>
<p>assuming the datagram service is listening on the unix domain socket
file <code>/tmp/some-datagram-service.sock</code> and the client socket
will use the "autobind" feature on Linux.</p>
<p>Calling this method on an already connected socket object will cause
the original connection to be closed first.</p>
<p>This method was first introduced in the <code>v0.5.7</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="udpsocksend">udpsock:send</h2>
<p><strong>syntax:</strong> <em>ok, err = udpsock:send(data)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Sends data on the current UDP or datagram unix domain socket
object.</p>
<p>In case of success, it returns <code>1</code>. Otherwise, it returns
<code>nil</code> and a string describing the error.</p>
<p>The input argument <code>data</code> can either be a Lua string or a
(nested) Lua table holding string fragments. In case of table arguments,
this method will copy all the string elements piece by piece to the
underlying Nginx socket send buffers, which is usually optimal than
doing string concatenation operations on the Lua land.</p>
<p>This feature was first introduced in the <code>v0.5.7</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="udpsockreceive">udpsock:receive</h2>
<p><strong>syntax:</strong> <em>data, err =
udpsock:receive(size?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Receives data from the UDP or datagram unix domain socket object with
an optional receive buffer size argument, <code>size</code>.</p>
<p>This method is a synchronous operation and is 100% nonblocking.</p>
<p>In case of success, it returns the data received; in case of error,
it returns <code>nil</code> with a string describing the error.</p>
<p>If the <code>size</code> argument is specified, then this method will
use this size as the receive buffer size. But when this size is greater
than <code>8192</code>, then <code>8192</code> will be used instead.</p>
<p>If no argument is specified, then the maximal buffer size,
<code>8192</code> is assumed.</p>
<p>Timeout for the reading operation is controlled by the <a
href="#lua_socket_read_timeout">lua_socket_read_timeout</a> config
directive and the <a href="#udpsocksettimeout">settimeout</a> method.
And the latter takes priority. For example:</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a> <span class="va">sock</span><span class="op">:</span>settimeout<span class="op">(</span><span class="dv">1000</span><span class="op">)</span>  <span class="co">-- one second timeout</span></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">data</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>receive<span class="op">()</span></span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">data</span> <span class="cf">then</span></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to read a packet: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb268-8"><a href="#cb268-8" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;successfully read a packet: &quot;</span><span class="op">,</span> <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>It is important here to call the <a
href="#udpsocksettimeout">settimeout</a> method <em>before</em> calling
this method.</p>
<p>This feature was first introduced in the <code>v0.5.7</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="udpsockclose">udpsock:close</h2>
<p><strong>syntax:</strong> <em>ok, err = udpsock:close()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Closes the current UDP or datagram unix domain socket. It returns the
<code>1</code> in case of success and returns <code>nil</code> with a
string describing the error otherwise.</p>
<p>Socket objects that have not invoked this method (and associated
connections) will be closed when the socket object is released by the
Lua GC (Garbage Collector) or the current client HTTP request finishes
processing.</p>
<p>This feature was first introduced in the <code>v0.5.7</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="udpsocksettimeout">udpsock:settimeout</h2>
<p><strong>syntax:</strong> <em>udpsock:settimeout(time)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Set the timeout value in milliseconds for subsequent socket
operations (like <a href="#udpsockreceive">receive</a>).</p>
<p>Settings done by this method takes priority over those config
directives, like <a
href="#lua_socket_read_timeout">lua_socket_read_timeout</a>.</p>
<p>This feature was first introduced in the <code>v0.5.7</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.socket.stream">ngx.socket.stream</h2>
<p>Just an alias to <a href="#ngxsockettcp">ngx.socket.tcp</a>. If the
stream-typed cosocket may also connect to a unix domain socket, then
this API name is preferred.</p>
<p>This API function was first added to the <code>v0.10.1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.socket.tcp">ngx.socket.tcp</h2>
<p><strong>syntax:</strong> <em>tcpsock = ngx.socket.tcp()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Creates and returns a TCP or stream-oriented unix domain socket
object (also known as one type of the "cosocket" objects). The following
methods are supported on this object:</p>
<ul>
<li><a href="#tcpsockbind">bind</a></li>
<li><a href="#tcpsockconnect">connect</a></li>
<li><a href="#tcpsocksetclientcert">setclientcert</a></li>
<li><a href="#tcpsocksslhandshake">sslhandshake</a></li>
<li><a href="#tcpsocksend">send</a></li>
<li><a href="#tcpsockreceive">receive</a></li>
<li><a href="#tcpsockclose">close</a></li>
<li><a href="#tcpsocksettimeout">settimeout</a></li>
<li><a href="#tcpsocksettimeouts">settimeouts</a></li>
<li><a href="#tcpsocksetoption">setoption</a></li>
<li><a href="#tcpsockreceiveany">receiveany</a></li>
<li><a href="#tcpsockreceiveuntil">receiveuntil</a></li>
<li><a href="#tcpsocksetkeepalive">setkeepalive</a></li>
<li><a href="#tcpsockgetreusedtimes">getreusedtimes</a></li>
</ul>
<p>It is intended to be compatible with the TCP API of the <a
href="http://w3.impa.br/~diego/software/luasocket/tcp.html">LuaSocket</a>
library but is 100% nonblocking out of the box. Also, we introduce some
new APIs to provide more functionalities.</p>
<p>The cosocket object created by this API function has exactly the same
lifetime as the Lua handler creating it. So never pass the cosocket
object to any other Lua handler (including ngx.timer callback functions)
and never share the cosocket object between different Nginx
requests.</p>
<p>For every cosocket object's underlying connection, if you do not
explicitly close it (via <a href="#tcpsockclose">close</a>) or put it
back to the connection pool (via <a
href="#tcpsocksetkeepalive">setkeepalive</a>), then it is automatically
closed when one of the following two events happens:</p>
<ul>
<li>the current request handler completes, or</li>
<li>the Lua cosocket object value gets collected by the Lua GC.</li>
</ul>
<p>Fatal errors in cosocket operations always automatically close the
current connection (note that, read timeout error is the only error that
is not fatal), and if you call <a href="#tcpsockclose">close</a> on a
closed connection, you will get the "closed" error.</p>
<p>Starting from the <code>0.9.9</code> release, the cosocket object
here is full-duplex, that is, a reader "light thread" and a writer
"light thread" can operate on a single cosocket object simultaneously
(both "light threads" must belong to the same Lua handler though, see
reasons above). But you cannot have two "light threads" both reading (or
writing or connecting) the same cosocket, otherwise you might get an
error like "socket busy reading" when calling the methods of the
cosocket object.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p>See also <a href="#ngxsocketudp">ngx.socket.udp</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockbind">tcpsock:bind</h2>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:bind(address,
port?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*,
ssl_certificate_by_lua*,ssl_session_fetch_by_lua*,ssl_client_hello_by_lua*</em></p>
<p>Just like the standard <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind">proxy_bind</a>
directive, this api makes the outgoing connection to a upstream server
originate from the specified local IP address.</p>
<p>IP addresses can be specified as the <code>address</code> argument.
The optional <code>port</code> argument is usually used in the
transparent proxy.</p>
<p>Here is an example for connecting to a TCP server from the specified
local IP address:</p>
<pre class="nginx"><code>
 location /test {
     content_by_lua_block {
         local sock = ngx.socket.tcp()
         -- assume &quot;192.168.1.10&quot; is the local ip address
         local ok, err = sock:bind(&quot;192.168.1.10&quot;)
         if not ok then
             ngx.say(&quot;failed to bind&quot;)
             return
         end
         local ok, err = sock:connect(&quot;192.168.1.67&quot;, 80)
         if not ok then
             ngx.say(&quot;failed to connect server: &quot;, err)
             return
         end
         ngx.say(&quot;successfully connected!&quot;)
         sock:close()
     }
 }</code></pre>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockconnect">tcpsock:connect</h2>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(host, port,
options_table?)</em></p>
<p><strong>syntax:</strong> <em>ok, err =
tcpsock:connect("unix:/path/to/unix-domain.socket",
options_table?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Attempts to connect a TCP socket object to a remote server or to a
stream unix domain socket file without blocking.</p>
<p>Before actually resolving the host name and connecting to the remote
backend, this method will always look up the connection pool for matched
idle connections created by previous calls of this method (or the <a
href="#ngxsocketconnect">ngx.socket.connect</a> function).</p>
<p>Both IP addresses and domain names can be specified as the
<code>host</code> argument. In case of domain names, this method will
use Nginx core's dynamic resolver to parse the domain name without
blocking and it is required to configure the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver">resolver</a>
directive in the <code>nginx.conf</code> file like this:</p>
<pre class="nginx"><code>
 resolver 8.8.8.8;  # use Google&#39;s public DNS nameserver</code></pre>
<p>If the nameserver returns multiple IP addresses for the host name,
this method will pick up one randomly.</p>
<p>In case of error, the method returns <code>nil</code> followed by a
string describing the error. In case of success, the method returns
<code>1</code>.</p>
<p>Here is an example for connecting to a TCP server:</p>
<pre class="nginx"><code>
 location /test {
     resolver 8.8.8.8;

     content_by_lua_block {
         local sock = ngx.socket.tcp()
         local ok, err = sock:connect(&quot;www.google.com&quot;, 80)
         if not ok then
             ngx.say(&quot;failed to connect to google: &quot;, err)
             return
         end
         ngx.say(&quot;successfully connected to google!&quot;)
         sock:close()
     }
 }</code></pre>
<p>Connecting to a Unix Domain Socket file is also possible:</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">sock</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">socket</span><span class="op">.</span>tcp<span class="op">()</span></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span><span class="fu">connect</span><span class="op">(</span><span class="st">&quot;unix:/tmp/memcached.sock&quot;</span><span class="op">)</span></span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to connect to the memcached unix domain socket: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb272-8"><a href="#cb272-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-9"><a href="#cb272-9" aria-hidden="true" tabindex="-1"></a> <span class="co">-- do something after connect</span></span>
<span id="cb272-10"><a href="#cb272-10" aria-hidden="true" tabindex="-1"></a> <span class="co">-- such as sock:send or sock:receive</span></span></code></pre></div>
<p>assuming memcached (or something else) is listening on the unix
domain socket file <code>/tmp/memcached.sock</code>.</p>
<p>Timeout for the connecting operation is controlled by the <a
href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a> config
directive and the <a href="#tcpsocksettimeout">settimeout</a> method.
And the latter takes priority. For example:</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">sock</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">socket</span><span class="op">.</span>tcp<span class="op">()</span></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a> <span class="va">sock</span><span class="op">:</span>settimeout<span class="op">(</span><span class="dv">1000</span><span class="op">)</span>  <span class="co">-- one second timeout</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span><span class="fu">connect</span><span class="op">(</span><span class="va">host</span><span class="op">,</span> <span class="va">port</span><span class="op">)</span></span></code></pre></div>
<p>It is important here to call the <a
href="#tcpsocksettimeout">settimeout</a> method <em>before</em> calling
this method.</p>
<p>Calling this method on an already connected socket object will cause
the original connection to be closed first.</p>
<p>An optional Lua table can be specified as the last argument to this
method to specify various connect options:</p>
<ul>
<li><p><code>pool</code> specify a custom name for the connection pool
being used. If omitted, then the connection pool name will be generated
from the string template <code>"&lt;host&gt;:&lt;port&gt;"</code> or
<code>"&lt;unix-socket-path&gt;"</code>.</p></li>
<li><p><code>pool_size</code> specify the size of the connection pool.
If omitted and no <code>backlog</code> option was provided, no pool will
be created. If omitted but <code>backlog</code> was provided, the pool
will be created with a default size equal to the value of the <a
href="#lua_socket_pool_size">lua_socket_pool_size</a> directive. The
connection pool holds up to <code>pool_size</code> alive connections
ready to be reused by subsequent calls to <a
href="#tcpsockconnect">connect</a>, but note that there is no upper
limit to the total number of opened connections outside of the pool. If
you need to restrict the total number of opened connections, specify the
<code>backlog</code> option. When the connection pool would exceed its
size limit, the least recently used (kept-alive) connection already in
the pool will be closed to make room for the current connection. Note
that the cosocket connection pool is per Nginx worker process rather
than per Nginx server instance, so the size limit specified here also
applies to every single Nginx worker process. Also note that the size of
the connection pool cannot be changed once it has been created. This
option was first introduced in the <code>v0.10.14</code>
release.</p></li>
<li><p><code>backlog</code> if specified, this module will limit the
total number of opened connections for this pool. No more connections
than <code>pool_size</code> can be opened for this pool at any time. If
<code>pool_size</code> number of connections are in use, subsequent
connect operations will be queued into a queue equal to this option's
value (the "backlog" queue). If the number of queued connect operations
is equal to <code>backlog</code>, subsequent connect operations will
fail and return <code>nil</code> plus the error string
<code>"too many waiting connect operations"</code>. The queued connect
operations will be resumed once the number of active connections becomes
less than <code>pool_size</code>. The queued connect operation will
abort once they have been queued for more than
<code>connect_timeout</code>, controlled by <a
href="#tcpsocksettimeouts">settimeouts</a>, and will return
<code>nil</code> plus the error string <code>"timeout"</code>. This
option was first introduced in the <code>v0.10.14</code>
release.</p></li>
</ul>
<p>The support for the options table argument was first introduced in
the <code>v0.5.7</code> release.</p>
<p>This method was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockgetfd">tcpsock:getfd</h2>
<p><strong>syntax:</strong> <em>fd, err = tcpsock:getfd()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Get the file describer of the current tcp socket.</p>
<p>This method was first introduced in the <code>v0.10.29</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksetclientcert">tcpsock:setclientcert</h2>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:setclientcert(cert,
pkey)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Set client certificate chain and corresponding private key to the TCP
socket object. The certificate chain and private key provided will be
used later by the <a
href="#tcpsocksslhandshake">tcpsock:sslhandshake</a> method.</p>
<ul>
<li><code>cert</code> specify a client certificate chain cdata object
that will be used while handshaking with remote server. These objects
can be created using <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md#parse_pem_cert">ngx.ssl.parse_pem_cert</a>
or <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md#parse_der_cert">ngx.ssl.parse_der_cert</a>
function provided by lua-resty-core. Note that specifying the
<code>cert</code> option requires corresponding <code>pkey</code> be
provided too. See below.</li>
<li><code>pkey</code> specify a private key corresponds to the
<code>cert</code> option above. These objects can be created using <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md#parse_pem_priv_key">ngx.ssl.parse_pem_priv_key</a>
or <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md#parse_der_priv_key">ngx.ssl.parse_der_priv_key</a>
function provided by lua-resty-core.</li>
</ul>
<p>If both of <code>cert</code> and <code>pkey</code> are
<code>nil</code>, this method will clear any existing client certificate
and private key that was previously set on the cosocket object.</p>
<p>This method was first introduced in the <code>v0.10.22</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksslhandshake">tcpsock:sslhandshake</h2>
<p><strong>syntax:</strong> <em>session, err =
tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?,
send_status_req?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Does SSL/TLS handshake on the currently established connection.</p>
<p>The optional <code>reused_session</code> argument can take a former
SSL session userdata returned by a previous <code>sslhandshake</code>
call for exactly the same target. For short-lived connections, reusing
SSL sessions can usually speed up the handshake by one order by
magnitude but it is not so useful if the connection pool is enabled.
This argument defaults to <code>nil</code>. If this argument takes the
boolean <code>false</code> value, no SSL session userdata would return
by this call and only a Lua boolean will be returned as the first return
value; otherwise the current SSL session will always be returned as the
first argument in case of successes.</p>
<p>The optional <code>server_name</code> argument is used to specify the
server name for the new TLS extension Server Name Indication (SNI). Use
of SNI can make different servers share the same IP address on the
server side. Also, when SSL verification is enabled, this
<code>server_name</code> argument is also used to validate the server
name specified in the server certificate sent from the remote.</p>
<p>The optional <code>ssl_verify</code> argument takes a Lua boolean
value to control whether to perform SSL verification. When set to
<code>true</code>, the server certificate will be verified according to
the CA certificates specified by the <a
href="#lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</a>
directive. You may also need to adjust the <a
href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a> directive to
control how deep we should follow along the certificate chain. Also,
when the <code>ssl_verify</code> argument is true and the
<code>server_name</code> argument is also specified, the latter will be
used to validate the server name in the server certificate.</p>
<p>The optional <code>send_status_req</code> argument takes a boolean
that controls whether to send the OCSP status request in the SSL
handshake request (which is for requesting OCSP stapling).</p>
<p>For connections that have already done SSL/TLS handshake, this method
returns immediately.</p>
<p>This method was first introduced in the <code>v0.9.11</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksend">tcpsock:send</h2>
<p><strong>syntax:</strong> <em>bytes, err = tcpsock:send(data)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Sends data without blocking on the current TCP or Unix Domain Socket
connection.</p>
<p>This method is a synchronous operation that will not return until
<em>all</em> the data has been flushed into the system socket send
buffer or an error occurs.</p>
<p>In case of success, it returns the total number of bytes that have
been sent. Otherwise, it returns <code>nil</code> and a string
describing the error.</p>
<p>The input argument <code>data</code> can either be a Lua string or a
(nested) Lua table holding string fragments. In case of table arguments,
this method will copy all the string elements piece by piece to the
underlying Nginx socket send buffers, which is usually optimal than
doing string concatenation operations on the Lua land.</p>
<p>Timeout for the sending operation is controlled by the <a
href="#lua_socket_send_timeout">lua_socket_send_timeout</a> config
directive and the <a href="#tcpsocksettimeout">settimeout</a> method.
And the latter takes priority. For example:</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a> <span class="va">sock</span><span class="op">:</span>settimeout<span class="op">(</span><span class="dv">1000</span><span class="op">)</span>  <span class="co">-- one second timeout</span></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">bytes</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>send<span class="op">(</span><span class="va">request</span><span class="op">)</span></span></code></pre></div>
<p>It is important here to call the <a
href="#tcpsocksettimeout">settimeout</a> method <em>before</em> calling
this method.</p>
<p>In case of any connection errors, this method always automatically
closes the current connection.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockreceive">tcpsock:receive</h2>
<p><strong>syntax:</strong> <em>data, err, partial =
tcpsock:receive(size)</em></p>
<p><strong>syntax:</strong> <em>data, err, partial =
tcpsock:receive(pattern?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Receives data from the connected socket according to the reading
pattern or size.</p>
<p>This method is a synchronous operation just like the <a
href="#tcpsocksend">send</a> method and is 100% nonblocking.</p>
<p>In case of success, it returns the data received; in case of error,
it returns <code>nil</code> with a string describing the error and the
partial data received so far.</p>
<p>If a number-like argument is specified (including strings that look
like numbers), then it is interpreted as a size. This method will not
return until it reads exactly this size of data or an error occurs.</p>
<p>If a non-number-like string argument is specified, then it is
interpreted as a "pattern". The following patterns are supported:</p>
<ul>
<li><code>'*a'</code>: reads from the socket until the connection is
closed. No end-of-line translation is performed;</li>
<li><code>'*l'</code>: reads a line of text from the socket. The line is
terminated by a <code>Line Feed</code> (LF) character (ASCII 10),
optionally preceded by a <code>Carriage Return</code> (CR) character
(ASCII 13). The CR and LF characters are not included in the returned
line. In fact, all CR characters are ignored by the pattern.</li>
</ul>
<p>If no argument is specified, then it is assumed to be the pattern
<code>'*l'</code>, that is, the line reading pattern.</p>
<p>Timeout for the reading operation is controlled by the <a
href="#lua_socket_read_timeout">lua_socket_read_timeout</a> config
directive and the <a href="#tcpsocksettimeout">settimeout</a> method.
And the latter takes priority. For example:</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a> <span class="va">sock</span><span class="op">:</span>settimeout<span class="op">(</span><span class="dv">1000</span><span class="op">)</span>  <span class="co">-- one second timeout</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">line</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">partial</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>receive<span class="op">()</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">line</span> <span class="cf">then</span></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to read a line: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;successfully read a line: &quot;</span><span class="op">,</span> <span class="va">line</span><span class="op">)</span></span></code></pre></div>
<p>It is important here to call the <a
href="#tcpsocksettimeout">settimeout</a> method <em>before</em> calling
this method.</p>
<p>Since the <code>v0.8.8</code> release, this method no longer
automatically closes the current connection when the read timeout error
happens. For other connection errors, this method always automatically
closes the connection.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockreceiveany">tcpsock:receiveany</h2>
<p><strong>syntax:</strong> <em>data, err =
tcpsock:receiveany(max)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Returns any data received by the connected socket, at most
<code>max</code> bytes.</p>
<p>This method is a synchronous operation just like the <a
href="#tcpsocksend">send</a> method and is 100% nonblocking.</p>
<p>In case of success, it returns the data received; in case of error,
it returns <code>nil</code> with a string describing the error.</p>
<p>If the received data is more than this size, this method will return
with exactly this size of data. The remaining data in the underlying
receive buffer could be returned in the next reading operation.</p>
<p>Timeout for the reading operation is controlled by the <a
href="#lua_socket_read_timeout">lua_socket_read_timeout</a> config
directive and the <a href="#tcpsocksettimeouts">settimeouts</a> method.
And the latter takes priority. For example:</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a> <span class="va">sock</span><span class="op">:</span>settimeouts<span class="op">(</span><span class="dv">1000</span><span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="dv">1000</span><span class="op">)</span>  <span class="co">-- one second timeout for connect/read/write</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">data</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>receiveany<span class="op">(</span><span class="dv">10</span> <span class="op">*</span> <span class="dv">1024</span><span class="op">)</span> <span class="co">-- read any data, at most 10K</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">data</span> <span class="cf">then</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to read any data: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;successfully read: &quot;</span><span class="op">,</span> <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>This method doesn't automatically close the current connection when
the read timeout error occurs. For other connection errors, this method
always automatically closes the connection.</p>
<p>This feature was first introduced in the <code>v0.10.14</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockreceiveuntil">tcpsock:receiveuntil</h2>
<p><strong>syntax:</strong> <em>iterator = tcpsock:receiveuntil(pattern,
options?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>This method returns an iterator Lua function that can be called to
read the data stream until it sees the specified pattern or an error
occurs.</p>
<p>Here is an example for using this method to read a data stream with
the boundary sequence <code>--abcedhb</code>:</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">reader</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>receiveuntil<span class="op">(</span><span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">--abcedhb&quot;</span><span class="op">)</span></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">data</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">partial</span> <span class="op">=</span> reader<span class="op">()</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">data</span> <span class="cf">then</span></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to read the data stream: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;read the data stream: &quot;</span><span class="op">,</span> <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>When called without any argument, the iterator function returns the
received data right <em>before</em> the specified pattern string in the
incoming data stream. So for the example above, if the incoming data
stream is <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>,
then the string <code>'hello, world! -agentzh'</code> will be
returned.</p>
<p>In case of error, the iterator function will return <code>nil</code>
along with a string describing the error and the partial data bytes that
have been read so far.</p>
<p>The iterator function can be called multiple times and can be mixed
safely with other cosocket method calls or other iterator function
calls.</p>
<p>The iterator function behaves differently (i.e., like a real
iterator) when it is called with a <code>size</code> argument. That is,
it will read that <code>size</code> of data on each invocation and will
return <code>nil</code> at the last invocation (either sees the boundary
pattern or meets an error). For the last successful invocation of the
iterator function, the <code>err</code> return value will be
<code>nil</code> too. The iterator function will be reset after the last
successful invocation that returns <code>nil</code> data and
<code>nil</code> error. Consider the following example:</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">reader</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>receiveuntil<span class="op">(</span><span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">--abcedhb&quot;</span><span class="op">)</span></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">while</span> <span class="kw">true</span> <span class="cf">do</span></span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">data</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">partial</span> <span class="op">=</span> reader<span class="op">(</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="kw">not</span> <span class="va">data</span> <span class="cf">then</span></span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="va">err</span> <span class="cf">then</span></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true" tabindex="-1"></a>             <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to read the data stream: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb278-9"><a href="#cb278-9" aria-hidden="true" tabindex="-1"></a>             <span class="cf">break</span></span>
<span id="cb278-10"><a href="#cb278-10" aria-hidden="true" tabindex="-1"></a>         <span class="cf">end</span></span>
<span id="cb278-11"><a href="#cb278-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-12"><a href="#cb278-12" aria-hidden="true" tabindex="-1"></a>         <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;read done&quot;</span><span class="op">)</span></span>
<span id="cb278-13"><a href="#cb278-13" aria-hidden="true" tabindex="-1"></a>         <span class="cf">break</span></span>
<span id="cb278-14"><a href="#cb278-14" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb278-15"><a href="#cb278-15" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;read chunk: [&quot;</span><span class="op">,</span> <span class="va">data</span><span class="op">,</span> <span class="st">&quot;]&quot;</span><span class="op">)</span></span>
<span id="cb278-16"><a href="#cb278-16" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>Then for the incoming data stream
<code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, we shall
get the following output from the sample code above:</p>
<pre><code>read chunk: [hell]
read chunk: [o, w]
read chunk: [orld]
read chunk: [! -a]
read chunk: [gent]
read chunk: [zh]
read done</code></pre>
<p>Note that, the actual data returned <em>might</em> be a little longer
than the size limit specified by the <code>size</code> argument when the
boundary pattern has ambiguity for streaming parsing. Near the boundary
of the data stream, the data string actually returned could also be
shorter than the size limit.</p>
<p>Timeout for the iterator function's reading operation is controlled
by the <a href="#lua_socket_read_timeout">lua_socket_read_timeout</a>
config directive and the <a href="#tcpsocksettimeout">settimeout</a>
method. And the latter takes priority. For example:</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">readline</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span>receiveuntil<span class="op">(</span><span class="st">&quot;</span><span class="sc">\r\n</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a> <span class="va">sock</span><span class="op">:</span>settimeout<span class="op">(</span><span class="dv">1000</span><span class="op">)</span>  <span class="co">-- one second timeout</span></span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a> <span class="va">line</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">partial</span> <span class="op">=</span> readline<span class="op">()</span></span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">line</span> <span class="cf">then</span></span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to read a line: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb280-8"><a href="#cb280-8" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb280-9"><a href="#cb280-9" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb280-10"><a href="#cb280-10" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;successfully read a line: &quot;</span><span class="op">,</span> <span class="va">line</span><span class="op">)</span></span></code></pre></div>
<p>It is important here to call the <a
href="#tcpsocksettimeout">settimeout</a> method <em>before</em> calling
the iterator function (note that the <code>receiveuntil</code> call is
irrelevant here).</p>
<p>As from the <code>v0.5.1</code> release, this method also takes an
optional <code>options</code> table argument to control the behavior.
The following options are supported:</p>
<ul>
<li><code>inclusive</code></li>
</ul>
<p>The <code>inclusive</code> takes a boolean value to control whether
to include the pattern string in the returned data string. Default to
<code>false</code>. For example,</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">reader</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>receiveuntil<span class="op">(</span><span class="st">&quot;_END_&quot;</span><span class="op">,</span> <span class="op">{</span> <span class="va">inclusive</span> <span class="op">=</span> <span class="kw">true</span> <span class="op">})</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">data</span> <span class="op">=</span> reader<span class="op">()</span></span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>Then for the input data stream
<code>"hello world _END_ blah blah blah"</code>, then the example above
will output <code>hello world _END_</code>, including the pattern string
<code>_END_</code> itself.</p>
<p>Since the <code>v0.8.8</code> release, this method no longer
automatically closes the current connection when the read timeout error
happens. For other connection errors, this method always automatically
closes the connection.</p>
<p>This method was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockclose">tcpsock:close</h2>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:close()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Closes the current TCP or stream unix domain socket. It returns the
<code>1</code> in case of success and returns <code>nil</code> with a
string describing the error otherwise.</p>
<p>Note that there is no need to call this method on socket objects that
have invoked the <a href="#tcpsocksetkeepalive">setkeepalive</a> method
because the socket object is already closed (and the current connection
is saved into the built-in connection pool).</p>
<p>Socket objects that have not invoked this method (and associated
connections) will be closed when the socket object is released by the
Lua GC (Garbage Collector) or the current client HTTP request finishes
processing.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksettimeout">tcpsock:settimeout</h2>
<p><strong>syntax:</strong> <em>tcpsock:settimeout(time)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Set the timeout value in milliseconds for subsequent socket
operations (<a href="#tcpsockconnect">connect</a>, <a
href="#tcpsockreceive">receive</a>, and iterators returned from <a
href="#tcpsockreceiveuntil">receiveuntil</a>).</p>
<p>Settings done by this method take priority over those specified via
config directives (i.e. <a
href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a>, <a
href="#lua_socket_send_timeout">lua_socket_send_timeout</a>, and <a
href="#lua_socket_read_timeout">lua_socket_read_timeout</a>).</p>
<p>Note that this method does <em>not</em> affect the <a
href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a>
setting; the <code>timeout</code> argument to the <a
href="#tcpsocksetkeepalive">setkeepalive</a> method should be used for
this purpose instead.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksettimeouts">tcpsock:settimeouts</h2>
<p><strong>syntax:</strong> <em>tcpsock:settimeouts(connect_timeout,
send_timeout, read_timeout)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Respectively sets the connect, send, and read timeout thresholds (in
milliseconds) for subsequent socket operations (<a
href="#tcpsockconnect">connect</a>, <a href="#tcpsocksend">send</a>, <a
href="#tcpsockreceive">receive</a>, and iterators returned from <a
href="#tcpsockreceiveuntil">receiveuntil</a>).</p>
<p>Settings done by this method take priority over those specified via
config directives (i.e. <a
href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a>, <a
href="#lua_socket_send_timeout">lua_socket_send_timeout</a>, and <a
href="#lua_socket_read_timeout">lua_socket_read_timeout</a>).</p>
<p>It is recommended to use <a
href="#tcpsocksettimeouts">settimeouts</a> instead of <a
href="#tcpsocksettimeout">settimeout</a>.</p>
<p>Note that this method does <em>not</em> affect the <a
href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a>
setting; the <code>timeout</code> argument to the <a
href="#tcpsocksetkeepalive">setkeepalive</a> method should be used for
this purpose instead.</p>
<p>This feature was first introduced in the <code>v0.10.7</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksetoption">tcpsock:setoption</h2>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:setoption(option,
value?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>This function is added for <a
href="http://w3.impa.br/~diego/software/luasocket/tcp.html">LuaSocket</a>
API compatibility, its functionality is implemented
<code>v0.10.18</code>.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p>In case of success, it returns <code>true</code>. Otherwise, it
returns nil and a string describing the error.</p>
<p>The <code>option</code> is a string with the option name, and the
value depends on the option being set:</p>
<ul>
<li><p><code>keepalive</code></p>
<p>Setting this option to true enables sending of keep-alive messages on
connection-oriented sockets. Make sure the <code>connect</code> function
had been called before, for example,</p>
<div class="sourceCode" id="cb282"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a><span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>setoption<span class="op">(</span><span class="st">&quot;keepalive&quot;</span><span class="op">,</span> <span class="kw">true</span><span class="op">)</span></span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;setoption keepalive failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
<li><p><code>reuseaddr</code></p>
<p>Enabling this option indicates that the rules used in validating
addresses supplied in a call to bind should allow reuse of local
addresses. Make sure the <code>connect</code> function had been called
before, for example,</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a><span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>setoption<span class="op">(</span><span class="st">&quot;reuseaddr&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb283-4"><a href="#cb283-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;setoption reuseaddr failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb283-5"><a href="#cb283-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
<li><p><code>tcp-nodelay</code></p>
<p>Setting this option to true disables the Nagle's algorithm for the
connection. Make sure the <code>connect</code> function had been called
before, for example,</p>
<div class="sourceCode" id="cb284"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a><span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>setoption<span class="op">(</span><span class="st">&quot;tcp-nodelay&quot;</span><span class="op">,</span> <span class="kw">true</span><span class="op">)</span></span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;setoption tcp-nodelay failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
<li><p><code>sndbuf</code></p>
<p>Sets the maximum socket send buffer in bytes. The kernel doubles this
value (to allow space for bookkeeping overhead) when it is set using
setsockopt(). Make sure the <code>connect</code> function had been
called before, for example,</p>
<div class="sourceCode" id="cb285"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a><span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>setoption<span class="op">(</span><span class="st">&quot;sndbuf&quot;</span><span class="op">,</span> <span class="dv">1024</span> <span class="op">*</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;setoption sndbuf failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
<li><p><code>rcvbuf</code></p>
<p>Sets the maximum socket receive buffer in bytes. The kernel doubles
this value (to allow space for bookkeeping overhead) when it is set
using setsockopt. Make sure the <code>connect</code> function had been
called before, for example,</p>
<div class="sourceCode" id="cb286"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a><span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>setoption<span class="op">(</span><span class="st">&quot;rcvbuf&quot;</span><span class="op">,</span> <span class="dv">1024</span> <span class="op">*</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;setoption rcvbuf failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
</ul>
<p>NOTE: Once the option is set, it will become effective until the
connection is closed. If you know the connection is from the connection
pool and all the in-pool connections already have called the setoption()
method with the desired socket option state, then you can just skip
calling setoption() again to avoid the overhead of repeated calls, for
example,</p>
<div class="sourceCode" id="cb287"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">count</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>getreusedtimes<span class="op">()</span></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">count</span> <span class="cf">then</span></span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;getreusedtimes failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb287-6"><a href="#cb287-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb287-7"><a href="#cb287-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-8"><a href="#cb287-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="va">count</span> <span class="op">==</span> <span class="dv">0</span> <span class="cf">then</span></span>
<span id="cb287-9"><a href="#cb287-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">tcpsock</span><span class="op">:</span>setoption<span class="op">(</span><span class="st">&quot;rcvbuf&quot;</span><span class="op">,</span> <span class="dv">1024</span> <span class="op">*</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb287-10"><a href="#cb287-10" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb287-11"><a href="#cb287-11" aria-hidden="true" tabindex="-1"></a>         <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;setoption rcvbuf failed: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb287-12"><a href="#cb287-12" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span></span>
<span id="cb287-13"><a href="#cb287-13" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb287-14"><a href="#cb287-14" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>These options described above are supported in <code>v0.10.18</code>,
and more options will be implemented in future.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsocksetkeepalive">tcpsock:setkeepalive</h2>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:setkeepalive(timeout?,
size?)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Puts the current socket's connection immediately into the cosocket
built-in connection pool and keep it alive until other <a
href="#tcpsockconnect">connect</a> method calls request it or the
associated maximal idle timeout is expired.</p>
<p>The first optional argument, <code>timeout</code>, can be used to
specify the maximal idle timeout (in milliseconds) for the current
connection. If omitted, the default setting in the <a
href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a>
config directive will be used. If the <code>0</code> value is given,
then the timeout interval is unlimited.</p>
<p>The second optional argument <code>size</code> is considered
deprecated since the <code>v0.10.14</code> release of this module, in
favor of the <code>pool_size</code> option of the <a
href="#tcpsockconnect">connect</a> method. Since the
<code>v0.10.14</code> release, this option will only take effect if the
call to <a href="#tcpsockconnect">connect</a> did not already create a
connection pool. When this option takes effect (no connection pool was
previously created by <a href="#tcpsockconnect">connect</a>), it will
specify the size of the connection pool, and create it. If omitted (and
no pool was previously created), the default size is the value of the <a
href="#lua_socket_pool_size">lua_socket_pool_size</a> directive. The
connection pool holds up to <code>size</code> alive connections ready to
be reused by subsequent calls to <a href="#tcpsockconnect">connect</a>,
but note that there is no upper limit to the total number of opened
connections outside of the pool. When the connection pool would exceed
its size limit, the least recently used (kept-alive) connection already
in the pool will be closed to make room for the current connection. Note
that the cosocket connection pool is per Nginx worker process rather
than per Nginx server instance, so the size limit specified here also
applies to every single Nginx worker process. Also note that the size of
the connection pool cannot be changed once it has been created. If you
need to restrict the total number of opened connections, specify both
the <code>pool_size</code> and <code>backlog</code> option in the call
to <a href="#tcpsockconnect">connect</a>.</p>
<p>In case of success, this method returns <code>1</code>; otherwise, it
returns <code>nil</code> and a string describing the error.</p>
<p>When the system receive buffer for the current connection has unread
data, then this method will return the "connection in dubious state"
error message (as the second return value) because the previous session
has unread data left behind for the next session and the connection is
not safe to be reused.</p>
<p>This method also makes the current cosocket object enter the "closed"
state, so there is no need to manually call the <a
href="#tcpsockclose">close</a> method on it afterwards.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="tcpsockgetreusedtimes">tcpsock:getreusedtimes</h2>
<p><strong>syntax:</strong> <em>count, err =
tcpsock:getreusedtimes()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>This method returns the (successfully) reused times for the current
connection. In case of error, it returns <code>nil</code> and a string
describing the error.</p>
<p>If the current connection does not come from the built-in connection
pool, then this method always returns <code>0</code>, that is, the
connection has never been reused (yet). If the connection comes from the
connection pool, then the return value is always non-zero. So this
method can also be used to determine if the current connection comes
from the pool.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.socket.connect">ngx.socket.connect</h2>
<p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(host,
port)</em></p>
<p><strong>syntax:</strong> <em>tcpsock, err =
ngx.socket.connect("unix:/path/to/unix-domain.socket")</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*</em></p>
<p>This function is a shortcut for combining <a
href="#ngxsockettcp">ngx.socket.tcp()</a> and the <a
href="#tcpsockconnect">connect()</a> method call in a single operation.
It is actually implemented like this:</p>
<div class="sourceCode" id="cb288"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">sock</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">socket</span><span class="op">.</span>tcp<span class="op">()</span></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">sock</span><span class="op">:</span><span class="fu">connect</span><span class="op">(...)</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="kw">nil</span><span class="op">,</span> <span class="va">err</span></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">sock</span></span></code></pre></div>
<p>There is no way to use the <a
href="#tcpsocksettimeout">settimeout</a> method to specify connecting
timeout for this method and the <a
href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a>
directive must be set at configure time instead.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.get_phase">ngx.get_phase</h2>
<p><strong>syntax:</strong> <em>str = ngx.get_phase()</em></p>
<p><strong>context:</strong> <em>init_by_lua*, init_worker_by_lua*,
set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*,
header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*,
balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Retrieves the current running phase name. Possible return values
are</p>
<ul>
<li><code>init</code> for the context of <a
href="#init_by_lua">init_by_lua*</a>.</li>
<li><code>init_worker</code> for the context of <a
href="#init_worker_by_lua">init_worker_by_lua*</a>.</li>
<li><code>ssl_cert</code> for the context of <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua*</a>.</li>
<li><code>ssl_session_fetch</code> for the context of <a
href="#ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua*</a>.</li>
<li><code>ssl_session_store</code> for the context of <a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua*</a>.</li>
<li><code>ssl_client_hello</code> for the context of <a
href="#ssl_client_hello_by_lua_block">ssl_client_hello_by_lua*</a>.</li>
<li><code>set</code> for the context of <a
href="#set_by_lua">set_by_lua*</a>.</li>
<li><code>rewrite</code> for the context of <a
href="#rewrite_by_lua">rewrite_by_lua*</a>.</li>
<li><code>balancer</code> for the context of <a
href="#balancer_by_lua_block">balancer_by_lua*</a>.</li>
<li><code>access</code> for the context of <a
href="#access_by_lua">access_by_lua*</a>.</li>
<li><code>content</code> for the context of <a
href="#content_by_lua">content_by_lua*</a>.</li>
<li><code>header_filter</code> for the context of <a
href="#header_filter_by_lua">header_filter_by_lua*</a>.</li>
<li><code>body_filter</code> for the context of <a
href="#body_filter_by_lua">body_filter_by_lua*</a>.</li>
<li><code>log</code> for the context of <a
href="#log_by_lua">log_by_lua*</a>.</li>
<li><code>timer</code> for the context of user callback functions for <a
href="#ngxtimerat">ngx.timer.*</a>.</li>
<li><code>exit_worker</code> for the context of <a
href="#exit_worker_by_lua">exit_worker_by_lua*</a>.</li>
</ul>
<p>This API was first introduced in the <code>v0.5.10</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.thread.spawn">ngx.thread.spawn</h2>
<p><strong>syntax:</strong> <em>co = ngx.thread.spawn(func, arg1, arg2,
...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Spawns a new user "light thread" with the Lua function
<code>func</code> as well as those optional arguments <code>arg1</code>,
<code>arg2</code>, and etc. Returns a Lua thread (or Lua coroutine)
object represents this "light thread".</p>
<p>"Light threads" are just a special kind of Lua coroutines that are
scheduled by the ngx_lua module.</p>
<p>Before <code>ngx.thread.spawn</code> returns, the <code>func</code>
will be called with those optional arguments until it returns, aborts
with an error, or gets yielded due to I/O operations via the <a
href="#nginx-api-for-lua">Nginx API for Lua</a> (like <a
href="#tcpsockreceive">tcpsock:receive</a>).</p>
<p>After <code>ngx.thread.spawn</code> returns, the newly-created "light
thread" will keep running asynchronously usually at various I/O
events.</p>
<p>All the Lua code chunks running by <a
href="#rewrite_by_lua">rewrite_by_lua</a>, <a
href="#access_by_lua">access_by_lua</a>, and <a
href="#content_by_lua">content_by_lua</a> are in a boilerplate "light
thread" created automatically by ngx_lua. Such boilerplate "light
thread" are also called "entry threads".</p>
<p>By default, the corresponding Nginx handler (e.g., <a
href="#rewrite_by_lua">rewrite_by_lua</a> handler) will not terminate
until</p>
<ol type="1">
<li>both the "entry thread" and all the user "light threads"
terminates,</li>
<li>a "light thread" (either the "entry thread" or a user "light
thread") aborts by calling <a href="#ngxexit">ngx.exit</a>, <a
href="#ngxexec">ngx.exec</a>, <a href="#ngxredirect">ngx.redirect</a>,
or <a href="#ngxreqset_uri">ngx.req.set_uri(uri, true)</a>, or</li>
<li>the "entry thread" terminates with a Lua error.</li>
</ol>
<p>When the user "light thread" terminates with a Lua error, however, it
will not abort other running "light threads" like the "entry thread"
does.</p>
<p>Due to the limitation in the Nginx subrequest model, it is not
allowed to abort a running Nginx subrequest in general. So it is also
prohibited to abort a running "light thread" that is pending on one ore
more Nginx subrequests. You must call <a
href="#ngxthreadwait">ngx.thread.wait</a> to wait for those "light
thread" to terminate before quitting the "world". A notable exception
here is that you can abort pending subrequests by calling <a
href="#ngxexit">ngx.exit</a> with and only with the status code
<code>ngx.ERROR</code> (-1), <code>408</code>, <code>444</code>, or
<code>499</code>.</p>
<p>The "light threads" are not scheduled in a pre-emptive way. In other
words, no time-slicing is performed automatically. A "light thread" will
keep running exclusively on the CPU until</p>
<ol type="1">
<li>a (nonblocking) I/O operation cannot be completed in a single
run,</li>
<li>it calls <a href="#coroutineyield">coroutine.yield</a> to actively
give up execution, or</li>
<li>it is aborted by a Lua error or an invocation of <a
href="#ngxexit">ngx.exit</a>, <a href="#ngxexec">ngx.exec</a>, <a
href="#ngxredirect">ngx.redirect</a>, or <a
href="#ngxreqset_uri">ngx.req.set_uri(uri, true)</a>.</li>
</ol>
<p>For the first two cases, the "light thread" will usually be resumed
later by the ngx_lua scheduler unless a "stop-the-world" event
happens.</p>
<p>User "light threads" can create "light threads" themselves. And
normal user coroutines created by <a
href="#coroutinecreate">coroutine.create</a> can also create "light
threads". The coroutine (be it a normal Lua coroutine or a "light
thread") that directly spawns the "light thread" is called the "parent
coroutine" for the "light thread" newly spawned.</p>
<p>The "parent coroutine" can call <a
href="#ngxthreadwait">ngx.thread.wait</a> to wait on the termination of
its child "light thread".</p>
<p>You can call coroutine.status() and coroutine.yield() on the "light
thread" coroutines.</p>
<p>The status of the "light thread" coroutine can be "zombie" if</p>
<ol type="1">
<li>the current "light thread" already terminates (either successfully
or with an error),</li>
<li>its parent coroutine is still alive, and</li>
<li>its parent coroutine is not waiting on it with <a
href="#ngxthreadwait">ngx.thread.wait</a>.</li>
</ol>
<p>The following example demonstrates the use of coroutine.yield() in
the "light thread" coroutines to do manual time-slicing:</p>
<div class="sourceCode" id="cb289"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">yield</span> <span class="op">=</span> <span class="fu">coroutine.yield</span></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">function</span> f<span class="op">()</span></span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">self</span> <span class="op">=</span> <span class="fu">coroutine.running</span><span class="op">()</span></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;f 1&quot;</span><span class="op">)</span></span>
<span id="cb289-7"><a href="#cb289-7" aria-hidden="true" tabindex="-1"></a>     yield<span class="op">(</span><span class="va">self</span><span class="op">)</span></span>
<span id="cb289-8"><a href="#cb289-8" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;f 2&quot;</span><span class="op">)</span></span>
<span id="cb289-9"><a href="#cb289-9" aria-hidden="true" tabindex="-1"></a>     yield<span class="op">(</span><span class="va">self</span><span class="op">)</span></span>
<span id="cb289-10"><a href="#cb289-10" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;f 3&quot;</span><span class="op">)</span></span>
<span id="cb289-11"><a href="#cb289-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb289-12"><a href="#cb289-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-13"><a href="#cb289-13" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">self</span> <span class="op">=</span> <span class="fu">coroutine.running</span><span class="op">()</span></span>
<span id="cb289-14"><a href="#cb289-14" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;0&quot;</span><span class="op">)</span></span>
<span id="cb289-15"><a href="#cb289-15" aria-hidden="true" tabindex="-1"></a> yield<span class="op">(</span><span class="va">self</span><span class="op">)</span></span>
<span id="cb289-16"><a href="#cb289-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-17"><a href="#cb289-17" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;1&quot;</span><span class="op">)</span></span>
<span id="cb289-18"><a href="#cb289-18" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>spawn<span class="op">(</span><span class="va">f</span><span class="op">)</span></span>
<span id="cb289-19"><a href="#cb289-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-20"><a href="#cb289-20" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;2&quot;</span><span class="op">)</span></span>
<span id="cb289-21"><a href="#cb289-21" aria-hidden="true" tabindex="-1"></a> yield<span class="op">(</span><span class="va">self</span><span class="op">)</span></span>
<span id="cb289-22"><a href="#cb289-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-23"><a href="#cb289-23" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;3&quot;</span><span class="op">)</span></span>
<span id="cb289-24"><a href="#cb289-24" aria-hidden="true" tabindex="-1"></a> yield<span class="op">(</span><span class="va">self</span><span class="op">)</span></span>
<span id="cb289-25"><a href="#cb289-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-26"><a href="#cb289-26" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;4&quot;</span><span class="op">)</span></span></code></pre></div>
<p>Then it will generate the output</p>
<pre><code>0
1
f 1
2
f 2
3
f 3
4</code></pre>
<p>"Light threads" are mostly useful for making concurrent upstream
requests in a single Nginx request handler, much like a generalized
version of <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a> that can
work with all the <a href="#nginx-api-for-lua">Nginx API for Lua</a>.
The following example demonstrates parallel requests to MySQL,
Memcached, and upstream HTTP services in a single Lua handler, and
outputting the results in the order that they actually return (similar
to Facebook's BigPipe model):</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a> <span class="co">-- query mysql, memcached, and a remote http service at the same time,</span></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- output the results in the order that they</span></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a> <span class="co">-- actually return the results.</span></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">mysql</span> <span class="op">=</span> <span class="fu">require</span> <span class="st">&quot;resty.mysql&quot;</span></span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">memcached</span> <span class="op">=</span> <span class="fu">require</span> <span class="st">&quot;resty.memcached&quot;</span></span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="kw">function</span> query_mysql<span class="op">()</span></span>
<span id="cb291-10"><a href="#cb291-10" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">db</span> <span class="op">=</span> <span class="va">mysql</span><span class="op">:</span>new<span class="op">()</span></span>
<span id="cb291-11"><a href="#cb291-11" aria-hidden="true" tabindex="-1"></a>     <span class="va">db</span><span class="op">:</span><span class="fu">connect</span><span class="op">{</span></span>
<span id="cb291-12"><a href="#cb291-12" aria-hidden="true" tabindex="-1"></a>                 <span class="va">host</span> <span class="op">=</span> <span class="st">&quot;127.0.0.1&quot;</span><span class="op">,</span></span>
<span id="cb291-13"><a href="#cb291-13" aria-hidden="true" tabindex="-1"></a>                 <span class="va">port</span> <span class="op">=</span> <span class="dv">3306</span><span class="op">,</span></span>
<span id="cb291-14"><a href="#cb291-14" aria-hidden="true" tabindex="-1"></a>                 <span class="va">database</span> <span class="op">=</span> <span class="st">&quot;test&quot;</span><span class="op">,</span></span>
<span id="cb291-15"><a href="#cb291-15" aria-hidden="true" tabindex="-1"></a>                 <span class="va">user</span> <span class="op">=</span> <span class="st">&quot;monty&quot;</span><span class="op">,</span></span>
<span id="cb291-16"><a href="#cb291-16" aria-hidden="true" tabindex="-1"></a>                 <span class="va">password</span> <span class="op">=</span> <span class="st">&quot;mypass&quot;</span></span>
<span id="cb291-17"><a href="#cb291-17" aria-hidden="true" tabindex="-1"></a>               <span class="op">}</span></span>
<span id="cb291-18"><a href="#cb291-18" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">res</span><span class="op">,</span> <span class="va">err</span><span class="op">,</span> <span class="va">errno</span><span class="op">,</span> <span class="va">sqlstate</span> <span class="op">=</span></span>
<span id="cb291-19"><a href="#cb291-19" aria-hidden="true" tabindex="-1"></a>             <span class="va">db</span><span class="op">:</span>query<span class="op">(</span><span class="st">&quot;select * from cats order by id asc&quot;</span><span class="op">)</span></span>
<span id="cb291-20"><a href="#cb291-20" aria-hidden="true" tabindex="-1"></a>     <span class="va">db</span><span class="op">:</span>set_keepalive<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">100</span><span class="op">)</span></span>
<span id="cb291-21"><a href="#cb291-21" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;mysql done: &quot;</span><span class="op">,</span> <span class="va">cjson</span><span class="op">.</span>encode<span class="op">(</span><span class="va">res</span><span class="op">))</span></span>
<span id="cb291-22"><a href="#cb291-22" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb291-23"><a href="#cb291-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-24"><a href="#cb291-24" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="kw">function</span> query_memcached<span class="op">()</span></span>
<span id="cb291-25"><a href="#cb291-25" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">memc</span> <span class="op">=</span> <span class="va">memcached</span><span class="op">:</span>new<span class="op">()</span></span>
<span id="cb291-26"><a href="#cb291-26" aria-hidden="true" tabindex="-1"></a>     <span class="va">memc</span><span class="op">:</span><span class="fu">connect</span><span class="op">(</span><span class="st">&quot;127.0.0.1&quot;</span><span class="op">,</span> <span class="dv">11211</span><span class="op">)</span></span>
<span id="cb291-27"><a href="#cb291-27" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">res</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">memc</span><span class="op">:</span>get<span class="op">(</span><span class="st">&quot;some_key&quot;</span><span class="op">)</span></span>
<span id="cb291-28"><a href="#cb291-28" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;memcached done: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">)</span></span>
<span id="cb291-29"><a href="#cb291-29" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb291-30"><a href="#cb291-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-31"><a href="#cb291-31" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="kw">function</span> query_http<span class="op">()</span></span>
<span id="cb291-32"><a href="#cb291-32" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">res</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span>capture<span class="op">(</span><span class="st">&quot;/my-http-proxy&quot;</span><span class="op">)</span></span>
<span id="cb291-33"><a href="#cb291-33" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;http done: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">.</span><span class="va">body</span><span class="op">)</span></span>
<span id="cb291-34"><a href="#cb291-34" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb291-35"><a href="#cb291-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-36"><a href="#cb291-36" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>spawn<span class="op">(</span><span class="va">query_mysql</span><span class="op">)</span>      <span class="co">-- create thread 1</span></span>
<span id="cb291-37"><a href="#cb291-37" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>spawn<span class="op">(</span><span class="va">query_memcached</span><span class="op">)</span>  <span class="co">-- create thread 2</span></span>
<span id="cb291-38"><a href="#cb291-38" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>spawn<span class="op">(</span><span class="va">query_http</span><span class="op">)</span>       <span class="co">-- create thread 3</span></span></code></pre></div>
<p>This API was first enabled in the <code>v0.7.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.thread.wait">ngx.thread.wait</h2>
<p><strong>syntax:</strong> <em>ok, res1, res2, ... =
ngx.thread.wait(thread1, thread2, ...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Waits on one or more child "light threads" and returns the results of
the first "light thread" that terminates (either successfully or with an
error).</p>
<p>The arguments <code>thread1</code>, <code>thread2</code>, and etc are
the Lua thread objects returned by earlier calls of <a
href="#ngxthreadspawn">ngx.thread.spawn</a>.</p>
<p>The return values have exactly the same meaning as <a
href="#coroutineresume">coroutine.resume</a>, that is, the first value
returned is a boolean value indicating whether the "light thread"
terminates successfully or not, and subsequent values returned are the
return values of the user Lua function that was used to spawn the "light
thread" (in case of success) or the error object (in case of
failure).</p>
<p>Only the direct "parent coroutine" can wait on its child "light
thread", otherwise a Lua exception will be raised.</p>
<p>The following example demonstrates the use of
<code>ngx.thread.wait</code> and <a
href="#ngxlocationcapture">ngx.location.capture</a> to emulate <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>:</p>
<div class="sourceCode" id="cb292"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">capture</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">location</span><span class="op">.</span><span class="va">capture</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">spawn</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span><span class="va">spawn</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">wait</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span><span class="va">wait</span></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">say</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">say</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="kw">function</span> <span class="fu">fetch</span><span class="op">(</span><span class="va">uri</span><span class="op">)</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> capture<span class="op">(</span><span class="va">uri</span><span class="op">)</span></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">threads</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a>     spawn<span class="op">(</span><span class="fu">fetch</span><span class="op">,</span> <span class="st">&quot;/foo&quot;</span><span class="op">),</span></span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a>     spawn<span class="op">(</span><span class="fu">fetch</span><span class="op">,</span> <span class="st">&quot;/bar&quot;</span><span class="op">),</span></span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a>     spawn<span class="op">(</span><span class="fu">fetch</span><span class="op">,</span> <span class="st">&quot;/baz&quot;</span><span class="op">)</span></span>
<span id="cb292-15"><a href="#cb292-15" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span>
<span id="cb292-16"><a href="#cb292-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-17"><a href="#cb292-17" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> <span class="va">i</span> <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="op">#</span><span class="va">threads</span> <span class="cf">do</span></span>
<span id="cb292-18"><a href="#cb292-18" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">res</span> <span class="op">=</span> wait<span class="op">(</span><span class="va">threads</span><span class="op">[</span><span class="va">i</span><span class="op">])</span></span>
<span id="cb292-19"><a href="#cb292-19" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb292-20"><a href="#cb292-20" aria-hidden="true" tabindex="-1"></a>         say<span class="op">(</span><span class="va">i</span><span class="op">,</span> <span class="st">&quot;: failed to run: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">)</span></span>
<span id="cb292-21"><a href="#cb292-21" aria-hidden="true" tabindex="-1"></a>     <span class="cf">else</span></span>
<span id="cb292-22"><a href="#cb292-22" aria-hidden="true" tabindex="-1"></a>         say<span class="op">(</span><span class="va">i</span><span class="op">,</span> <span class="st">&quot;: status: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">.</span><span class="va">status</span><span class="op">)</span></span>
<span id="cb292-23"><a href="#cb292-23" aria-hidden="true" tabindex="-1"></a>         say<span class="op">(</span><span class="va">i</span><span class="op">,</span> <span class="st">&quot;: body: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">.</span><span class="va">body</span><span class="op">)</span></span>
<span id="cb292-24"><a href="#cb292-24" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb292-25"><a href="#cb292-25" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>Here it essentially implements the "wait all" model.</p>
<p>And below is an example demonstrating the "wait any" model:</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">function</span> f<span class="op">()</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>sleep<span class="op">(</span><span class="dv">0.2</span><span class="op">)</span></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;f: hello&quot;</span><span class="op">)</span></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="st">&quot;f done&quot;</span></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">function</span> g<span class="op">()</span></span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>sleep<span class="op">(</span><span class="dv">0.1</span><span class="op">)</span></span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;g: hello&quot;</span><span class="op">)</span></span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="st">&quot;g done&quot;</span></span>
<span id="cb293-12"><a href="#cb293-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb293-13"><a href="#cb293-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-14"><a href="#cb293-14" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">tf</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>spawn<span class="op">(</span><span class="va">f</span><span class="op">)</span></span>
<span id="cb293-15"><a href="#cb293-15" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">tf</span> <span class="cf">then</span></span>
<span id="cb293-16"><a href="#cb293-16" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to spawn thread f: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb293-17"><a href="#cb293-17" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb293-18"><a href="#cb293-18" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb293-19"><a href="#cb293-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-20"><a href="#cb293-20" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;f thread created: &quot;</span><span class="op">,</span> <span class="fu">coroutine.status</span><span class="op">(</span><span class="va">tf</span><span class="op">))</span></span>
<span id="cb293-21"><a href="#cb293-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-22"><a href="#cb293-22" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">tg</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>spawn<span class="op">(</span><span class="va">g</span><span class="op">)</span></span>
<span id="cb293-23"><a href="#cb293-23" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">tg</span> <span class="cf">then</span></span>
<span id="cb293-24"><a href="#cb293-24" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to spawn thread g: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb293-25"><a href="#cb293-25" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb293-26"><a href="#cb293-26" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb293-27"><a href="#cb293-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-28"><a href="#cb293-28" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;g thread created: &quot;</span><span class="op">,</span> <span class="fu">coroutine.status</span><span class="op">(</span><span class="va">tg</span><span class="op">))</span></span>
<span id="cb293-29"><a href="#cb293-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-30"><a href="#cb293-30" aria-hidden="true" tabindex="-1"></a> <span class="va">ok</span><span class="op">,</span> <span class="va">res</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">thread</span><span class="op">.</span>wait<span class="op">(</span><span class="va">tf</span><span class="op">,</span> <span class="va">tg</span><span class="op">)</span></span>
<span id="cb293-31"><a href="#cb293-31" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb293-32"><a href="#cb293-32" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;failed to wait: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">)</span></span>
<span id="cb293-33"><a href="#cb293-33" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb293-34"><a href="#cb293-34" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb293-35"><a href="#cb293-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-36"><a href="#cb293-36" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>say<span class="op">(</span><span class="st">&quot;res: &quot;</span><span class="op">,</span> <span class="va">res</span><span class="op">)</span></span>
<span id="cb293-37"><a href="#cb293-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-38"><a href="#cb293-38" aria-hidden="true" tabindex="-1"></a> <span class="co">-- stop the &quot;world&quot;, aborting other running threads</span></span>
<span id="cb293-39"><a href="#cb293-39" aria-hidden="true" tabindex="-1"></a> <span class="va">ngx</span><span class="op">.</span>exit<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">OK</span><span class="op">)</span></span></code></pre></div>
<p>And it will generate the following output:</p>
<pre><code>f thread created: running
g thread created: running
g: hello
res: g done</code></pre>
<p>This API was first enabled in the <code>v0.7.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.thread.kill">ngx.thread.kill</h2>
<p><strong>syntax:</strong> <em>ok, err =
ngx.thread.kill(thread)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*,
ssl_session_fetch_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Kills a running "light thread" created by <a
href="#ngxthreadspawn">ngx.thread.spawn</a>. Returns a true value when
successful or <code>nil</code> and a string describing the error
otherwise.</p>
<p>According to the current implementation, only the parent coroutine
(or "light thread") can kill a thread. Also, a running "light thread"
with pending Nginx subrequests (initiated by <a
href="#ngxlocationcapture">ngx.location.capture</a> for example) cannot
be killed due to a limitation in the Nginx core.</p>
<p>This API was first enabled in the <code>v0.9.9</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.on_abort">ngx.on_abort</h2>
<p><strong>syntax:</strong> <em>ok, err =
ngx.on_abort(callback)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p>Registers a user Lua function as the callback which gets called
automatically when the client closes the (downstream) connection
prematurely.</p>
<p>Returns <code>1</code> if the callback is registered successfully or
returns <code>nil</code> and a string describing the error
otherwise.</p>
<p>All the <a href="#nginx-api-for-lua">Nginx API for Lua</a> can be
used in the callback function because the function is run in a special
"light thread", just as those "light threads" created by <a
href="#ngxthreadspawn">ngx.thread.spawn</a>.</p>
<p>The callback function can decide what to do with the client abortion
event all by itself. For example, it can simply ignore the event by
doing nothing and the current Lua request handler will continue
executing without interruptions. And the callback function can also
decide to terminate everything by calling <a
href="#ngxexit">ngx.exit</a>, for example,</p>
<div class="sourceCode" id="cb295"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="kw">function</span> my_cleanup<span class="op">()</span></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- custom cleanup work goes here, like cancelling a pending DB transaction</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- now abort all the &quot;light threads&quot; running in the current request handler</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>exit<span class="op">(</span><span class="dv">499</span><span class="op">)</span></span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-9"><a href="#cb295-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span>on_abort<span class="op">(</span><span class="va">my_cleanup</span><span class="op">)</span></span>
<span id="cb295-10"><a href="#cb295-10" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb295-11"><a href="#cb295-11" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;failed to register the on_abort callback: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb295-12"><a href="#cb295-12" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>exit<span class="op">(</span><span class="dv">500</span><span class="op">)</span></span>
<span id="cb295-13"><a href="#cb295-13" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span></code></pre></div>
<p>When <a href="#lua_check_client_abort">lua_check_client_abort</a> is
set to <code>off</code> (which is the default), then this function call
will always return the error message "lua_check_client_abort is
off".</p>
<p>According to the current implementation, this function can only be
called once in a single request handler; subsequent calls will return
the error message "duplicate call".</p>
<p>This API was first introduced in the <code>v0.7.4</code> release.</p>
<p>See also <a
href="#lua_check_client_abort">lua_check_client_abort</a>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.timer.at">ngx.timer.at</h2>
<p><strong>syntax:</strong> <em>hdl, err = ngx.timer.at(delay, callback,
user_arg1, user_arg2, ...)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Creates an Nginx timer with a user callback function as well as
optional user arguments.</p>
<p>The first argument, <code>delay</code>, specifies the delay for the
timer, in seconds. One can specify fractional seconds like
<code>0.001</code> to mean 1 millisecond here. <code>0</code> delay can
also be specified, in which case the timer will immediately expire when
the current handler yields execution.</p>
<p>The second argument, <code>callback</code>, can be any Lua function,
which will be invoked later in a background "light thread" after the
delay specified. The user callback will be called automatically by the
Nginx core with the arguments <code>premature</code>,
<code>user_arg1</code>, <code>user_arg2</code>, and etc, where the
<code>premature</code> argument takes a boolean value indicating whether
it is a premature timer expiration or not(for the <code>0</code> delay
timer it is always <code>false</code>), and <code>user_arg1</code>,
<code>user_arg2</code>, and etc, are those (extra) user arguments
specified when calling <code>ngx.timer.at</code> as the remaining
arguments.</p>
<p>Premature timer expiration happens when the Nginx worker process is
trying to shut down, as in an Nginx configuration reload triggered by
the <code>HUP</code> signal or in an Nginx server shutdown. When the
Nginx worker is trying to shut down, one can no longer call
<code>ngx.timer.at</code> to create new timers with nonzero delays and
in that case <code>ngx.timer.at</code> will return a "conditional false"
value and a string describing the error, that is, "process exiting".</p>
<p>Starting from the <code>v0.9.3</code> release, it is allowed to
create zero-delay timers even when the Nginx worker process starts
shutting down.</p>
<p>When a timer expires, the user Lua code in the timer callback is
running in a "light thread" detached completely from the original
request creating the timer. So objects with the same lifetime as the
request creating them, like <a href="#ngxsockettcp">cosockets</a>,
cannot be shared between the original request and the timer user
callback function.</p>
<p>Here is a simple example:</p>
<pre class="nginx"><code>
 location / {
     ...
     log_by_lua_block {
         local function push_data(premature, uri, args, status)
             -- push the data uri, args, and status to the remote
             -- via ngx.socket.tcp or ngx.socket.udp
             -- (one may want to buffer the data in Lua a bit to
             -- save I/O operations)
         end
         local ok, err = ngx.timer.at(0, push_data,
                                      ngx.var.uri, ngx.var.args, ngx.header.status)
         if not ok then
             ngx.log(ngx.ERR, &quot;failed to create timer: &quot;, err)
             return
         end

         -- other job in log_by_lua_block
     }
 }</code></pre>
<p>One can also create infinite re-occurring timers, for instance, a
timer getting triggered every <code>5</code> seconds, by calling
<code>ngx.timer.at</code> recursively in the timer callback function.
Here is such an example,</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">delay</span> <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">handler</span></span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a> <span class="va">handler</span> <span class="op">=</span> <span class="kw">function</span> <span class="op">(</span><span class="va">premature</span><span class="op">)</span></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- do some routine job in Lua just like a cron job</span></span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="va">premature</span> <span class="cf">then</span></span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span></span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">timer</span><span class="op">.</span>at<span class="op">(</span><span class="va">delay</span><span class="op">,</span> <span class="va">handler</span><span class="op">)</span></span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true" tabindex="-1"></a>         <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;failed to create the timer: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb297-12"><a href="#cb297-12" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span></span>
<span id="cb297-13"><a href="#cb297-13" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb297-14"><a href="#cb297-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-15"><a href="#cb297-15" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- do something in timer</span></span>
<span id="cb297-16"><a href="#cb297-16" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb297-17"><a href="#cb297-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-18"><a href="#cb297-18" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">ok</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="va">ngx</span><span class="op">.</span><span class="va">timer</span><span class="op">.</span>at<span class="op">(</span><span class="va">delay</span><span class="op">,</span> <span class="va">handler</span><span class="op">)</span></span>
<span id="cb297-19"><a href="#cb297-19" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="kw">not</span> <span class="va">ok</span> <span class="cf">then</span></span>
<span id="cb297-20"><a href="#cb297-20" aria-hidden="true" tabindex="-1"></a>     <span class="va">ngx</span><span class="op">.</span>log<span class="op">(</span><span class="va">ngx</span><span class="op">.</span><span class="cn">ERR</span><span class="op">,</span> <span class="st">&quot;failed to create the timer: &quot;</span><span class="op">,</span> <span class="va">err</span><span class="op">)</span></span>
<span id="cb297-21"><a href="#cb297-21" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span></span>
<span id="cb297-22"><a href="#cb297-22" aria-hidden="true" tabindex="-1"></a> <span class="cf">end</span></span>
<span id="cb297-23"><a href="#cb297-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-24"><a href="#cb297-24" aria-hidden="true" tabindex="-1"></a> <span class="co">-- do other jobs</span></span></code></pre></div>
<p>It is recommended, however, to use the <a
href="#ngxtimerevery">ngx.timer.every</a> API function instead for
creating recurring timers since it is more robust.</p>
<p>Because timer callbacks run in the background and their running time
will not add to any client request's response time, they can easily
accumulate in the server and exhaust system resources due to either Lua
programming mistakes or just too much client traffic. To prevent extreme
consequences like crashing the Nginx server, there are built-in
limitations on both the number of "pending timers" and the number of
"running timers" in an Nginx worker process. The "pending timers" here
mean timers that have not yet been expired and "running timers" are
those whose user callbacks are currently running.</p>
<p>The maximal number of pending timers allowed in an Nginx worker is
controlled by the <a
href="#lua_max_pending_timers">lua_max_pending_timers</a> directive. The
maximal number of running timers is controlled by the <a
href="#lua_max_running_timers">lua_max_running_timers</a> directive.</p>
<p>According to the current implementation, each "running timer" will
take one (fake) connection record from the global connection record list
configured by the standard <a
href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections">worker_connections</a>
directive in <code>nginx.conf</code>. So ensure that the <a
href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections">worker_connections</a>
directive is set to a large enough value that takes into account both
the real connections and fake connections required by timer callbacks
(as limited by the <a
href="#lua_max_running_timers">lua_max_running_timers</a>
directive).</p>
<p>A lot of the Lua APIs for Nginx are enabled in the context of the
timer callbacks, like stream/datagram cosockets (<a
href="#ngxsockettcp">ngx.socket.tcp</a> and <a
href="#ngxsocketudp">ngx.socket.udp</a>), shared memory dictionaries (<a
href="#ngxshareddict">ngx.shared.DICT</a>), user coroutines (<a
href="#coroutinecreate">coroutine.*</a>), user "light threads" (<a
href="#ngxthreadspawn">ngx.thread.*</a>), <a
href="#ngxexit">ngx.exit</a>, <a href="#ngxnow">ngx.now</a>/<a
href="#ngxtime">ngx.time</a>, <a href="#ngxmd5">ngx.md5</a>/<a
href="#ngxsha1_bin">ngx.sha1_bin</a>, are all allowed. But the
subrequest API (like <a
href="#ngxlocationcapture">ngx.location.capture</a>), the <a
href="#ngxreqstart_time">ngx.req.*</a> API, the downstream output API
(like <a href="#ngxsay">ngx.say</a>, <a href="#ngxprint">ngx.print</a>,
and <a href="#ngxflush">ngx.flush</a>) are explicitly disabled in this
context.</p>
<p>You must notice that each timer will be based on a fake request (this
fake request is also based on a fake connection). Because Nginx's memory
release is based on the connection closure, if you run a lot of APIs
that apply for memory resources in a timer, such as <a
href="#tcpsockconnect">tcpsock:connect</a>, will cause the accumulation
of memory resources. So it is recommended to create a new timer after
running several times to release memory resources.</p>
<p>You can pass most of the standard Lua values (nils, booleans,
numbers, strings, tables, closures, file handles, etc.) into the timer
callback, either explicitly as user arguments or implicitly as upvalues
for the callback closure. There are several exceptions, however: you
<em>cannot</em> pass any thread objects returned by <a
href="#coroutinecreate">coroutine.create</a> and <a
href="#ngxthreadspawn">ngx.thread.spawn</a> or any cosocket objects
returned by <a href="#ngxsockettcp">ngx.socket.tcp</a>, <a
href="#ngxsocketudp">ngx.socket.udp</a>, and <a
href="#ngxreqsocket">ngx.req.socket</a> because these objects' lifetime
is bound to the request context creating them while the timer callback
is detached from the creating request's context (by design) and runs in
its own (fake) request context. If you try to share the thread or
cosocket objects across the boundary of the creating request, then you
will get the "no co ctx found" error (for threads) or "bad request" (for
cosockets). It is fine, however, to create all these objects inside your
timer callback.</p>
<p>Please note that the timer Lua handler has its own copy of the
<code>ngx.ctx</code> magic table. It won't share the same
<code>ngx.ctx</code> with the Lua handler creating the timer. If you
need to pass data from the timer creator to the timer handler, please
use the extra parameters of <code>ngx.timer.at()</code>.</p>
<p>This API was first introduced in the <code>v0.8.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.timer.every">ngx.timer.every</h2>
<p><strong>syntax:</strong> <em>hdl, err = ngx.timer.every(delay,
callback, user_arg1, user_arg2, ...)</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Similar to the <a href="#ngxtimerat">ngx.timer.at</a> API function,
but</p>
<ol type="1">
<li><code>delay</code> <em>cannot</em> be zero,</li>
<li>timer will be created every <code>delay</code> seconds until the
current Nginx worker process starts exiting.</li>
</ol>
<p>Like <a href="#ngxtimerat">ngx.timer.at</a>, the
<code>callback</code> argument will be called automatically with the
arguments <code>premature</code>, <code>user_arg1</code>,
<code>user_arg2</code>, etc.</p>
<p>When success, returns a "conditional true" value (but not a
<code>true</code>). Otherwise, returns a "conditional false" value and a
string describing the error.</p>
<p>This API also respect the <a
href="#lua_max_pending_timers">lua_max_pending_timers</a> and <a
href="#lua_max_running_timers">lua_max_running_timers</a>.</p>
<p>This API was first introduced in the <code>v0.10.9</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.timer.running_count">ngx.timer.running_count</h2>
<p><strong>syntax:</strong> <em>count =
ngx.timer.running_count()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns the number of timers currently running.</p>
<p>This directive was first introduced in the <code>v0.9.20</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.timer.pending_count">ngx.timer.pending_count</h2>
<p><strong>syntax:</strong> <em>count =
ngx.timer.pending_count()</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>Returns the number of pending timers.</p>
<p>This directive was first introduced in the <code>v0.9.20</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.config.subsystem">ngx.config.subsystem</h2>
<p><strong>syntax:</strong> <em>subsystem =
ngx.config.subsystem</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>This string field indicates the Nginx subsystem the current Lua
environment is based on. For this module, this field always takes the
string value <code>"http"</code>. For <a
href="https://github.com/openresty/stream-lua-nginx-module#readme">ngx_stream_lua_module</a>,
however, this field takes the value <code>"stream"</code>.</p>
<p>This field was first introduced in the <code>0.10.1</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.config.debug">ngx.config.debug</h2>
<p><strong>syntax:</strong> <em>debug = ngx.config.debug</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>This boolean field indicates whether the current Nginx is a debug
build, i.e., being built by the <code>./configure</code> option
<code>--with-debug</code>.</p>
<p>This field was first introduced in the <code>0.8.7</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.config.prefix">ngx.config.prefix</h2>
<p><strong>syntax:</strong> <em>prefix = ngx.config.prefix()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>Returns the Nginx server "prefix" path, as determined by the
<code>-p</code> command-line option when running the Nginx executable,
or the path specified by the <code>--prefix</code> command-line option
when building Nginx with the <code>./configure</code> script.</p>
<p>This function was first introduced in the <code>0.9.2</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.config.nginx_version">ngx.config.nginx_version</h2>
<p><strong>syntax:</strong> <em>ver = ngx.config.nginx_version</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>This field take an integral value indicating the version number of
the current Nginx core being used. For example, the version number
<code>1.4.3</code> results in the Lua number 1004003.</p>
<p>This API was first introduced in the <code>0.9.3</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.config.nginx_configure">ngx.config.nginx_configure</h2>
<p><strong>syntax:</strong> <em>str =
ngx.config.nginx_configure()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</em></p>
<p>This function returns a string for the Nginx <code>./configure</code>
command's arguments string.</p>
<p>This API was first introduced in the <code>0.9.5</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.config.ngx_lua_version">ngx.config.ngx_lua_version</h2>
<p><strong>syntax:</strong> <em>ver =
ngx.config.ngx_lua_version</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</em></p>
<p>This field take an integral value indicating the version number of
the current <code>ngx_lua</code> module being used. For example, the
version number <code>0.9.3</code> results in the Lua number 9003.</p>
<p>This API was first introduced in the <code>0.9.3</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.worker.exiting">ngx.worker.exiting</h2>
<p><strong>syntax:</strong> <em>exiting = ngx.worker.exiting()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>This function returns a boolean value indicating whether the current
Nginx worker process already starts exiting. Nginx worker process
exiting happens on Nginx server quit or configuration reload (aka HUP
reload).</p>
<p>This API was first introduced in the <code>0.9.3</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.worker.pid">ngx.worker.pid</h2>
<p><strong>syntax:</strong> <em>pid = ngx.worker.pid()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>This function returns a Lua number for the process ID (PID) of the
current Nginx worker process. This API is more efficient than
<code>ngx.var.pid</code> and can be used in contexts where the <a
href="#ngxvarvariable">ngx.var.VARIABLE</a> API cannot be used (like <a
href="#init_worker_by_lua">init_worker_by_lua</a>).</p>
<p>This API was first introduced in the <code>0.9.5</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.worker.pids">ngx.worker.pids</h2>
<p><strong>syntax:</strong> <em>pids = ngx.worker.pids()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*,
exit_worker_by_lua*</em></p>
<p>This function returns a Lua table for all Nginx worker process IDs
(PIDs). Nginx uses channel to send the current worker PID to another
worker in the worker process start or restart. So this API can get all
current worker PIDs. Windows does not have this API.</p>
<p>This API was first introduced in the <code>0.10.23</code>
release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.worker.count">ngx.worker.count</h2>
<p><strong>syntax:</strong> <em>count = ngx.worker.count()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*,
init_worker_by_lua*, exit_worker_by_lua*</em></p>
<p>Returns the total number of the Nginx worker processes (i.e., the
value configured by the <a
href="https://nginx.org/en/docs/ngx_core_module.html#worker_processes">worker_processes</a>
directive in <code>nginx.conf</code>).</p>
<p>This API was first introduced in the <code>0.9.20</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.worker.id">ngx.worker.id</h2>
<p><strong>syntax:</strong> <em>id = ngx.worker.id()</em></p>
<p><strong>context:</strong> <em>set_by_lua*, rewrite_by_lua*,
access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua*,
exit_worker_by_lua*</em></p>
<p>Returns the ordinal number of the current Nginx worker processes
(starting from number 0).</p>
<p>So if the total number of workers is <code>N</code>, then this method
may return a number between 0 and <code>N - 1</code> (inclusive).</p>
<p>This function returns meaningful values only for Nginx 1.9.1+. With
earlier versions of Nginx, it always returns <code>nil</code>.</p>
<p>See also <a href="#ngxworkercount">ngx.worker.count</a>.</p>
<p>This API was first introduced in the <code>0.9.20</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.semaphore">ngx.semaphore</h2>
<p><strong>syntax:</strong> <em>local semaphore = require
"ngx.semaphore"</em></p>
<p>This is a Lua module that implements a classic-style semaphore API
for efficient synchronizations among different "light threads". Sharing
the same semaphore among different "light threads" created in different
(request) contexts are also supported as long as the "light threads"
reside in the same Nginx worker process and the <a
href="#lua_code_cache">lua_code_cache</a> directive is turned on (which
is the default).</p>
<p>This Lua module does not ship with this ngx_lua module itself rather
it is shipped with the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>Please refer to the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md">documentation</a>
for this <code>ngx.semaphore</code> Lua module in <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
for more details.</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.balancer">ngx.balancer</h2>
<p><strong>syntax:</strong> <em>local balancer = require
"ngx.balancer"</em></p>
<p>This is a Lua module that provides a Lua API to allow defining
completely dynamic load balancers in pure Lua.</p>
<p>This Lua module does not ship with this ngx_lua module itself rather
it is shipped with the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>Please refer to the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md">documentation</a>
for this <code>ngx.balancer</code> Lua module in <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
for more details.</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.ssl">ngx.ssl</h2>
<p><strong>syntax:</strong> <em>local ssl = require "ngx.ssl"</em></p>
<p>This Lua module provides API functions to control the SSL handshake
process in contexts like <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua*</a>.</p>
<p>This Lua module does not ship with this ngx_lua module itself rather
it is shipped with the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>Please refer to the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md">documentation</a>
for this <code>ngx.ssl</code> Lua module for more details.</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.ocsp">ngx.ocsp</h2>
<p><strong>syntax:</strong> <em>local ocsp = require "ngx.ocsp"</em></p>
<p>This Lua module provides API to perform OCSP queries, OCSP response
validations, and OCSP stapling planting.</p>
<p>Usually, this module is used together with the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md">ngx.ssl</a>
module in the context of <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua*</a>.</p>
<p>This Lua module does not ship with this ngx_lua module itself rather
it is shipped with the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>Please refer to the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md">documentation</a>
for this <code>ngx.ocsp</code> Lua module for more details.</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ndk.set_var.directive">ndk.set_var.DIRECTIVE</h2>
<p><strong>syntax:</strong> <em>res =
ndk.set_var.DIRECTIVE_NAME</em></p>
<p><strong>context:</strong> <em>init_worker_by_lua*, set_by_lua*,
rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*,
ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, exit_worker_by_lua*,
ssl_client_hello_by_lua*</em></p>
<p>This mechanism allows calling other Nginx C modules' directives that
are implemented by <a
href="https://github.com/simplresty/ngx_devel_kit">Nginx Devel Kit</a>
(NDK)'s set_var submodule's <code>ndk_set_var_value</code>.</p>
<p>For example, the following <a
href="http://github.com/openresty/set-misc-nginx-module">set-misc-nginx-module</a>
directives can be invoked this way:</p>
<ul>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_quote_sql_str">set_quote_sql_str</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_quote_pgsql_str">set_quote_pgsql_str</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_quote_json_str">set_quote_json_str</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_unescape_uri">set_unescape_uri</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_escape_uri">set_escape_uri</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_encode_base32">set_encode_base32</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_decode_base32">set_decode_base32</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64">set_encode_base64</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64">set_decode_base64</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64">set_encode_hex</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64">set_decode_hex</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64">set_sha1</a></li>
<li><a
href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64">set_md5</a></li>
</ul>
<p>For instance,</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="va">res</span> <span class="op">=</span> <span class="va">ndk</span><span class="op">.</span><span class="va">set_var</span><span class="op">.</span>set_escape_uri<span class="op">(</span><span class="st">&#39;a/b&#39;</span><span class="op">)</span></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a> <span class="co">-- now res == &#39;a%2fb&#39;</span></span></code></pre></div>
<p>Similarly, the following directives provided by <a
href="http://github.com/openresty/encrypted-session-nginx-module">encrypted-session-nginx-module</a>
can be invoked from within Lua too:</p>
<ul>
<li><a
href="http://github.com/openresty/encrypted-session-nginx-module#set_encrypt_session">set_encrypt_session</a></li>
<li><a
href="http://github.com/openresty/encrypted-session-nginx-module#set_decrypt_session">set_decrypt_session</a></li>
</ul>
<p>This feature requires the <a
href="https://github.com/simplresty/ngx_devel_kit">ngx_devel_kit</a>
module.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="coroutine.create">coroutine.create</h2>
<p><strong>syntax:</strong> <em>co = coroutine.create(f)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*,
body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Creates a user Lua coroutines with a Lua function, and returns a
coroutine object.</p>
<p>Similar to the standard Lua <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create">coroutine.create</a>
API, but works in the context of the Lua coroutines created by
ngx_lua.</p>
<p>This API was first usable in the context of <a
href="#init_by_lua">init_by_lua*</a> since the <code>0.9.2</code>.</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="coroutine.resume">coroutine.resume</h2>
<p><strong>syntax:</strong> <em>ok, ... = coroutine.resume(co, ...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*,
body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Resumes the execution of a user Lua coroutine object previously
yielded or just created.</p>
<p>Similar to the standard Lua <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume">coroutine.resume</a>
API, but works in the context of the Lua coroutines created by
ngx_lua.</p>
<p>This API was first usable in the context of <a
href="#init_by_lua">init_by_lua*</a> since the <code>0.9.2</code>.</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="coroutine.yield">coroutine.yield</h2>
<p><strong>syntax:</strong> <em>... = coroutine.yield(...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*,
body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Yields the execution of the current user Lua coroutine.</p>
<p>Similar to the standard Lua <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield">coroutine.yield</a>
API, but works in the context of the Lua coroutines created by
ngx_lua.</p>
<p>This API was first usable in the context of <a
href="#init_by_lua">init_by_lua*</a> since the <code>0.9.2</code>.</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="coroutine.wrap">coroutine.wrap</h2>
<p><strong>syntax:</strong> <em>co = coroutine.wrap(f)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*,
body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Similar to the standard Lua <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap">coroutine.wrap</a>
API, but works in the context of the Lua coroutines created by
ngx_lua.</p>
<p>This API was first usable in the context of <a
href="#init_by_lua">init_by_lua*</a> since the <code>0.9.2</code>.</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="coroutine.running">coroutine.running</h2>
<p><strong>syntax:</strong> <em>co = coroutine.running()</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*,
body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Identical to the standard Lua <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running">coroutine.running</a>
API.</p>
<p>This API was first usable in the context of <a
href="#init_by_lua">init_by_lua*</a> since the <code>0.9.2</code>.</p>
<p>This API was first enabled in the <code>v0.6.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="coroutine.status">coroutine.status</h2>
<p><strong>syntax:</strong> <em>status = coroutine.status(co)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*,
body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*,
ssl_session_store_by_lua*, ssl_client_hello_by_lua*</em></p>
<p>Identical to the standard Lua <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status">coroutine.status</a>
API.</p>
<p>This API was first usable in the context of <a
href="#init_by_lua">init_by_lua*</a> since the <code>0.9.2</code>.</p>
<p>This API was first enabled in the <code>v0.6.0</code> release.</p>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>
<h2 id="ngx.run_worker_thread">ngx.run_worker_thread</h2>
<p><strong>syntax:</strong> <em>ok, res1, res2, ... =
ngx.run_worker_thread(threadpool, module_name, func_name, arg1, arg2,
...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua*, access_by_lua*,
content_by_lua*</em></p>
<p><strong>This API is still experimental and may change in the future
without notice.</strong></p>
<p><strong>This API is available only for Linux.</strong></p>
<p>Wrap the <a
href="http://nginx.org/en/docs/dev/development_guide.html#threads">nginx
worker thread</a> to execute lua function. The caller coroutine would
yield until the function returns.</p>
<p>Only the following ngx_lua APIs could be used in
<code>function_name</code> function of the <code>module</code>
module:</p>
<ul>
<li><p><code>ngx.encode_base64</code></p></li>
<li><p><code>ngx.decode_base64</code></p></li>
<li><p><code>ngx.hmac_sha1</code></p></li>
<li><p><code>ngx.encode_args</code></p></li>
<li><p><code>ngx.decode_args</code></p></li>
<li><p><code>ngx.quote_sql_str</code></p></li>
<li><p><code>ngx.crc32_short</code></p></li>
<li><p><code>ngx.crc32_long</code></p></li>
<li><p><code>ngx.hmac_sha1</code></p></li>
<li><p><code>ngx.md5_bin</code></p></li>
<li><p><code>ngx.md5</code></p></li>
<li><p><code>ngx.config.subsystem</code></p></li>
<li><p><code>ngx.config.debug</code></p></li>
<li><p><code>ngx.config.prefix</code></p></li>
<li><p><code>ngx.config.nginx_version</code></p></li>
<li><p><code>ngx.config.nginx_configure</code></p></li>
<li><p><code>ngx.config.ngx_lua_version</code></p></li>
<li><p><code>ngx.shared.DICT</code></p></li>
</ul>
<p>The first argument <code>threadpool</code> specifies the Nginx thread
pool name defined by <a
href="https://nginx.org/en/docs/ngx_core_module.html#thread_pool">thread_pool</a>.</p>
<p>The second argument <code>module_name</code> specifies the lua module
name to execute in the worker thread, which would return a lua table.
The module must be inside the package path, e.g.</p>
<pre class="nginx"><code>
 lua_package_path &#39;/opt/openresty/?.lua;;&#39;;</code></pre>
<p>The third argument <code>func_name</code> specifies the function
field in the module table as the second argument.</p>
<p>The type of <code>args</code> must be one of type below:</p>
<ul>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>nil</li>
<li>table (the table may be recursive, and contains members of types
above.)</li>
</ul>
<p>The <code>ok</code> is in boolean type, which indicate the C land
error (failed to get thread from thread pool, pcall the module function
failed, etc.). If <code>ok</code> is <code>false</code>, the
<code>res1</code> is the error string.</p>
<p>The return values (res1, ...) are returned by invocation of the module
function. Normally, the <code>res1</code> should be in boolean type, so
that the caller could inspect the error.</p>
<p>This API is useful when you need to execute the below types of
tasks:</p>
<ul>
<li>CPU bound task, e.g. do md5 calculation</li>
<li>File I/O task</li>
<li>Call <code>os.execute()</code> or blocking C API via
<code>ffi</code></li>
<li>Call external Lua library not based on cosocket or nginx</li>
</ul>
<p>Example1: do md5 calculation.</p>
<pre class="nginx"><code>
 location /calc_md5 {
     default_type &#39;text/plain&#39;;

     content_by_lua_block {
         local ok, md5_or_err = ngx.run_worker_thread(&quot;testpool&quot;, &quot;md5&quot;, &quot;md5&quot;)
         ngx.say(ok, &quot; : &quot;, md5_or_err)
     }
 }</code></pre>
<p><code>md5.lua</code></p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="kw">local</span> <span class="kw">function</span> md5<span class="op">()</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span>md5<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="op">{</span> <span class="va">md5</span><span class="op">=</span><span class="va">md5</span><span class="op">,</span> <span class="op">}</span></span></code></pre></div>
<p>Example2: write logs into the log file.</p>
<pre class="nginx"><code>
 location /write_log_file {
     default_type &#39;text/plain&#39;;

     content_by_lua_block {
         local ok, err = ngx.run_worker_thread(&quot;testpool&quot;, &quot;write_log_file&quot;, &quot;log&quot;, ngx.var.arg_str)
         if not ok then
             ngx.say(ok, &quot; : &quot;, err)
             return
         end
         ngx.say(ok)
     }
 }</code></pre>
<p><code>write_log_file.lua</code></p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">local</span> <span class="kw">function</span> log<span class="op">(</span><span class="va">str</span><span class="op">)</span></span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">local</span> <span class="va">file</span><span class="op">,</span> <span class="va">err</span> <span class="op">=</span> <span class="fu">io.open</span><span class="op">(</span><span class="st">&quot;/tmp/tmp.log&quot;</span><span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">)</span></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="kw">not</span> <span class="va">file</span> <span class="cf">then</span></span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="kw">false</span><span class="op">,</span> <span class="va">err</span></span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true" tabindex="-1"></a>     <span class="cf">end</span></span>
<span id="cb303-7"><a href="#cb303-7" aria-hidden="true" tabindex="-1"></a>     <span class="va">file</span><span class="op">:</span><span class="fu">write</span><span class="op">(</span><span class="va">str</span><span class="op">)</span></span>
<span id="cb303-8"><a href="#cb303-8" aria-hidden="true" tabindex="-1"></a>     <span class="va">file</span><span class="op">:</span><span class="fu">flush</span><span class="op">()</span></span>
<span id="cb303-9"><a href="#cb303-9" aria-hidden="true" tabindex="-1"></a>     <span class="va">file</span><span class="op">:</span><span class="fu">close</span><span class="op">()</span></span>
<span id="cb303-10"><a href="#cb303-10" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="kw">true</span></span>
<span id="cb303-11"><a href="#cb303-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span>
<span id="cb303-12"><a href="#cb303-12" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="op">{</span><span class="va">log</span><span class="op">=</span><span class="va">log</span><span class="op">}</span></span></code></pre></div>
<p><a href="#nginx-api-for-lua">Back to TOC</a></p>