<h1 id="directives">Directives</h1>
<ul>
<li><a href="#lua_load_resty_core">lua_load_resty_core</a></li>
<li><a href="#lua_capture_error_log">lua_capture_error_log</a></li>
<li><a href="#lua_use_default_type">lua_use_default_type</a></li>
<li><a href="#lua_malloc_trim">lua_malloc_trim</a></li>
<li><a href="#lua_code_cache">lua_code_cache</a></li>
<li><a
href="#lua_thread_cache_max_entries">lua_thread_cache_max_entries</a></li>
<li><a
href="#lua_regex_cache_max_entries">lua_regex_cache_max_entries</a></li>
<li><a href="#lua_regex_match_limit">lua_regex_match_limit</a></li>
<li><a href="#lua_package_path">lua_package_path</a></li>
<li><a href="#lua_package_cpath">lua_package_cpath</a></li>
<li><a href="#init_by_lua">init_by_lua</a></li>
<li><a href="#init_by_lua_block">init_by_lua_block</a></li>
<li><a href="#init_by_lua_file">init_by_lua_file</a></li>
<li><a href="#init_worker_by_lua">init_worker_by_lua</a></li>
<li><a
href="#init_worker_by_lua_block">init_worker_by_lua_block</a></li>
<li><a href="#init_worker_by_lua_file">init_worker_by_lua_file</a></li>
<li><a
href="#exit_worker_by_lua_block">exit_worker_by_lua_block</a></li>
<li><a href="#exit_worker_by_lua_file">exit_worker_by_lua_file</a></li>
<li><a href="#set_by_lua">set_by_lua</a></li>
<li><a href="#set_by_lua_block">set_by_lua_block</a></li>
<li><a href="#set_by_lua_file">set_by_lua_file</a></li>
<li><a href="#content_by_lua">content_by_lua</a></li>
<li><a href="#content_by_lua_block">content_by_lua_block</a></li>
<li><a href="#content_by_lua_file">content_by_lua_file</a></li>
<li><a
href="#server_rewrite_by_lua_block">server_rewrite_by_lua_block</a></li>
<li><a
href="#server_rewrite_by_lua_file">server_rewrite_by_lua_file</a></li>
<li><a href="#rewrite_by_lua">rewrite_by_lua</a></li>
<li><a href="#rewrite_by_lua_block">rewrite_by_lua_block</a></li>
<li><a href="#rewrite_by_lua_file">rewrite_by_lua_file</a></li>
<li><a href="#access_by_lua">access_by_lua</a></li>
<li><a href="#access_by_lua_block">access_by_lua_block</a></li>
<li><a href="#access_by_lua_file">access_by_lua_file</a></li>
<li><a href="#header_filter_by_lua">header_filter_by_lua</a></li>
<li><a
href="#header_filter_by_lua_block">header_filter_by_lua_block</a></li>
<li><a
href="#header_filter_by_lua_file">header_filter_by_lua_file</a></li>
<li><a href="#body_filter_by_lua">body_filter_by_lua</a></li>
<li><a
href="#body_filter_by_lua_block">body_filter_by_lua_block</a></li>
<li><a href="#body_filter_by_lua_file">body_filter_by_lua_file</a></li>
<li><a href="#log_by_lua">log_by_lua</a></li>
<li><a href="#log_by_lua_block">log_by_lua_block</a></li>
<li><a href="#log_by_lua_file">log_by_lua_file</a></li>
<li><a href="#balancer_by_lua_block">balancer_by_lua_block</a></li>
<li><a href="#balancer_by_lua_file">balancer_by_lua_file</a></li>
<li><a href="#balancer_keepalive">balancer_keepalive</a></li>
<li><a href="#lua_need_request_body">lua_need_request_body</a></li>
<li><a
href="#ssl_client_hello_by_lua_block">ssl_client_hello_by_lua_block</a></li>
<li><a
href="#ssl_client_hello_by_lua_file">ssl_client_hello_by_lua_file</a></li>
<li><a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</a></li>
<li><a
href="#ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</a></li>
<li><a
href="#ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</a></li>
<li><a
href="#ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</a></li>
<li><a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</a></li>
<li><a
href="#ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</a></li>
<li><a href="#lua_shared_dict">lua_shared_dict</a></li>
<li><a
href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a></li>
<li><a href="#lua_socket_send_timeout">lua_socket_send_timeout</a></li>
<li><a href="#lua_socket_send_lowat">lua_socket_send_lowat</a></li>
<li><a href="#lua_socket_read_timeout">lua_socket_read_timeout</a></li>
<li><a href="#lua_socket_buffer_size">lua_socket_buffer_size</a></li>
<li><a href="#lua_socket_pool_size">lua_socket_pool_size</a></li>
<li><a
href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a></li>
<li><a href="#lua_socket_log_errors">lua_socket_log_errors</a></li>
<li><a href="#lua_ssl_ciphers">lua_ssl_ciphers</a></li>
<li><a href="#lua_ssl_crl">lua_ssl_crl</a></li>
<li><a href="#lua_ssl_protocols">lua_ssl_protocols</a></li>
<li><a href="#lua_ssl_certificate">lua_ssl_certificate</a></li>
<li><a href="#lua_ssl_certificate_key">lua_ssl_certificate_key</a></li>
<li><a
href="#lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</a></li>
<li><a href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a></li>
<li><a href="#lua_ssl_conf_command">lua_ssl_conf_command</a></li>
<li><a href="#lua_http10_buffering">lua_http10_buffering</a></li>
<li><a
href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a></li>
<li><a
href="#access_by_lua_no_postpone">access_by_lua_no_postpone</a></li>
<li><a
href="#lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</a></li>
<li><a href="#lua_check_client_abort">lua_check_client_abort</a></li>
<li><a href="#lua_max_pending_timers">lua_max_pending_timers</a></li>
<li><a href="#lua_max_running_timers">lua_max_running_timers</a></li>
<li><a href="#lua_sa_restart">lua_sa_restart</a></li>
<li><a
href="#lua_worker_thread_vm_pool_size">lua_worker_thread_vm_pool_size</a></li>
</ul>
<p>The basic building blocks of scripting Nginx with Lua are directives.
Directives are used to specify when the user Lua code is run and how the
result will be used. Below is a diagram showing the order in which
directives are executed.</p>
<figure>
<img src="./doc/images/lua_nginx_modules_directives.drawio.png"
alt="Lua Nginx Modules Directives" />
<figcaption aria-hidden="true">Lua Nginx Modules Directives</figcaption>
</figure>
<p><a href="#table-of-contents">Back to TOC</a></p>
<h2 id="lua_load_resty_core">lua_load_resty_core</h2>
<p><strong>syntax:</strong> <em>lua_load_resty_core on|off</em></p>
<p><strong>default:</strong> <em>lua_load_resty_core on</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>This directive is deprecated since the <code>v0.10.16</code> release
of this module. The <code>resty.core</code> module from <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a> is
now mandatorily loaded during the Lua VM initialization. Specifying this
directive will have no effect.</p>
<p>This directive was first introduced in the <code>v0.10.15</code>
release and used to optionally load the <code>resty.core</code>
module.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_capture_error_log">lua_capture_error_log</h2>
<p><strong>syntax:</strong> <em>lua_capture_error_log size</em></p>
<p><strong>default:</strong> <em>none</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Enables a buffer of the specified <code>size</code> for capturing all
the Nginx error log message data (not just those produced by this module
or the Nginx http subsystem, but everything) without touching files or
disks.</p>
<p>You can use units like <code>k</code> and <code>m</code> in the
<code>size</code> value, as in</p>
<pre class="nginx"><code>
 lua_capture_error_log 100k;</code></pre>
<p>As a rule of thumb, a 4KB buffer can usually hold about 20 typical
error log messages. So do the maths!</p>
<p>This buffer never grows. If it is full, new error log messages will
replace the oldest ones in the buffer.</p>
<p>The size of the buffer must be bigger than the maximum length of a
single error log message (which is 4K in OpenResty and 2K in stock
NGINX).</p>
<p>You can read the messages in the buffer on the Lua land via the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs">get_logs()</a>
function of the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme">ngx.errlog</a>
module of the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme">lua-resty-core</a>
library. This Lua API function will return the captured error log
messages and also remove these already read from the global capturing
buffer, making room for any new error log data. For this reason, the
user should not configure this buffer to be too big if the user read the
buffered error log data fast enough.</p>
<p>Note that the log level specified in the standard <a
href="https://nginx.org/r/error_log">error_log</a> directive
<em>does</em> have effect on this capturing facility. It only captures
log messages of a level no lower than the specified log level in the <a
href="https://nginx.org/r/error_log">error_log</a> directive. The user
can still choose to set an even higher filtering log level on the fly
via the Lua API function <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level">errlog.set_filter_level</a>.
So it is more flexible than the static <a
href="https://nginx.org/r/error_log">error_log</a> directive.</p>
<p>It is worth noting that there is no way to capture the debugging logs
without building OpenResty or Nginx with the <code>./configure</code>
option <code>--with-debug</code>. And enabling debugging logs is
strongly discouraged in production builds due to high overhead.</p>
<p>This directive was first introduced in the <code>v0.10.9</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_use_default_type">lua_use_default_type</h2>
<p><strong>syntax:</strong> <em>lua_use_default_type on | off</em></p>
<p><strong>default:</strong> <em>lua_use_default_type on</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p>Specifies whether to use the MIME type specified by the <a
href="https://nginx.org/en/docs/http/ngx_http_core_module.html#default_type">default_type</a>
directive for the default value of the <code>Content-Type</code>
response header. Deactivate this directive if a default
<code>Content-Type</code> response header for Lua request handlers is
not desired.</p>
<p>This directive is turned on by default.</p>
<p>This directive was first introduced in the <code>v0.9.1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_malloc_trim">lua_malloc_trim</h2>
<p><strong>syntax:</strong> <em>lua_malloc_trim
&lt;request-count&gt;</em></p>
<p><strong>default:</strong> <em>lua_malloc_trim 1000</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Asks the underlying <code>libc</code> runtime library to release its
cached free memory back to the operating system every <code>N</code>
requests processed by the Nginx core. By default, <code>N</code> is
1000. You can configure the request count by using your own numbers.
Smaller numbers mean more frequent releases, which may introduce higher
CPU time consumption and smaller memory footprint while larger numbers
usually lead to less CPU time overhead and relatively larger memory
footprint. Just tune the number for your own use cases.</p>
<p>Configuring the argument to <code>0</code> essentially turns off the
periodical memory trimming altogether.</p>
<pre class="nginx"><code>
 lua_malloc_trim 0;  # turn off trimming completely</code></pre>
<p>The current implementation uses an Nginx log phase handler to do the
request counting. So the appearance of the <a
href="https://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest">log_subrequest
on</a> directives in <code>nginx.conf</code> may make the counting
faster when subrequests are involved. By default, only “main requests”
count.</p>
<p>Note that this directive does <em>not</em> affect the memory
allocated by LuaJIT’s own allocator based on the <code>mmap</code>
system call.</p>
<p>This directive was first introduced in the <code>v0.10.7</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_code_cache">lua_code_cache</h2>
<p><strong>syntax:</strong> <em>lua_code_cache on | off</em></p>
<p><strong>default:</strong> <em>lua_code_cache on</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p>Enables or disables the Lua code cache for Lua code in
<code>*_by_lua_file</code> directives (like <a
href="#set_by_lua_file">set_by_lua_file</a> and <a
href="#content_by_lua_file">content_by_lua_file</a>) and Lua
modules.</p>
<p>When turning off, every request served by ngx_lua will run in a
separate Lua VM instance, starting from the <code>0.9.3</code> release.
So the Lua files referenced in <a
href="#set_by_lua_file">set_by_lua_file</a>, <a
href="#content_by_lua_file">content_by_lua_file</a>, <a
href="#access_by_lua_file">access_by_lua_file</a>, and etc will not be
cached and all Lua modules used will be loaded from scratch. With this
in place, developers can adopt an edit-and-refresh approach.</p>
<p>Please note however, that Lua code written inlined within nginx.conf
such as those specified by <a href="#set_by_lua">set_by_lua</a>, <a
href="#content_by_lua">content_by_lua</a>, <a
href="#access_by_lua">access_by_lua</a>, and <a
href="#rewrite_by_lua">rewrite_by_lua</a> will not be updated when you
edit the inlined Lua code in your <code>nginx.conf</code> file because
only the Nginx config file parser can correctly parse the
<code>nginx.conf</code> file and the only way is to reload the config
file by sending a <code>HUP</code> signal or just to restart Nginx.</p>
<p>Even when the code cache is enabled, Lua files which are loaded by
<code>dofile</code> or <code>loadfile</code> in *_by_lua_file cannot be
cached (unless you cache the results yourself). Usually you can either
use the <a href="#init_by_lua">init_by_lua</a> or <a
href="#init-by_lua_file">init_by_lua_file</a> directives to load all
such files or just make these Lua files true Lua modules and load them
via <code>require</code>.</p>
<p>The ngx_lua module does not support the <code>stat</code> mode
available with the Apache <code>mod_lua</code> module (yet).</p>
<p>Disabling the Lua code cache is strongly discouraged for production
use and should only be used during development as it has a significant
negative impact on overall performance. For example, the performance of
a “hello world” Lua example can drop by an order of magnitude after
disabling the Lua code cache.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_thread_cache_max_entries">lua_thread_cache_max_entries</h2>
<p><strong>syntax:</strong> <em>lua_thread_cache_max_entries
&lt;num&gt;</em></p>
<p><strong>default:</strong> <em>lua_thread_cache_max_entries
1024</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Specifies the maximum number of entries allowed in the worker process
level lua thread object cache.</p>
<p>This cache recycles the lua thread GC objects among all our “light
threads”.</p>
<p>A zero value of <code>&lt;num&gt;</code> disables the cache.</p>
<p>Note that this feature requires OpenResty’s LuaJIT with the new C API
<code>lua_resetthread</code>.</p>
<p>This feature was first introduced in verson <code>v0.10.9</code>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_regex_cache_max_entries">lua_regex_cache_max_entries</h2>
<p><strong>syntax:</strong> <em>lua_regex_cache_max_entries
&lt;num&gt;</em></p>
<p><strong>default:</strong> <em>lua_regex_cache_max_entries
1024</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Specifies the maximum number of entries allowed in the worker process
level compiled regex cache.</p>
<p>The regular expressions used in <a
href="#ngxrematch">ngx.re.match</a>, <a
href="#ngxregmatch">ngx.re.gmatch</a>, <a
href="#ngxresub">ngx.re.sub</a>, and <a
href="#ngxregsub">ngx.re.gsub</a> will be cached within this cache if
the regex option <code>o</code> (i.e., compile-once flag) is
specified.</p>
<p>The default number of entries allowed is 1024 and when this limit is
reached, new regular expressions will not be cached (as if the
<code>o</code> option was not specified) and there will be one, and only
one, warning in the <code>error.log</code> file:</p>
<pre><code>2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...</code></pre>
<p>If you are using the <code>ngx.re.*</code> implementation of <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a> by
loading the <code>resty.core.regex</code> module (or just the
<code>resty.core</code> module), then an LRU cache is used for the regex
cache being used here.</p>
<p>Do not activate the <code>o</code> option for regular expressions
(and/or <code>replace</code> string arguments for <a
href="#ngxresub">ngx.re.sub</a> and <a
href="#ngxregsub">ngx.re.gsub</a>) that are generated <em>on the
fly</em> and give rise to infinite variations to avoid hitting the
specified limit.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_regex_match_limit">lua_regex_match_limit</h2>
<p><strong>syntax:</strong> <em>lua_regex_match_limit
&lt;num&gt;</em></p>
<p><strong>default:</strong> <em>lua_regex_match_limit 0</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Specifies the “match limit” used by the PCRE library when executing
the <a href="#ngxrematch">ngx.re API</a>. To quote the PCRE manpage,
“the limit … has the effect of limiting the amount of backtracking that
can take place.”</p>
<p>When the limit is hit, the error string “pcre_exec() failed: -8” will
be returned by the <a href="#ngxrematch">ngx.re API</a> functions on the
Lua land.</p>
<p>When setting the limit to 0, the default “match limit” when compiling
the PCRE library is used. And this is the default value of this
directive.</p>
<p>This directive was first introduced in the <code>v0.8.5</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_package_path">lua_package_path</h2>
<p><strong>syntax:</strong> <em>lua_package_path
&lt;lua-style-path-str&gt;</em></p>
<p><strong>default:</strong> <em>The content of LUA_PATH environment
variable or Lua’s compiled-in defaults.</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Sets the Lua module search path used by scripts specified by <a
href="#set_by_lua">set_by_lua</a>, <a
href="#content_by_lua">content_by_lua</a> and others. The path string is
in standard Lua path form, and <code>;;</code> can be used to stand for
the original search paths.</p>
<p>As from the <code>v0.5.0rc29</code> release, the special notation
<code>$prefix</code> or <code>${prefix}</code> can be used in the search
path string to indicate the path of the <code>server prefix</code>
usually determined by the <code>-p PATH</code> command-line option while
starting the Nginx server.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_package_cpath">lua_package_cpath</h2>
<p><strong>syntax:</strong> <em>lua_package_cpath
&lt;lua-style-cpath-str&gt;</em></p>
<p><strong>default:</strong> <em>The content of LUA_CPATH environment
variable or Lua’s compiled-in defaults.</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Sets the Lua C-module search path used by scripts specified by <a
href="#set_by_lua">set_by_lua</a>, <a
href="#content_by_lua">content_by_lua</a> and others. The cpath string
is in standard Lua cpath form, and <code>;;</code> can be used to stand
for the original cpath.</p>
<p>As from the <code>v0.5.0rc29</code> release, the special notation
<code>$prefix</code> or <code>${prefix}</code> can be used in the search
path string to indicate the path of the <code>server prefix</code>
usually determined by the <code>-p PATH</code> command-line option while
starting the Nginx server.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="init_by_lua">init_by_lua</h2>
<p><strong>syntax:</strong> <em>init_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#init_by_lua_block">init_by_lua_block</a> directive instead.</p>
<p>Similar to the <a href="#init_by_lua_block">init_by_lua_block</a>
directive, but accepts the Lua source directly in an Nginx string
literal (which requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 init_by_lua &#39;
     print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)
 &#39;</code></pre>
<p>This directive was first introduced in the <code>v0.5.5</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="init_by_lua_block">init_by_lua_block</h2>
<p><strong>syntax:</strong> <em>init_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p>When Nginx receives the <code>HUP</code> signal and starts reloading
the config file, the Lua VM will also be re-created and
<code>init_by_lua_block</code> will run again on the new Lua VM. In case
that the <a href="#lua_code_cache">lua_code_cache</a> directive is
turned off (default on), the <code>init_by_lua_block</code> handler will
run upon every request because in this special mode a standalone Lua VM
is always created for each request.</p>
<p>Usually you can pre-load Lua modules at server start-up by means of
this hook and take advantage of modern operating systems’ copy-on-write
(COW) optimization. Here is an example for pre-loading Lua modules:</p>
<pre class="nginx"><code>
 # this runs before forking out nginx worker processes:
 init_by_lua_block { require &quot;cjson&quot; }

 server {
     location = /api {
         content_by_lua_block {
             -- the following require() will just  return
             -- the already loaded module from package.loaded:
             ngx.say(require &quot;cjson&quot;.encode{dog = 5, cat = 6})
         }
     }
 }</code></pre>
<p>You can also initialize the <a
href="#lua_shared_dict">lua_shared_dict</a> shm storage at this phase.
Here is an example for this:</p>
<pre class="nginx"><code>
 lua_shared_dict dogs 1m;

 init_by_lua_block {
     local dogs = ngx.shared.dogs
     dogs:set(&quot;Tom&quot;, 56)
 }

 server {
     location = /api {
         content_by_lua_block {
             local dogs = ngx.shared.dogs
             ngx.say(dogs:get(&quot;Tom&quot;))
         }
     }
 }</code></pre>
<p>But note that, the <a href="#lua_shared_dict">lua_shared_dict</a>’s
shm storage will not be cleared through a config reload (via the
<code>HUP</code> signal, for example). So if you do <em>not</em> want to
re-initialize the shm storage in your <code>init_by_lua_block</code>
code in this case, then you just need to set a custom flag in the shm
storage and always check the flag in your <code>init_by_lua_block</code>
code.</p>
<p>Because the Lua code in this context runs before Nginx forks its
worker processes (if any), data or code loaded here will enjoy the <a
href="https://en.wikipedia.org/wiki/Copy-on-write">Copy-on-write
(COW)</a> feature provided by many operating systems among all the
worker processes, thus saving a lot of memory.</p>
<p>Do <em>not</em> initialize your own Lua global variables in this
context because use of Lua global variables have performance penalties
and can lead to global namespace pollution (see the <a
href="#lua-variable-scope">Lua Variable Scope</a> section for more
details). The recommended way is to use proper <a
href="https://www.lua.org/manual/5.1/manual.html#5.3">Lua module</a>
files (but do not use the standard Lua function <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-module">module()</a>
to define Lua modules because it pollutes the global namespace as well)
and call <a
href="https://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
to load your own module files in <code>init_by_lua_block</code> or other
contexts (<a
href="https://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
does cache the loaded Lua modules in the global
<code>package.loaded</code> table in the Lua registry so your modules
will only loaded once for the whole Lua VM instance).</p>
<p>Only a small set of the <a href="#nginx-api-for-lua">Nginx API for
Lua</a> is supported in this context:</p>
<ul>
<li>Logging APIs: <a href="#ngxlog">ngx.log</a> and <a
href="#print">print</a>,</li>
<li>Shared Dictionary API: <a
href="#ngxshareddict">ngx.shared.DICT</a>.</li>
</ul>
<p>More Nginx APIs for Lua may be supported in this context upon future
user requests.</p>
<p>Basically you can safely use Lua libraries that do blocking I/O in
this very context because blocking the master process during server
start-up is completely okay. Even the Nginx core does blocking I/O (at
least on resolving upstream’s host names) at the configure-loading
phase.</p>
<p>You should be very careful about potential security vulnerabilities
in your Lua code registered in this context because the Nginx master
process is often run under the <code>root</code> account.</p>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p>See also the following blog posts for more details on OpenResty and
Nginx’s shared memory zones:</p>
<ul>
<li><a
href="https://blog.openresty.com/en/how-nginx-shm-consume-ram/?src=gh_ngxlua">How
OpenResty and Nginx Shared Memory Zones Consume RAM</a></li>
<li><a
href="https://blog.openresty.com/en/nginx-shm-frag/?src=gh_ngxlua">Memory
Fragmentation in OpenResty and Nginx’s Shared Memory Zones</a></li>
</ul>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="init_by_lua_file">init_by_lua_file</h2>
<p><strong>syntax:</strong> <em>init_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p>Equivalent to <a href="#init_by_lua_block">init_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.5.5</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="init_worker_by_lua">init_worker_by_lua</h2>
<p><strong>syntax:</strong> <em>init_worker_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>starting-worker</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#init_worker_by_lua_block">init_worker_by_lua_block</a> directive
instead.</p>
<p>Similar to the <a
href="#init_worker_by_lua_block">init_worker_by_lua_block</a> directive,
but accepts the Lua source directly in an Nginx string literal (which
requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 init_worker_by_lua &#39;
     print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)
 &#39;;</code></pre>
<p>This directive was first introduced in the <code>v0.9.5</code>
release.</p>
<p>This hook no longer runs in the cache manager and cache loader
processes since the <code>v0.10.12</code> release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="init_worker_by_lua_block">init_worker_by_lua_block</h2>
<p><strong>syntax:</strong> <em>init_worker_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>starting-worker</em></p>
<p>Runs the specified Lua code upon every Nginx worker process’s startup
when the master process is enabled. When the master process is disabled,
this hook will just run after <a
href="#init_by_lua_block">init_by_lua*</a>.</p>
<p>This hook is often used to create per-worker reoccurring timers (via
the <a href="#ngxtimerat">ngx.timer.at</a> Lua API), either for backend
health-check or other timed routine work. Below is an example,</p>
<pre class="nginx"><code>
 init_worker_by_lua_block {
     local delay = 3  -- in seconds
     local new_timer = ngx.timer.at
     local log = ngx.log
     local ERR = ngx.ERR
     local check

     check = function(premature)
         if not premature then
             -- do the health check or other routine work
             local ok, err = new_timer(delay, check)
             if not ok then
                 log(ERR, &quot;failed to create timer: &quot;, err)
                 return
             end
         end

         -- do something in timer
     end

     local hdl, err = new_timer(delay, check)
     if not hdl then
         log(ERR, &quot;failed to create timer: &quot;, err)
         return
     end

     -- other job in init_worker_by_lua
 }</code></pre>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p>This hook no longer runs in the cache manager and cache loader
processes since the <code>v0.10.12</code> release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="init_worker_by_lua_file">init_worker_by_lua_file</h2>
<p><strong>syntax:</strong> <em>init_worker_by_lua_file
&lt;lua-file-path&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>starting-worker</em></p>
<p>Similar to <a
href="#init_worker_by_lua_block">init_worker_by_lua_block</a>, but
accepts the file path to a Lua source file or Lua bytecode file.</p>
<p>This directive was first introduced in the <code>v0.9.5</code>
release.</p>
<p>This hook no longer runs in the cache manager and cache loader
processes since the <code>v0.10.12</code> release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="exit_worker_by_lua_block">exit_worker_by_lua_block</h2>
<p><strong>syntax:</strong> <em>exit_worker_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>exiting-worker</em></p>
<p>Runs the specified Lua code upon every Nginx worker process’s exit
when the master process is enabled. When the master process is disabled,
this hook will run before the Nginx process exits.</p>
<p>This hook is often used to release resources allocated by each worker
(e.g. resources allocated by <a
href="#init_worker_by_lua_block">init_worker_by_lua*</a>), or to prevent
workers from exiting abnormally.</p>
<p>For example,</p>
<pre class="nginx"><code>
 exit_worker_by_lua_block {
     print(&quot;log from exit_worker_by_lua_block&quot;)
 }</code></pre>
<p>It’s not allowed to create a timer (even a 0-delay timer) here since
it runs after all timers have been processed.</p>
<p>This directive was first introduced in the <code>v0.10.18</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="exit_worker_by_lua_file">exit_worker_by_lua_file</h2>
<p><strong>syntax:</strong> <em>exit_worker_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>exiting-worker</em></p>
<p>Similar to <a
href="#exit_worker_by_lua_block">exit_worker_by_lua_block</a>, but
accepts the file path to a Lua source file or Lua bytecode file.</p>
<p>This directive was first introduced in the <code>v0.10.18</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="set_by_lua">set_by_lua</h2>
<p><strong>syntax:</strong> <em>set_by_lua <span
class="math inline">$res &amp;lt;lua-script-str&amp;gt; [$</span>arg1
$arg2 …]</em></p>
<p><strong>context:</strong> <em>server, server if, location, location
if</em></p>
<p><strong>phase:</strong> <em>rewrite</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#set_by_lua_block">set_by_lua_block</a> directive instead.</p>
<p>Similar to the <a href="#set_by_lua_block">set_by_lua_block</a>
directive, but accepts the Lua source directly in an Nginx string
literal (which requires special character escaping), and 1. this
directive support extra arguments after the Lua script.</p>
<p>For example,</p>
<pre class="nginx"><code>
 set_by_lua $res &#39; return 32 + math.cos(32) &#39;;
 # $res now has the value &quot;32.834223360507&quot; or alike.</code></pre>
<p>As from the <code>v0.5.0rc29</code> release, Nginx variable
interpolation is disabled in the <code>&lt;lua-script-str&gt;</code>
argument of this directive and therefore, the dollar sign character
(<code>$</code>) can be used directly.</p>
<p>This directive requires the <a
href="https://github.com/simplresty/ngx_devel_kit">ngx_devel_kit</a>
module.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="set_by_lua_block">set_by_lua_block</h2>
<p><strong>syntax:</strong> <em>set_by_lua_block $res { lua-script
}</em></p>
<p><strong>context:</strong> <em>server, server if, location, location
if</em></p>
<p><strong>phase:</strong> <em>rewrite</em></p>
<p>Executes code specified inside a pair of curly braces
(<code>{}</code>), and returns string output to <code>$res</code>. The
code inside a pair of curly braces (<code>{}</code>) can make <a
href="#nginx-api-for-lua">API calls</a> and can retrieve input arguments
from the <code>ngx.arg</code> table (index starts from <code>1</code>
and increases sequentially).</p>
<p>This directive is designed to execute short, fast running code blocks
as the Nginx event loop is blocked during code execution. Time consuming
code sequences should therefore be avoided.</p>
<p>This directive is implemented by injecting custom commands into the
standard <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>’s
command list. Because <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>
does not support nonblocking I/O in its commands, Lua APIs requiring
yielding the current Lua “light thread” cannot work in this
directive.</p>
<p>At least the following API functions are currently disabled within
the context of <code>set_by_lua_block</code>:</p>
<ul>
<li>Output API functions (e.g., <a href="#ngxsay">ngx.say</a> and <a
href="#ngxsend_headers">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="#ngxexit">ngx.exit</a>)</li>
<li>Subrequest API functions (e.g., <a
href="#ngxlocationcapture">ngx.location.capture</a> and <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a
href="#ngxsockettcp">ngx.socket.tcp</a> and <a
href="#ngxreqsocket">ngx.req.socket</a>).</li>
<li>Sleeping API function <a href="#ngxsleep">ngx.sleep</a>.</li>
</ul>
<p>In addition, note that this directive can only write out a value to a
single Nginx variable at a time. However, a workaround is possible using
the <a href="#ngxvarvariable">ngx.var.VARIABLE</a> interface.</p>
<pre class="nginx"><code>
 location /foo {
     set $diff &#39;&#39;; # we have to predefine the $diff variable here

     set_by_lua_block $sum {
         local a = 32
         local b = 56

         ngx.var.diff = a - b  -- write to $diff directly
         return a + b          -- return the $sum value normally
     }

     echo &quot;sum = $sum, diff = $diff&quot;;
 }</code></pre>
<p>This directive can be freely mixed with all directives of the <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>,
<a
href="http://github.com/openresty/set-misc-nginx-module">set-misc-nginx-module</a>,
and <a
href="http://github.com/openresty/array-var-nginx-module">array-var-nginx-module</a>
modules. All of these directives will run in the same order as they
appear in the config file.</p>
<pre class="nginx"><code>
 set $foo 32;
 set_by_lua_block $bar { return tonumber(ngx.var.foo) + 1 }
 set $baz &quot;bar: $bar&quot;;  # $baz == &quot;bar: 33&quot;</code></pre>
<p>No special escaping is required in the Lua code block.</p>
<p>This directive requires the <a
href="https://github.com/simplresty/ngx_devel_kit">ngx_devel_kit</a>
module.</p>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="set_by_lua_file">set_by_lua_file</h2>
<p><strong>syntax:</strong> <em>set_by_lua_file <span
class="math inline">$res &amp;lt;path-to-lua-script-file&amp;gt;
[$</span>arg1 $arg2 …]</em></p>
<p><strong>context:</strong> <em>server, server if, location, location
if</em></p>
<p><strong>phase:</strong> <em>rewrite</em></p>
<p>Equivalent to <a href="#set_by_lua_block">set_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or,
as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variable interpolation is supported in the
<code>&lt;path-to-lua-script-file&gt;</code> argument string of this
directive. But special care must be taken for injection attacks.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is
loaded once at the first request and cached and the Nginx config must be
reloaded each time the Lua source file is modified. The Lua code cache
can be temporarily disabled during development by switching <a
href="#lua_code_cache">lua_code_cache</a> <code>off</code> in
<code>nginx.conf</code> to avoid reloading Nginx.</p>
<p>This directive requires the <a
href="https://github.com/simplresty/ngx_devel_kit">ngx_devel_kit</a>
module.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="content_by_lua">content_by_lua</h2>
<p><strong>syntax:</strong> <em>content_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>location, location if</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#content_by_lua_block">content_by_lua_block</a> directive
instead.</p>
<p>Similar to the <a
href="#content_by_lua_block">content_by_lua_block</a> directive, but
accepts the Lua source directly in an Nginx string literal (which
requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 content_by_lua &#39;
     ngx.say(&quot;I need no extra escaping here, for example: \r\nblah&quot;)
 &#39;;</code></pre>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="content_by_lua_block">content_by_lua_block</h2>
<p><strong>syntax:</strong> <em>content_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>location, location if</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>For instance,</p>
<pre class="nginx"><code>
 content_by_lua_block {
     ngx.say(&quot;I need no extra escaping here, for example: \r\nblah&quot;)
 }</code></pre>
<p>Acts as a “content handler” and executes Lua code string specified in
<code>{ lua-script }</code> for every request. The Lua code may make <a
href="#nginx-api-for-lua">API calls</a> and is executed as a new spawned
coroutine in an independent global environment (i.e. a sandbox).</p>
<p>Do not use this directive and other content handler directives in the
same location. For example, this directive and the <a
href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>
directive should not be used in the same location.</p>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="content_by_lua_file">content_by_lua_file</h2>
<p><strong>syntax:</strong> <em>content_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>location, location if</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>Equivalent to <a
href="#content_by_lua_block">content_by_lua_block</a>, except that the
file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains
the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>If the file is not found, a <code>404 Not Found</code> status code
will be returned, and a <code>503 Service Temporarily Unavailable</code>
status code will be returned in case of errors in reading other
files.</p>
<p>Nginx variables can be used in the
<code>&lt;path-to-lua-script-file&gt;</code> string to provide
flexibility. This however carries some risks and is not ordinarily
recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is
loaded once at the first request and cached and the Nginx config must be
reloaded each time the Lua source file is modified. The Lua code cache
can be temporarily disabled during development by switching <a
href="#lua_code_cache">lua_code_cache</a> <code>off</code> in
<code>nginx.conf</code> to avoid reloading Nginx.</p>
<p>Nginx variables are supported in the file path for dynamic dispatch,
for example:</p>
<pre class="nginx"><code>
 # CAUTION: contents in nginx var must be carefully filtered,
 # otherwise there&#39;ll be great security risk!
 location ~ ^/app/([-_a-zA-Z0-9/]+) {
     set $path $1;
     content_by_lua_file /path/to/lua/app/root/$path.lua;
 }</code></pre>
<p>But be very careful about malicious user inputs and always carefully
validate or filter out the user-supplied path components.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="server_rewrite_by_lua_block">server_rewrite_by_lua_block</h2>
<p><strong>syntax:</strong> <em>server_rewrite_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http, server</em></p>
<p><strong>phase:</strong> <em>server rewrite</em></p>
<p>Acts as a server rewrite phase handler and executes Lua code string
specified in <code>{ lua-script }</code> for every request. The Lua code
may make <a href="#nginx-api-for-lua">API calls</a> and is executed as a
new spawned coroutine in an independent global environment (i.e. a
sandbox).</p>
<pre class="nginx"><code>
 server {
     ...

     server_rewrite_by_lua_block {
         ngx.ctx.a = &quot;server_rewrite_by_lua_block in http&quot;
     }

     location /lua {
         content_by_lua_block {
             ngx.say(ngx.ctx.a)
             ngx.log(ngx.INFO, ngx.ctx.a)
            }
     }
 }</code></pre>
<p>Just as any other rewrite phase handlers, <a
href="#server_rewrite_by_lua_block">server_rewrite_by_lua_block</a> also
runs in subrequests.</p>
<pre class="nginx"><code>
 server {
     server_rewrite_by_lua_block {
         ngx.log(ngx.INFO, &quot;is_subrequest:&quot;, ngx.is_subrequest)
     }

     location /lua {
         content_by_lua_block {
             local res = ngx.location.capture(&quot;/sub&quot;)
             ngx.print(res.body)
         }
     }

     location /sub {
         content_by_lua_block {
             ngx.say(&quot;OK&quot;)
         }
     }
 }</code></pre>
<p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a
href="#server_rewrite_by_lua_block">server_rewrite_by_lua_block</a>
handler, the Nginx request processing control flow will still continue
to the content handler. To terminate the current request from within a
<a href="#server_rewrite_by_lua_block">server_rewrite_by_lua_block</a>
handler, call <a href="#ngxexit">ngx.exit</a> with status &gt;= 200
(<code>ngx.HTTP_OK</code>) and status &lt; 300
(<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and
<code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends)
for failures.</p>
<pre class="nginx"><code>
 server_rewrite_by_lua_block {
     ngx.exit(503)
 }

 location /bar {
     ...
     # never exec
 }</code></pre>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="server_rewrite_by_lua_file">server_rewrite_by_lua_file</h2>
<p><strong>syntax:</strong> <em>server_rewrite_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server</em></p>
<p><strong>phase:</strong> <em>server rewrite</em></p>
<p>Equivalent to <a
href="#server_rewrite_by_lua_block">server_rewrite_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or,
as from the <code>v0.10.22</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variables can be used in the
<code>&lt;path-to-lua-script-file&gt;</code> string to provide
flexibility. This however carries some risks and is not ordinarily
recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is
loaded once at the first request and cached and the Nginx config must be
reloaded each time the Lua source file is modified. The Lua code cache
can be temporarily disabled during development by switching <a
href="#lua_code_cache">lua_code_cache</a> <code>off</code> in
<code>nginx.conf</code> to avoid reloading Nginx.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="rewrite_by_lua">rewrite_by_lua</h2>
<p><strong>syntax:</strong> <em>rewrite_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>rewrite tail</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> directive
instead.</p>
<p>Similar to the <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> directive, but
accepts the Lua source directly in an Nginx string literal (which
requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 rewrite_by_lua &#39;
     do_something(&quot;hello, world!\nhiya\n&quot;)
 &#39;;</code></pre>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="rewrite_by_lua_block">rewrite_by_lua_block</h2>
<p><strong>syntax:</strong> <em>rewrite_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>rewrite tail</em></p>
<p>Acts as a rewrite phase handler and executes Lua code string
specified in <code>{ lua-script }</code> for every request. The Lua code
may make <a href="#nginx-api-for-lua">API calls</a> and is executed as a
new spawned coroutine in an independent global environment (i.e. a
sandbox).</p>
<p>Note that this handler always runs <em>after</em> the standard <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>.
So the following will work as expected:</p>
<pre class="nginx"><code>
 location /foo {
     set $a 12; # create and initialize $a
     set $b &quot;&quot;; # create and initialize $b
     rewrite_by_lua_block {
         ngx.var.b = tonumber(ngx.var.a) + 1
     }
     echo &quot;res = $b&quot;;
 }</code></pre>
<p>because <code>set $a 12</code> and <code>set $b ""</code> run
<em>before</em> <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a>.</p>
<p>On the other hand, the following will not work as expected:</p>
<pre class="nginx"><code>
 ?  location /foo {
 ?      set $a 12; # create and initialize $a
 ?      set $b &#39;&#39;; # create and initialize $b
 ?      rewrite_by_lua_block {
 ?          ngx.var.b = tonumber(ngx.var.a) + 1
 ?      }
 ?      if ($b = &#39;13&#39;) {
 ?         rewrite ^ /bar redirect;
 ?         break;
 ?      }
 ?
 ?      echo &quot;res = $b&quot;;
 ?  }</code></pre>
<p>because <code>if</code> runs <em>before</em> <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> even if it is
placed after <a href="#rewrite_by_lua_block">rewrite_by_lua_block</a> in
the config.</p>
<p>The right way of doing this is as follows:</p>
<pre class="nginx"><code>
 location /foo {
     set $a 12; # create and initialize $a
     set $b &#39;&#39;; # create and initialize $b
     rewrite_by_lua_block {
         ngx.var.b = tonumber(ngx.var.a) + 1
         if tonumber(ngx.var.b) == 13 then
             return ngx.redirect(&quot;/bar&quot;)
         end
     }

     echo &quot;res = $b&quot;;
 }</code></pre>
<p>Note that the <a
href="http://www.grid.net.ru/nginx/eval.en.html">ngx_eval</a> module can
be approximated by using <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a>. For example,</p>
<pre class="nginx"><code>
 location / {
     eval $res {
         proxy_pass http://foo.com/check-spam;
     }

     if ($res = &#39;spam&#39;) {
         rewrite ^ /terms-of-use.html redirect;
     }

     fastcgi_pass ...;
 }</code></pre>
<p>can be implemented in ngx_lua as:</p>
<pre class="nginx"><code>
 location = /check-spam {
     internal;
     proxy_pass http://foo.com/check-spam;
 }

 location / {
     rewrite_by_lua_block {
         local res = ngx.location.capture(&quot;/check-spam&quot;)
         if res.body == &quot;spam&quot; then
             return ngx.redirect(&quot;/terms-of-use.html&quot;)
         end
     }

     fastcgi_pass ...;
 }</code></pre>
<p>Just as any other rewrite phase handlers, <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> also runs in
subrequests.</p>
<p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> handler, the Nginx
request processing control flow will still continue to the content
handler. To terminate the current request from within a <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> handler, call <a
href="#ngxexit">ngx.exit</a> with status &gt;= 200
(<code>ngx.HTTP_OK</code>) and status &lt; 300
(<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and
<code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends)
for failures.</p>
<p>If the <a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a>’s
<a
href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite">rewrite</a>
directive is used to change the URI and initiate location re-lookups
(internal redirections), then any <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a> or <a
href="#rewrite_by_lua_file_block">rewrite_by_lua_file_block</a> code
sequences within the current location will not be executed. For
example,</p>
<pre class="nginx"><code>
 location /foo {
     rewrite ^ /bar;
     rewrite_by_lua_block {
         ngx.exit(503)
     }
 }
 location /bar {
     ...
 }</code></pre>
<p>Here the Lua code <code>ngx.exit(503)</code> will never run. This
will be the case if <code>rewrite ^ /bar last</code> is used as this
will similarly initiate an internal redirection. If the
<code>break</code> modifier is used instead, there will be no internal
redirection and the <code>rewrite_by_lua_block</code> code will be
executed.</p>
<p>The <code>rewrite_by_lua_block</code> code will always run at the end
of the <code>rewrite</code> request-processing phase unless <a
href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a> is
turned on.</p>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="rewrite_by_lua_file">rewrite_by_lua_file</h2>
<p><strong>syntax:</strong> <em>rewrite_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>rewrite tail</em></p>
<p>Equivalent to <a
href="#rewrite_by_lua_block">rewrite_by_lua_block</a>, except that the
file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains
the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variables can be used in the
<code>&lt;path-to-lua-script-file&gt;</code> string to provide
flexibility. This however carries some risks and is not ordinarily
recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is
loaded once at the first request and cached and the Nginx config must be
reloaded each time the Lua source file is modified. The Lua code cache
can be temporarily disabled during development by switching <a
href="#lua_code_cache">lua_code_cache</a> <code>off</code> in
<code>nginx.conf</code> to avoid reloading Nginx.</p>
<p>The <code>rewrite_by_lua_file</code> code will always run at the end
of the <code>rewrite</code> request-processing phase unless <a
href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a> is
turned on.</p>
<p>Nginx variables are supported in the file path for dynamic dispatch
just as in <a href="#content_by_lua_file">content_by_lua_file</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="access_by_lua">access_by_lua</h2>
<p><strong>syntax:</strong> <em>access_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>access tail</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#access_by_lua_block">access_by_lua_block</a> directive
instead.</p>
<p>Similar to the <a href="#access_by_lua_block">access_by_lua_block</a>
directive, but accepts the Lua source directly in an Nginx string
literal (which requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 access_by_lua &#39;
     do_something(&quot;hello, world!\nhiya\n&quot;)
 &#39;;</code></pre>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="access_by_lua_block">access_by_lua_block</h2>
<p><strong>syntax:</strong> <em>access_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>access tail</em></p>
<p>Acts as an access phase handler and executes Lua code string
specified in <code>{ &lt;lua-script }</code> for every request. The Lua
code may make <a href="#nginx-api-for-lua">API calls</a> and is executed
as a new spawned coroutine in an independent global environment (i.e. a
sandbox).</p>
<p>Note that this handler always runs <em>after</em> the standard <a
href="http://nginx.org/en/docs/http/ngx_http_access_module.html">ngx_http_access_module</a>.
So the following will work as expected:</p>
<pre class="nginx"><code>
 location / {
     deny    192.168.1.1;
     allow   192.168.1.0/24;
     allow   10.1.1.0/16;
     deny    all;

     access_by_lua_block {
         local res = ngx.location.capture(&quot;/mysql&quot;, { ... })
         ...
     }

     # proxy_pass/fastcgi_pass/...
 }</code></pre>
<p>That is, if a client IP address is in the blacklist, it will be
denied before the MySQL query for more complex authentication is
executed by <a href="#access_by_lua_block">access_by_lua_block</a>.</p>
<p>Note that the <a
href="http://mdounin.ru/hg/ngx_http_auth_request_module/">ngx_auth_request</a>
module can be approximated by using <a
href="#access_by_lua_block">access_by_lua_block</a>:</p>
<pre class="nginx"><code>
 location / {
     auth_request /auth;

     # proxy_pass/fastcgi_pass/postgres_pass/...
 }</code></pre>
<p>can be implemented in ngx_lua as:</p>
<pre class="nginx"><code>
 location / {
     access_by_lua_block {
         local res = ngx.location.capture(&quot;/auth&quot;)

         if res.status == ngx.HTTP_OK then
             return
         end

         if res.status == ngx.HTTP_FORBIDDEN then
             ngx.exit(res.status)
         end

         ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
     }

     # proxy_pass/fastcgi_pass/postgres_pass/...
 }</code></pre>
<p>As with other access phase handlers, <a
href="#access_by_lua_block">access_by_lua_block</a> will <em>not</em>
run in subrequests.</p>
<p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a
href="#access_by_lua_block">access_by_lua_block</a> handler, the Nginx
request processing control flow will still continue to the content
handler. To terminate the current request from within a <a
href="#access_by_lua_block">access_by_lua_block</a> handler, call <a
href="#ngxexit">ngx.exit</a> with status &gt;= 200
(<code>ngx.HTTP_OK</code>) and status &lt; 300
(<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and
<code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends)
for failures.</p>
<p>Starting from the <code>v0.9.20</code> release, you can use the <a
href="#access_by_lua_no_postpone">access_by_lua_no_postpone</a>
directive to control when to run this handler inside the “access”
request-processing phase of Nginx.</p>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="access_by_lua_file">access_by_lua_file</h2>
<p><strong>syntax:</strong> <em>access_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>access tail</em></p>
<p>Equivalent to <a href="#access_by_lua_block">access_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or,
as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variables can be used in the
<code>&lt;path-to-lua-script-file&gt;</code> string to provide
flexibility. This however carries some risks and is not ordinarily
recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is
loaded once at the first request and cached and the Nginx config must be
reloaded each time the Lua source file is modified. The Lua code cache
can be temporarily disabled during development by switching <a
href="#lua_code_cache">lua_code_cache</a> <code>off</code> in
<code>nginx.conf</code> to avoid repeatedly reloading Nginx.</p>
<p>Nginx variables are supported in the file path for dynamic dispatch
just as in <a href="#content_by_lua_file">content_by_lua_file</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="header_filter_by_lua">header_filter_by_lua</h2>
<p><strong>syntax:</strong> <em>header_filter_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>output-header-filter</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#header_filter_by_lua_block">header_filter_by_lua_block</a>
directive instead.</p>
<p>Similar to the <a
href="#header_filter_by_lua_block">header_filter_by_lua_block</a>
directive, but accepts the Lua source directly in an Nginx string
literal (which requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 header_filter_by_lua &#39;
     ngx.header[&quot;content-length&quot;] = nil
 &#39;;</code></pre>
<p>This directive was first introduced in the <code>v0.2.1rc20</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="header_filter_by_lua_block">header_filter_by_lua_block</h2>
<p><strong>syntax:</strong> <em>header_filter_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>output-header-filter</em></p>
<p>Uses Lua code specified in <code>{ lua-script }</code> to define an
output header filter.</p>
<p>Note that the following API functions are currently disabled within
this context:</p>
<ul>
<li>Output API functions (e.g., <a href="#ngxsay">ngx.say</a> and <a
href="#ngxsend_headers">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="#ngxredirect">ngx.redirect</a>
and <a href="#ngxexec">ngx.exec</a>)</li>
<li>Subrequest API functions (e.g., <a
href="#ngxlocationcapture">ngx.location.capture</a> and <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a
href="#ngxsockettcp">ngx.socket.tcp</a> and <a
href="#ngxreqsocket">ngx.req.socket</a>).</li>
</ul>
<p>Here is an example of overriding a response header (or adding one if
absent) in our Lua header filter:</p>
<pre class="nginx"><code>
 location / {
     proxy_pass http://mybackend;
     header_filter_by_lua_block {
         ngx.header.Foo = &quot;blah&quot;
     }
 }</code></pre>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="header_filter_by_lua_file">header_filter_by_lua_file</h2>
<p><strong>syntax:</strong> <em>header_filter_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>output-header-filter</em></p>
<p>Equivalent to <a
href="#header_filter_by_lua_block">header_filter_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or
as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.2.1rc20</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="body_filter_by_lua">body_filter_by_lua</h2>
<p><strong>syntax:</strong> <em>body_filter_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>output-body-filter</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#body_filter_by_lua_block">body_filter_by_lua_block</a> directive
instead.</p>
<p>Similar to the <a
href="#body_filter_by_lua_block">body_filter_by_lua_block</a> directive,
but accepts the Lua source directly in an Nginx string literal (which
requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 body_filter_by_lua &#39;
     local data, eof = ngx.arg[1], ngx.arg[2]
 &#39;;</code></pre>
<p>This directive was first introduced in the <code>v0.5.0rc32</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="body_filter_by_lua_block">body_filter_by_lua_block</h2>
<p><strong>syntax:</strong> <em>body_filter_by_lua_block {
lua-script-str }</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>output-body-filter</em></p>
<p>Uses Lua code specified in <code>{ lua-script }</code> to define an
output body filter.</p>
<p>The input data chunk is passed via <a href="#ngxarg">ngx.arg</a>[1]
(as a Lua string value) and the “eof” flag indicating the end of the
response body data stream is passed via <a href="#ngxarg">ngx.arg</a>[2]
(as a Lua boolean value).</p>
<p>Behind the scene, the “eof” flag is just the <code>last_buf</code>
(for main requests) or <code>last_in_chain</code> (for subrequests) flag
of the Nginx chain link buffers. (Before the <code>v0.7.14</code>
release, the “eof” flag does not work at all in subrequests.)</p>
<p>The output data stream can be aborted immediately by running the
following Lua statement:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> <span class="va">ngx</span><span class="op">.</span><span class="cn">ERROR</span></span></code></pre></div>
<p>This will truncate the response body and usually result in incomplete
and also invalid responses.</p>
<p>The Lua code can pass its own modified version of the input data
chunk to the downstream Nginx output body filters by overriding <a
href="#ngxarg">ngx.arg</a>[1] with a Lua string or a Lua table of
strings. For example, to transform all the lowercase letters in the
response body, we can just write:</p>
<pre class="nginx"><code>
 location / {
     proxy_pass http://mybackend;
     body_filter_by_lua_block {
         ngx.arg[1] = string.upper(ngx.arg[1])
     }
 }</code></pre>
<p>When setting <code>nil</code> or an empty Lua string value to
<code>ngx.arg[1]</code>, no data chunk will be passed to the downstream
Nginx output filters at all.</p>
<p>Likewise, new “eof” flag can also be specified by setting a boolean
value to <a href="#ngxarg">ngx.arg</a>[2]. For example,</p>
<pre class="nginx"><code>
 location /t {
     echo hello world;
     echo hiya globe;

     body_filter_by_lua_block {
         local chunk = ngx.arg[1]
         if string.match(chunk, &quot;hello&quot;) then
             ngx.arg[2] = true  -- new eof
             return
         end

         -- just throw away any remaining chunk data
         ngx.arg[1] = nil
     }
 }</code></pre>
<p>Then <code>GET /t</code> will just return the output</p>
<pre><code>hello world</code></pre>
<p>That is, when the body filter sees a chunk containing the word
“hello”, then it will set the “eof” flag to true immediately, resulting
in truncated but still valid responses.</p>
<p>When the Lua code may change the length of the response body, then it
is required to always clear out the <code>Content-Length</code> response
header (if any) in a header filter to enforce streaming output, as
in</p>
<pre class="nginx"><code>
 location /foo {
     # fastcgi_pass/proxy_pass/...

     header_filter_by_lua_block {
         ngx.header.content_length = nil
     }
     body_filter_by_lua_block {
         ngx.arg[1] = string.len(ngx.arg[1]) .. &quot;\n&quot;
     }
 }</code></pre>
<p>Note that the following API functions are currently disabled within
this context due to the limitations in Nginx output filter’s current
implementation:</p>
<ul>
<li>Output API functions (e.g., <a href="#ngxsay">ngx.say</a> and <a
href="#ngxsend_headers">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="#ngxexit">ngx.exit</a> and <a
href="#ngxexec">ngx.exec</a>)</li>
<li>Subrequest API functions (e.g., <a
href="#ngxlocationcapture">ngx.location.capture</a> and <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a
href="#ngxsockettcp">ngx.socket.tcp</a> and <a
href="#ngxreqsocket">ngx.req.socket</a>).</li>
</ul>
<p>Nginx output filters may be called multiple times for a single
request because response body may be delivered in chunks. Thus, the Lua
code specified by in this directive may also run multiple times in the
lifetime of a single HTTP request.</p>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="body_filter_by_lua_file">body_filter_by_lua_file</h2>
<p><strong>syntax:</strong> <em>body_filter_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>output-body-filter</em></p>
<p>Equivalent to <a
href="#body_filter_by_lua_block">body_filter_by_lua_block</a>, except
that the file specified by <code>&lt;path-to-lua-script-file&gt;</code>
contains the Lua code, or, as from the <code>v0.5.0rc32</code> release,
the <a href="#luajit-bytecode-support">LuaJIT bytecode</a> to be
executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.5.0rc32</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="log_by_lua">log_by_lua</h2>
<p><strong>syntax:</strong> <em>log_by_lua
&lt;lua-script-str&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>log</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em>
following the <code>v0.9.17</code> release. Use the <a
href="#log_by_lua_block">log_by_lua_block</a> directive instead.</p>
<p>Similar to the <a href="#log_by_lua_block">log_by_lua_block</a>
directive, but accepts the Lua source directly in an Nginx string
literal (which requires special character escaping).</p>
<p>For instance,</p>
<pre class="nginx"><code>
 log_by_lua &#39;
     print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)
 &#39;;</code></pre>
<p>This directive was first introduced in the <code>v0.5.0rc31</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="log_by_lua_block">log_by_lua_block</h2>
<p><strong>syntax:</strong> <em>log_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>log</em></p>
<p>Runs the Lua source code inlined as the <code>{ lua-script }</code>
at the <code>log</code> request processing phase. This does not replace
the current access logs, but runs before.</p>
<p>Note that the following API functions are currently disabled within
this context:</p>
<ul>
<li>Output API functions (e.g., <a href="#ngxsay">ngx.say</a> and <a
href="#ngxsend_headers">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="#ngxexit">ngx.exit</a>)</li>
<li>Subrequest API functions (e.g., <a
href="#ngxlocationcapture">ngx.location.capture</a> and <a
href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a
href="#ngxsockettcp">ngx.socket.tcp</a> and <a
href="#ngxreqsocket">ngx.req.socket</a>).</li>
</ul>
<p>Here is an example of gathering average data for <a
href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time">$upstream_response_time</a>:</p>
<pre class="nginx"><code>
 lua_shared_dict log_dict 5M;

 server {
     location / {
         proxy_pass http://mybackend;

         log_by_lua_block {
             local log_dict = ngx.shared.log_dict
             local upstream_time = tonumber(ngx.var.upstream_response_time)

             local sum = log_dict:get(&quot;upstream_time-sum&quot;) or 0
             sum = sum + upstream_time
             log_dict:set(&quot;upstream_time-sum&quot;, sum)

             local newval, err = log_dict:incr(&quot;upstream_time-nb&quot;, 1)
             if not newval and err == &quot;not found&quot; then
                 log_dict:add(&quot;upstream_time-nb&quot;, 0)
                 log_dict:incr(&quot;upstream_time-nb&quot;, 1)
             end
         }
     }

     location = /status {
         content_by_lua_block {
             local log_dict = ngx.shared.log_dict
             local sum = log_dict:get(&quot;upstream_time-sum&quot;)
             local nb = log_dict:get(&quot;upstream_time-nb&quot;)

             if nb and sum then
                 ngx.say(&quot;average upstream response time: &quot;, sum / nb,
                         &quot; (&quot;, nb, &quot; reqs)&quot;)
             else
                 ngx.say(&quot;no data yet&quot;)
             end
         }
     }
 }</code></pre>
<p>This directive was first introduced in the <code>v0.9.17</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="log_by_lua_file">log_by_lua_file</h2>
<p><strong>syntax:</strong> <em>log_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>log</em></p>
<p>Equivalent to <a href="#log_by_lua_block">log_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or,
as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.5.0rc31</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="balancer_by_lua_block">balancer_by_lua_block</h2>
<p><strong>syntax:</strong> <em>balancer_by_lua_block { lua-script
}</em></p>
<p><strong>context:</strong> <em>upstream</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>This directive runs Lua code as an upstream balancer for any upstream
entities defined by the <code>upstream {}</code> configuration
block.</p>
<p>For instance,</p>
<pre class="nginx"><code>
 upstream foo {
     server 127.0.0.1;
     balancer_by_lua_block {
         -- use Lua to do something interesting here
         -- as a dynamic balancer
     }
 }

 server {
     location / {
         proxy_pass http://foo;
     }
 }</code></pre>
<p>The resulting Lua load balancer can work with any existing Nginx
upstream modules like <a
href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_proxy</a>
and <a
href="https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">ngx_fastcgi</a>.</p>
<p>Also, the Lua load balancer can work with the standard upstream
connection pool mechanism, i.e., the standard <a
href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">keepalive</a>
directive. Just ensure that the <a
href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">keepalive</a>
directive is used <em>after</em> this <code>balancer_by_lua_block</code>
directive in a single <code>upstream {}</code> configuration block.</p>
<p>The Lua load balancer can totally ignore the list of servers defined
in the <code>upstream {}</code> block and select peer from a completely
dynamic server list (even changing per request) via the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md">ngx.balancer</a>
module from the <a
href="https://github.com/openresty/lua-resty-core">lua-resty-core</a>
library.</p>
<p>The Lua code handler registered by this directive might get called
more than once in a single downstream request when the Nginx upstream
mechanism retries the request on conditions specified by directives like
the <a
href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a>
directive.</p>
<p>This Lua code execution context does not support yielding, so Lua
APIs that may yield (like cosockets and “light threads”) are disabled in
this context. One can usually work around this limitation by doing such
operations in an earlier phase handler (like <a
href="#access_by_lua">access_by_lua*</a>) and passing along the result
into this context via the <a href="#ngxctx">ngx.ctx</a> table.</p>
<p>This directive was first introduced in the <code>v0.10.0</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="balancer_by_lua_file">balancer_by_lua_file</h2>
<p><strong>syntax:</strong> <em>balancer_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>upstream</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>Equivalent to <a
href="#balancer_by_lua_block">balancer_by_lua_block</a>, except that the
file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains
the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.0</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="balancer_keepalive">balancer_keepalive</h2>
<p><strong>syntax:</strong> <em>balancer_keepalive
&lt;total-connections&gt;</em></p>
<p><strong>context:</strong> <em>upstream</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p>The <code>total-connections</code> parameter sets the maximum number
of idle keepalive connections to upstream servers that are preserved in
the cache of each worker process. When this number is exceeded, the
least recently used connections are closed.</p>
<p>It should be particularly noted that the keepalive directive does not
limit the total number of connections to upstream servers that an nginx
worker process can open. The connections parameter should be set to a
number small enough to let upstream servers process new incoming
connections as well.</p>
<p>This directive was first introduced in the <code>v0.10.21</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_need_request_body">lua_need_request_body</h2>
<p><strong>syntax:</strong> <em>lua_need_request_body
&lt;on|off&gt;</em></p>
<p><strong>default:</strong> <em>off</em></p>
<p><strong>context:</strong> <em>http, server, location, location
if</em></p>
<p><strong>phase:</strong> <em>depends on usage</em></p>
<p>Determines whether to force the request body data to be read before
running rewrite/access/content_by_lua* or not. The Nginx core does not
read the client request body by default and if request body data is
required, then this directive should be turned <code>on</code> or the <a
href="#ngxreqread_body">ngx.req.read_body</a> function should be called
within the Lua code.</p>
<p>To read the request body data within the <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body"><span
class="math inline">$request_body](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body)
variable,
[client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size)
must have the same value as
[client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size).
Because when the content length exceeds
[client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size)
but less than
[client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size),
Nginx will buffer the data into a temporary file on the disk, which will
lead to empty value in the [$</span>request_body</a> variable.</p>
<p>If the current location includes <a
href="#rewrite_by_lua">rewrite_by_lua*</a> directives, then the request
body will be read just before the <a
href="#rewrite_by_lua">rewrite_by_lua*</a> code is run (and also at the
<code>rewrite</code> phase). Similarly, if only <a
href="#content_by_lua">content_by_lua</a> is specified, the request body
will not be read until the content handler’s Lua code is about to run
(i.e., the request body will be read during the content phase).</p>
<p>It is recommended however, to use the <a
href="#ngxreqread_body">ngx.req.read_body</a> and <a
href="#ngxreqdiscard_body">ngx.req.discard_body</a> functions for finer
control over the request body reading process instead.</p>
<p>This also applies to <a href="#access_by_lua">access_by_lua*</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="ssl_client_hello_by_lua_block">ssl_client_hello_by_lua_block</h2>
<p><strong>syntax:</strong> <em>ssl_client_hello_by_lua_block {
lua-script }</em></p>
<p><strong>context:</strong> <em>http, server</em></p>
<p><strong>phase:</strong>
<em>right-after-client-hello-message-was-processed</em></p>
<p>This directive runs user Lua code when Nginx is about to post-process
the SSL client hello message for the downstream SSL (https)
connections.</p>
<p>It is particularly useful for dynamically setting the SSL protocols
according to the SNI.</p>
<p>It is also useful to do some custom operations according to the
per-connection information in the client hello message.</p>
<p>For example, one can parse custom client hello extension and do the
corresponding handling in pure Lua.</p>
<p>This Lua handler will always run whether the SSL session is resumed
(via SSL session IDs or TLS session tickets) or not. While the
<code>ssl_certificate_by_lua*</code> Lua handler will only runs when
initiating a full SSL handshake.</p>
<p>The <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/clienthello.md">ngx.ssl.clienthello</a>
Lua modules provided by the <a
href="https://github.com/openresty/lua-resty-core/#readme">lua-resty-core</a>
library are particularly useful in this context.</p>
<p>Note that this handler runs in extremely early stage of SSL
handshake, before the SSL client hello extensions are parsed. So you can
not use some Lua API like <code>ssl.server_name()</code> which is
dependent on the later stage’s processing.</p>
<p>Also note that only the directive in default server is valid for
several virtual servers with the same IP address and port.</p>
<p>Below is a trivial example using the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/clienthello.md">ngx.ssl.clienthello</a>
module at the same time:</p>
<pre class="nginx"><code>
 server {
     listen 443 ssl;
     server_name   test.com;
     ssl_certificate /path/to/cert.crt;
     ssl_certificate_key /path/to/key.key;
     ssl_client_hello_by_lua_block {
         local ssl_clt = require &quot;ngx.ssl.clienthello&quot;
         local host, err = ssl_clt.get_client_hello_server_name()
         if host == &quot;test.com&quot; then
             ssl_clt.set_protocols({&quot;TLSv1&quot;, &quot;TLSv1.1&quot;})
         elseif host == &quot;test2.com&quot; then
             ssl_clt.set_protocols({&quot;TLSv1.2&quot;, &quot;TLSv1.3&quot;})
         elseif not host then
             ngx.log(ngx.ERR, &quot;failed to get the SNI name: &quot;, err)
             ngx.exit(ngx.ERROR)
         else
             ngx.log(ngx.ERR, &quot;unknown SNI name: &quot;, host)
             ngx.exit(ngx.ERROR)
         end
     }
     ...
 }
 server {
     listen 443 ssl;
     server_name   test2.com;
     ssl_certificate /path/to/cert.crt;
     ssl_certificate_key /path/to/key.key;
     ...
 }</code></pre>
<p>See more information in the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/clienthello.md">ngx.ssl.clienthello</a>
Lua modules’ official documentation.</p>
<p>Uncaught Lua exceptions in the user Lua code immediately abort the
current SSL session, so does the <a href="#ngxexit">ngx.exit</a> call
with an error code like <code>ngx.ERROR</code>.</p>
<p>This Lua code execution context <em>does</em> support yielding, so
Lua APIs that may yield (like cosockets, sleeping, and “light threads”)
are enabled in this context</p>
<p>Note, you need to configure the <a
href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate">ssl_certificate</a>
and <a
href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a>
to avoid the following error while starting NGINX:</p>
<pre><code>nginx: [emerg] no ssl configured for the server</code></pre>
<p>This directive requires OpenSSL 1.1.1 or greater.</p>
<p>If you are using the <a
href="https://openresty.org/en/linux-packages.html">official pre-built
packages</a> for <a href="https://openresty.org/">OpenResty</a> 1.21.4.1
or later, then everything should work out of the box.</p>
<p>If you are not using the Nginx core shipped with <a
href="https://openresty.org">OpenResty</a> 1.21.4.1 or later, you will
need to apply patches to the standard Nginx core:</p>
<p><a href="https://openresty.org/en/nginx-ssl-patches.html"
class="uri">https://openresty.org/en/nginx-ssl-patches.html</a></p>
<p>This directive was first introduced in the <code>v0.10.21</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="ssl_client_hello_by_lua_file">ssl_client_hello_by_lua_file</h2>
<p><strong>syntax:</strong> <em>ssl_client_hello_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http, server</em></p>
<p><strong>phase:</strong>
<em>right-after-client-hello-message-was-processed</em></p>
<p>Equivalent to <a
href="#ssl_client_hello_by_lua_block">ssl_client_hello_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or,
as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.21</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</h2>
<p><strong>syntax:</strong> <em>ssl_certificate_by_lua_block {
lua-script }</em></p>
<p><strong>context:</strong> <em>server</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>This directive runs user Lua code when Nginx is about to start the
SSL handshake for the downstream SSL (https) connections.</p>
<p>It is particularly useful for setting the SSL certificate chain and
the corresponding private key on a per-request basis. It is also useful
to load such handshake configurations nonblockingly from the remote (for
example, with the <a href="#ngxsockettcp">cosocket</a> API). And one can
also do per-request OCSP stapling handling in pure Lua here as well.</p>
<p>Another typical use case is to do SSL handshake traffic control
nonblockingly in this context, with the help of the <a
href="https://github.com/openresty/lua-resty-limit-traffic">lua-resty-limit-traffic#readme</a>
library, for example.</p>
<p>One can also do interesting things with the SSL handshake requests
from the client side, like rejecting old SSL clients using the SSLv3
protocol or even below selectively.</p>
<p>The <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md">ngx.ssl</a>
and <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md">ngx.ocsp</a>
Lua modules provided by the <a
href="https://github.com/openresty/lua-resty-core/#readme">lua-resty-core</a>
library are particularly useful in this context. You can use the Lua API
offered by these two Lua modules to manipulate the SSL certificate chain
and private key for the current SSL connection being initiated.</p>
<p>This Lua handler does not run at all, however, when Nginx/OpenSSL
successfully resumes the SSL session via SSL session IDs or TLS session
tickets for the current SSL connection. In other words, this Lua handler
only runs when Nginx has to initiate a full SSL handshake.</p>
<p>Below is a trivial example using the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md">ngx.ssl</a>
module at the same time:</p>
<pre class="nginx"><code>
 server {
     listen 443 ssl;
     server_name   test.com;

     ssl_certificate_by_lua_block {
         print(&quot;About to initiate a new SSL handshake!&quot;)
     }

     location / {
         root html;
     }
 }</code></pre>
<p>See more complicated examples in the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md">ngx.ssl</a>
and <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md">ngx.ocsp</a>
Lua modules’ official documentation.</p>
<p>Uncaught Lua exceptions in the user Lua code immediately abort the
current SSL session, so does the <a href="#ngxexit">ngx.exit</a> call
with an error code like <code>ngx.ERROR</code>.</p>
<p>This Lua code execution context <em>does</em> support yielding, so
Lua APIs that may yield (like cosockets, sleeping, and “light threads”)
are enabled in this context.</p>
<p>Note, however, you still need to configure the <a
href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate">ssl_certificate</a>
and <a
href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key">ssl_certificate_key</a>
directives even though you will not use this static certificate and
private key at all. This is because the NGINX core requires their
appearance otherwise you are seeing the following error while starting
NGINX:</p>
<pre><code>nginx: [emerg] no ssl configured for the server</code></pre>
<p>This directive requires OpenSSL 1.0.2e or greater.</p>
<p>If you are using the <a
href="https://openresty.org/en/linux-packages.html">official pre-built
packages</a> for <a href="https://openresty.org/">OpenResty</a> 1.9.7.2
or later, then everything should work out of the box.</p>
<p>If you are not using the Nginx core shipped with <a
href="https://openresty.org">OpenResty</a> 1.9.7.2 or later, you will
need to apply patches to the standard Nginx core:</p>
<p><a href="https://openresty.org/en/nginx-ssl-patches.html"
class="uri">https://openresty.org/en/nginx-ssl-patches.html</a></p>
<p>This directive was first introduced in the <code>v0.10.0</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</h2>
<p><strong>syntax:</strong> <em>ssl_certificate_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>server</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>Equivalent to <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or,
as from the <code>v0.5.0rc32</code> release, the <a
href="#luajit-bytecode-support">LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.0</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</h2>
<p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_block {
lua-script }</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>This directive runs Lua code to look up and load the SSL session (if
any) according to the session ID provided by the current SSL handshake
request for the downstream.</p>
<p>The Lua API for obtaining the current session ID and loading a cached
SSL session data is provided in the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md">ngx.ssl.session</a>
Lua module shipped with the <a
href="https://github.com/openresty/lua-resty-core#readme">lua-resty-core</a>
library.</p>
<p>Lua APIs that may yield, like <a href="#ngxsleep">ngx.sleep</a> and
<a href="#ngxsockettcp">cosockets</a>, are enabled in this context.</p>
<p>This hook, together with the <a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua*</a>
hook, can be used to implement distributed caching mechanisms in pure
Lua (based on the <a href="#ngxsockettcp">cosocket</a> API, for
example). If a cached SSL session is found and loaded into the current
SSL connection context, SSL session resumption can then get immediately
initiated and bypass the full SSL handshake process which is very
expensive in terms of CPU time.</p>
<p>Please note that TLS session tickets are very different and it is the
clients’ responsibility to cache the SSL session state when session
tickets are used. SSL session resumptions based on TLS session tickets
would happen automatically without going through this hook (nor the <a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua*</a>
hook). This hook is mainly for older or less capable SSL clients that
can only do SSL sessions by session IDs.</p>
<p>When <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua*</a> is
specified at the same time, this hook usually runs before <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua*</a>. When
the SSL session is found and successfully loaded for the current SSL
connection, SSL session resumption will happen and thus bypass the <a
href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua*</a> hook
completely. In this case, Nginx also bypasses the <a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua*</a>
hook, for obvious reasons.</p>
<p>To easily test this hook locally with a modern web browser, you can
temporarily put the following line in your https server block to disable
the TLS session ticket support:</p>
<pre><code>ssl_session_tickets off;</code></pre>
<p>But do not forget to comment this line out before publishing your
site to the world.</p>
<p>If you are using the <a
href="https://openresty.org/en/linux-packages.html">official pre-built
packages</a> for <a href="https://openresty.org/">OpenResty</a> 1.11.2.1
or later, then everything should work out of the box.</p>
<p>If you are not using one of the <a
href="https://openresty.org/en/linux-packages.html">OpenSSL packages</a>
provided by <a href="https://openresty.org">OpenResty</a>, you will need
to apply patches to OpenSSL in order to use this directive:</p>
<p><a href="https://openresty.org/en/openssl-patches.html"
class="uri">https://openresty.org/en/openssl-patches.html</a></p>
<p>Similarly, if you are not using the Nginx core shipped with <a
href="https://openresty.org">OpenResty</a> 1.11.2.1 or later, you will
need to apply patches to the standard Nginx core:</p>
<p><a href="https://openresty.org/en/nginx-ssl-patches.html"
class="uri">https://openresty.org/en/nginx-ssl-patches.html</a></p>
<p>This directive was first introduced in the <code>v0.10.6</code>
release.</p>
<p>Note that this directive can only be used in the <strong>http
context</strong> starting with the <code>v0.10.7</code> release since
SSL session resumption happens before server name dispatch.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</h2>
<p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>Equivalent to <a
href="#ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or
rather, the <a href="#luajit-bytecode-support">LuaJIT bytecode</a> to be
executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.6</code>
release.</p>
<p>Note that: this directive is only allowed to used in <strong>http
context</strong> from the <code>v0.10.7</code> release (because SSL
session resumption happens before server name dispatch).</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</h2>
<p><strong>syntax:</strong> <em>ssl_session_store_by_lua_block {
lua-script }</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p>
<p>This directive runs Lua code to fetch and save the SSL session (if
any) according to the session ID provided by the current SSL handshake
request for the downstream. The saved or cached SSL session data can be
used for future SSL connections to resume SSL sessions without going
through the full SSL handshake process (which is very expensive in terms
of CPU time).</p>
<p>Lua APIs that may yield, like <a href="#ngxsleep">ngx.sleep</a> and
<a href="#ngxsockettcp">cosockets</a>, are <em>disabled</em> in this
context. You can still, however, use the <a
href="#ngxtimerat">ngx.timer.at</a> API to create 0-delay timers to save
the SSL session data asynchronously to external services (like
<code>redis</code> or <code>memcached</code>).</p>
<p>The Lua API for obtaining the current session ID and the associated
session state data is provided in the <a
href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme">ngx.ssl.session</a>
Lua module shipped with the <a
href="https://github.com/openresty/lua-resty-core#readme">lua-resty-core</a>
library.</p>
<p>To easily test this hook locally with a modern web browser, you can
temporarily put the following line in your https server block to disable
the TLS session ticket support:</p>
<pre><code>ssl_session_tickets off;</code></pre>
<p>But do not forget to comment this line out before publishing your
site to the world.</p>
<p>This directive was first introduced in the <code>v0.10.6</code>
release.</p>
<p>Note that: this directive is only allowed to used in <strong>http
context</strong> from the <code>v0.10.7</code> release (because SSL
session resumption happens before server name dispatch).</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</h2>
<p><strong>syntax:</strong> <em>ssl_session_store_by_lua_file
&lt;path-to-lua-script-file&gt;</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p>
<p>Equivalent to <a
href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</a>,
except that the file specified by
<code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or
rather, the <a href="#luajit-bytecode-support">LuaJIT bytecode</a> to be
executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they
will be turned into the absolute path relative to the
<code>server prefix</code> path determined by the <code>-p PATH</code>
command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.6</code>
release.</p>
<p>Note that: this directive is only allowed to used in <strong>http
context</strong> from the <code>v0.10.7</code> release (because SSL
session resumption happens before server name dispatch).</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_shared_dict">lua_shared_dict</h2>
<p><strong>syntax:</strong> <em>lua_shared_dict &lt;name&gt;
&lt;size&gt;</em></p>
<p><strong>default:</strong> <em>no</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>depends on usage</em></p>
<p>Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as
storage for the shm based Lua dictionary
<code>ngx.shared.&lt;name&gt;</code>.</p>
<p>Shared memory zones are always shared by all the Nginx worker
processes in the current Nginx server instance.</p>
<p>The <code>&lt;size&gt;</code> argument accepts size units such as
<code>k</code> and <code>m</code>:</p>
<pre class="nginx"><code>
 http {
     lua_shared_dict dogs 10m;
     ...
 }</code></pre>
<p>The hard-coded minimum size is 8KB while the practical minimum size
depends on actual user data set (some people start with 12KB).</p>
<p>See <a href="#ngxshareddict">ngx.shared.DICT</a> for details.</p>
<p>This directive was first introduced in the <code>v0.3.1rc22</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_connect_timeout">lua_socket_connect_timeout</h2>
<p><strong>syntax:</strong> <em>lua_socket_connect_timeout
&lt;time&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_connect_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>This directive controls the default timeout value used in
TCP/unix-domain socket object’s <a href="#tcpsockconnect">connect</a>
method and can be overridden by the <a
href="#tcpsocksettimeout">settimeout</a> or <a
href="#tcpsocksettimeouts">settimeouts</a> methods.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an
optional time unit, like <code>s</code> (second), <code>ms</code>
(millisecond), <code>m</code> (minute). The default time unit is
<code>s</code>, i.e., “second”. The default setting is
<code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_send_timeout">lua_socket_send_timeout</h2>
<p><strong>syntax:</strong> <em>lua_socket_send_timeout
&lt;time&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_send_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Controls the default timeout value used in TCP/unix-domain socket
object’s <a href="#tcpsocksend">send</a> method and can be overridden by
the <a href="#tcpsocksettimeout">settimeout</a> or <a
href="#tcpsocksettimeouts">settimeouts</a> methods.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an
optional time unit, like <code>s</code> (second), <code>ms</code>
(millisecond), <code>m</code> (minute). The default time unit is
<code>s</code>, i.e., “second”. The default setting is
<code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_send_lowat">lua_socket_send_lowat</h2>
<p><strong>syntax:</strong> <em>lua_socket_send_lowat
&lt;size&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_send_lowat 0</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Controls the <code>lowat</code> (low water) value for the cosocket
send buffer.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_read_timeout">lua_socket_read_timeout</h2>
<p><strong>syntax:</strong> <em>lua_socket_read_timeout
&lt;time&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_read_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p><strong>phase:</strong> <em>depends on usage</em></p>
<p>This directive controls the default timeout value used in
TCP/unix-domain socket object’s <a href="#tcpsockreceive">receive</a>
method and iterator functions returned by the <a
href="#tcpsockreceiveuntil">receiveuntil</a> method. This setting can be
overridden by the <a href="#tcpsocksettimeout">settimeout</a> or <a
href="#tcpsocksettimeouts">settimeouts</a> methods.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an
optional time unit, like <code>s</code> (second), <code>ms</code>
(millisecond), <code>m</code> (minute). The default time unit is
<code>s</code>, i.e., “second”. The default setting is
<code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_buffer_size">lua_socket_buffer_size</h2>
<p><strong>syntax:</strong> <em>lua_socket_buffer_size
&lt;size&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_buffer_size 4k/8k</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the buffer size used by cosocket reading operations.</p>
<p>This buffer does not have to be that big to hold everything at the
same time because cosocket supports 100% non-buffered reading and
parsing. So even <code>1</code> byte buffer size should still work
everywhere but the performance could be terrible.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_pool_size">lua_socket_pool_size</h2>
<p><strong>syntax:</strong> <em>lua_socket_pool_size
&lt;size&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_pool_size 30</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the size limit (in terms of connection count) for every
cosocket connection pool associated with every remote server (i.e.,
identified by either the host-port pair or the unix domain socket file
path).</p>
<p>Default to 30 connections for every pool.</p>
<p>When the connection pool exceeds the available size limit, the least
recently used (idle) connection already in the pool will be closed to
make room for the current connection.</p>
<p>Note that the cosocket connection pool is per Nginx worker process
rather than per Nginx server instance, so size limit specified here also
applies to every single Nginx worker process.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</h2>
<p><strong>syntax:</strong> <em>lua_socket_keepalive_timeout
&lt;time&gt;</em></p>
<p><strong>default:</strong> <em>lua_socket_keepalive_timeout
60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>This directive controls the default maximal idle time of the
connections in the cosocket built-in connection pool. When this timeout
reaches, idle connections will be closed and removed from the pool. This
setting can be overridden by cosocket objects’ <a
href="#tcpsocksetkeepalive">setkeepalive</a> method.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an
optional time unit, like <code>s</code> (second), <code>ms</code>
(millisecond), <code>m</code> (minute). The default time unit is
<code>s</code>, i.e., “second”. The default setting is
<code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_socket_log_errors">lua_socket_log_errors</h2>
<p><strong>syntax:</strong> <em>lua_socket_log_errors on|off</em></p>
<p><strong>default:</strong> <em>lua_socket_log_errors on</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>This directive can be used to toggle error logging when a failure
occurs for the TCP or UDP cosockets. If you are already doing proper
error handling and logging in your Lua code, then it is recommended to
turn this directive off to prevent data flushing in your Nginx error log
files (which is usually rather expensive).</p>
<p>This directive was first introduced in the <code>v0.5.13</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_ciphers">lua_ssl_ciphers</h2>
<p><strong>syntax:</strong> <em>lua_ssl_ciphers &lt;ciphers&gt;</em></p>
<p><strong>default:</strong> <em>lua_ssl_ciphers DEFAULT</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the enabled ciphers for requests to a SSL/TLS server in the
<a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a> method. The
ciphers are specified in the format understood by the OpenSSL
library.</p>
<p>The full list can be viewed using the “openssl ciphers” command.</p>
<p>This directive was first introduced in the <code>v0.9.11</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_crl">lua_ssl_crl</h2>
<p><strong>syntax:</strong> <em>lua_ssl_crl &lt;file&gt;</em></p>
<p><strong>default:</strong> <em>no</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies a file with revoked certificates (CRL) in the PEM format
used to verify the certificate of the SSL/TLS server in the <a
href="#tcpsocksslhandshake">tcpsock:sslhandshake</a> method.</p>
<p>This directive was first introduced in the <code>v0.9.11</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_protocols">lua_ssl_protocols</h2>
<p><strong>syntax:</strong> <em>lua_ssl_protocols [SSLv2] [SSLv3]
[TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</em></p>
<p><strong>default:</strong> <em>lua_ssl_protocols TLSv1 TLSv1.1 TLSv1.2
TLSv1.3</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Enables the specified protocols for requests to a SSL/TLS server in
the <a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a> method.</p>
<p>The support for the <code>TLSv1.3</code> parameter requires version
<code>v0.10.12</code> <em>and</em> OpenSSL 1.1.1. From version v0.10.25,
the default value change from <code>SSLV3 TLSv1 TLSv1.1 TLSv1.2</code>
to <code>TLSv1 TLSv1.1 TLSv1.2 TLSv1.3</code>.</p>
<p>This directive was first introduced in the <code>v0.9.11</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_certificate">lua_ssl_certificate</h2>
<p><strong>syntax:</strong> <em>lua_ssl_certificate
&lt;file&gt;</em></p>
<p><strong>default:</strong> <em>none</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the file path to the SSL/TLS certificate in PEM format used
for the <a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a>
method.</p>
<p>This directive allows you to specify the SSL/TLS certificate that
will be presented to server during the SSL/TLS handshake process.</p>
<p>This directive was first introduced in the <code>v0.10.26</code>
release.</p>
<p>See also <a
href="#lua_ssl_certificate_key">lua_ssl_certificate_key</a> and <a
href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_certificate_key">lua_ssl_certificate_key</h2>
<p><strong>syntax:</strong> <em>lua_ssl_certificate_key
&lt;file&gt;</em></p>
<p><strong>default:</strong> <em>none</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the file path to the private key associated with the
SSL/TLS certificate used in the <a
href="#tcpsocksslhandshake">tcpsock:sslhandshake</a> method.</p>
<p>This directive allows you to specify the private key file
corresponding to the SSL/TLS certificate specified by
lua_ssl_certificate. The private key should be in PEM format and must
match the certificate.</p>
<p>This directive was first introduced in the <code>v0.10.26</code>
release.</p>
<p>See also <a href="#lua_ssl_certificate">lua_ssl_certificate</a> and
<a href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</h2>
<p><strong>syntax:</strong> <em>lua_ssl_trusted_certificate
&lt;file&gt;</em></p>
<p><strong>default:</strong> <em>none</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies a file path with trusted CA certificates in the PEM format
used to verify the certificate of the SSL/TLS server in the <a
href="#tcpsocksslhandshake">tcpsock:sslhandshake</a> method.</p>
<p>This directive was first introduced in the <code>v0.9.11</code>
release.</p>
<p>See also <a
href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_verify_depth">lua_ssl_verify_depth</h2>
<p><strong>syntax:</strong> <em>lua_ssl_verify_depth
&lt;number&gt;</em></p>
<p><strong>default:</strong> <em>lua_ssl_verify_depth 1</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Sets the verification depth in the server certificates chain.</p>
<p>This directive was first introduced in the <code>v0.9.11</code>
release.</p>
<p>See also <a href="#lua_ssl_certificate">lua_ssl_certificate</a>, <a
href="#lua_ssl_certificate_key">lua_ssl_certificate_key</a> and <a
href="#lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_ssl_conf_command">lua_ssl_conf_command</h2>
<p><strong>syntax:</strong> <em>lua_ssl_conf_command
&lt;command&gt;</em></p>
<p><strong>default:</strong> <em>no</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Sets arbitrary OpenSSL configuration <a
href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CONF_cmd.html">commands</a>.</p>
<p>The directive is supported when using OpenSSL 1.0.2 or higher and
nginx 1.19.4 or higher. According to the specify command, higher OpenSSL
version may be needed.</p>
<p>Several <code>lua_ssl_conf_command</code> directives can be specified
on the same level:</p>
<pre class="nginx"><code>
 lua_ssl_conf_command Options PrioritizeChaCha;
 lua_ssl_conf_command Ciphersuites TLS_CHACHA20_POLY1305_SHA256;</code></pre>
<p>Configuration commands are applied after OpenResty own configuration
for SSL, so they can be used to override anything set by OpenResty.</p>
<p>Note though that configuring OpenSSL directly with
<code>lua_ssl_conf_command</code> might result in a behaviour OpenResty
does not expect, and should be done with care.</p>
<p>This directive was first introduced in the <code>v0.10.21</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_http10_buffering">lua_http10_buffering</h2>
<p><strong>syntax:</strong> <em>lua_http10_buffering on|off</em></p>
<p><strong>default:</strong> <em>lua_http10_buffering on</em></p>
<p><strong>context:</strong> <em>http, server, location,
location-if</em></p>
<p>Enables or disables automatic response buffering for HTTP 1.0 (or
older) requests. This buffering mechanism is mainly used for HTTP 1.0
keep-alive which relies on a proper <code>Content-Length</code> response
header.</p>
<p>If the Lua code explicitly sets a <code>Content-Length</code>
response header before sending the headers (either explicitly via <a
href="#ngxsend_headers">ngx.send_headers</a> or implicitly via the first
<a href="#ngxsay">ngx.say</a> or <a href="#ngxprint">ngx.print</a>
call), then the HTTP 1.0 response buffering will be disabled even when
this directive is turned on.</p>
<p>To output very large response data in a streaming fashion (via the <a
href="#ngxflush">ngx.flush</a> call, for example), this directive MUST
be turned off to minimize memory usage.</p>
<p>This directive is turned <code>on</code> by default.</p>
<p>This directive was first introduced in the <code>v0.5.0rc19</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</h2>
<p><strong>syntax:</strong> <em>rewrite_by_lua_no_postpone
on|off</em></p>
<p><strong>default:</strong> <em>rewrite_by_lua_no_postpone off</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls whether or not to disable postponing <a
href="#rewrite_by_lua">rewrite_by_lua*</a> directives to run at the end
of the <code>rewrite</code> request-processing phase. By default, this
directive is turned off and the Lua code is postponed to run at the end
of the <code>rewrite</code> phase.</p>
<p>This directive was first introduced in the <code>v0.5.0rc29</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="access_by_lua_no_postpone">access_by_lua_no_postpone</h2>
<p><strong>syntax:</strong> <em>access_by_lua_no_postpone
on|off</em></p>
<p><strong>default:</strong> <em>access_by_lua_no_postpone off</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls whether or not to disable postponing <a
href="#access_by_lua">access_by_lua*</a> directives to run at the end of
the <code>access</code> request-processing phase. By default, this
directive is turned off and the Lua code is postponed to run at the end
of the <code>access</code> phase.</p>
<p>This directive was first introduced in the <code>v0.9.20</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</h2>
<p><strong>syntax:</strong>
<em>lua_transform_underscores_in_response_headers on|off</em></p>
<p><strong>default:</strong>
<em>lua_transform_underscores_in_response_headers on</em></p>
<p><strong>context:</strong> <em>http, server, location,
location-if</em></p>
<p>Controls whether to transform underscores (<code>_</code>) in the
response header names specified in the <a
href="#ngxheaderheader">ngx.header.HEADER</a> API to hyphens
(<code>-</code>).</p>
<p>This directive was first introduced in the <code>v0.5.0rc32</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_check_client_abort">lua_check_client_abort</h2>
<p><strong>syntax:</strong> <em>lua_check_client_abort on|off</em></p>
<p><strong>default:</strong> <em>lua_check_client_abort off</em></p>
<p><strong>context:</strong> <em>http, server, location,
location-if</em></p>
<p>This directive controls whether to check for premature client
connection abortion.</p>
<p>When this directive is on, the ngx_lua module will monitor the
premature connection close event on the downstream connections and when
there is such an event, it will call the user Lua function callback
(registered by <a href="#ngxon_abort">ngx.on_abort</a>) or just stop and
clean up all the Lua “light threads” running in the current request’s
request handler when there is no user callback function registered.</p>
<p>According to the current implementation, however, if the client
closes the connection before the Lua code finishes reading the request
body data via <a href="#ngxreqsocket">ngx.req.socket</a>, then ngx_lua
will neither stop all the running “light threads” nor call the user
callback (if <a href="#ngxon_abort">ngx.on_abort</a> has been called).
Instead, the reading operation on <a
href="#ngxreqsocket">ngx.req.socket</a> will just return the error
message “client aborted” as the second return value (the first return
value is surely <code>nil</code>).</p>
<p>When TCP keepalive is disabled, it is relying on the client side to
close the socket gracefully (by sending a <code>FIN</code> packet or
something like that). For (soft) real-time web applications, it is
highly recommended to configure the <a
href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html">TCP
keepalive</a> support in your system’s TCP stack implementation in order
to detect “half-open” TCP connections in time.</p>
<p>For example, on Linux, you can configure the standard <a
href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen">listen</a>
directive in your <code>nginx.conf</code> file like this:</p>
<pre class="nginx"><code>
 listen 80 so_keepalive=2s:2s:8;</code></pre>
<p>On FreeBSD, you can only tune the system-wide configuration for TCP
keepalive, for example:</p>
<pre><code># sysctl net.inet.tcp.keepintvl=2000
# sysctl net.inet.tcp.keepidle=2000</code></pre>
<p>This directive was first introduced in the <code>v0.7.4</code>
release.</p>
<p>See also <a href="#ngxon_abort">ngx.on_abort</a>.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_max_pending_timers">lua_max_pending_timers</h2>
<p><strong>syntax:</strong> <em>lua_max_pending_timers
&lt;count&gt;</em></p>
<p><strong>default:</strong> <em>lua_max_pending_timers 1024</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls the maximum number of pending timers allowed.</p>
<p>Pending timers are those timers that have not expired yet.</p>
<p>When exceeding this limit, the <a href="#ngxtimerat">ngx.timer.at</a>
call will immediately return <code>nil</code> and the error string “too
many pending timers”.</p>
<p>This directive was first introduced in the <code>v0.8.0</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_max_running_timers">lua_max_running_timers</h2>
<p><strong>syntax:</strong> <em>lua_max_running_timers
&lt;count&gt;</em></p>
<p><strong>default:</strong> <em>lua_max_running_timers 256</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls the maximum number of “running timers” allowed.</p>
<p>Running timers are those timers whose user callback functions are
still running or <code>lightthreads</code> spawned in callback functions
are still running.</p>
<p>When exceeding this limit, Nginx will stop running the callbacks of
newly expired timers and log an error message “N lua_max_running_timers
are not enough” where “N” is the current value of this directive.</p>
<p>This directive was first introduced in the <code>v0.8.0</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2 id="lua_sa_restart">lua_sa_restart</h2>
<p><strong>syntax:</strong> <em>lua_sa_restart on|off</em></p>
<p><strong>default:</strong> <em>lua_sa_restart on</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>When enabled, this module will set the <code>SA_RESTART</code> flag
on Nginx workers signal dispositions.</p>
<p>This allows Lua I/O primitives to not be interrupted by Nginx’s
handling of various signals.</p>
<p>This directive was first introduced in the <code>v0.10.14</code>
release.</p>
<p><a href="#directives">Back to TOC</a></p>
<h2
id="lua_worker_thread_vm_pool_size">lua_worker_thread_vm_pool_size</h2>
<p><strong>syntax:</strong> <em>lua_worker_thread_vm_pool_size
&lt;size&gt;</em></p>
<p><strong>default:</strong> <em>lua_worker_thread_vm_pool_size
10</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Specifies the size limit of the Lua VM pool (default 100) that will
be used in the <a href="#ngxrun_worker_thread">ngx.run_worker_thread</a>
API.</p>
<p>Also, it is not allowed to create Lua VMs that exceeds the pool size
limit.</p>
<p>The Lua VM in the VM pool is used to execute Lua code in separate
thread.</p>
<p>The pool is global at Nginx worker level. And it is used to reuse Lua
VMs between requests.</p>
<p><strong>Warning:</strong> Each worker thread uses a separate Lua VM
and caches the Lua VM for reuse in subsequent operations. Configuring
too many worker threads can result in consuming a lot of memory.</p>
<p><a href="#directives">Back to TOC</a></p>